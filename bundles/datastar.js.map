{
  "version": 3,
  "sources": ["../library/dist/engine/consts.js", "../library/dist/utils/dom.js", "../library/dist/utils/paths.js", "../library/dist/utils/text.js", "../library/dist/engine/errors.js", "../library/dist/engine/types.js", "../library/dist/engine/engine.js", "../library/dist/plugins/actions/peek.js", "../library/dist/plugins/actions/setAll.js", "../library/dist/plugins/actions/toggleAll.js", "../library/dist/plugins/attributes/attr.js", "../library/dist/plugins/attributes/bind.js", "../library/dist/plugins/attributes/class.js", "../library/dist/plugins/attributes/computed.js", "../library/dist/plugins/attributes/effect.js", "../library/dist/plugins/backend/shared.js", "../library/dist/plugins/attributes/indicator.js", "../library/dist/plugins/attributes/jsonSignals.js", "../library/dist/utils/tags.js", "../library/dist/utils/timing.js", "../library/dist/utils/view-transitions.js", "../library/dist/plugins/attributes/on.js", "../library/dist/plugins/attributes/onIntersect.js", "../library/dist/plugins/attributes/onInterval.js", "../library/dist/plugins/attributes/onLoad.js", "../library/dist/plugins/attributes/onSignalPatch.js", "../library/dist/plugins/attributes/ref.js", "../library/dist/plugins/attributes/show.js", "../library/dist/plugins/attributes/signals.js", "../library/dist/plugins/attributes/style.js", "../library/dist/plugins/attributes/text.js", "../library/dist/plugins/backend/actions/fetch.js", "../library/dist/plugins/backend/actions/delete.js", "../library/dist/plugins/backend/actions/get.js", "../library/dist/plugins/backend/actions/patch.js", "../library/dist/plugins/backend/actions/post.js", "../library/dist/plugins/backend/actions/put.js", "../library/dist/plugins/backend/watchers/patchElements.js", "../library/dist/plugins/backend/watchers/patchSignals.js", "../library/dist/bundles/datastar.js"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source;\nexport const DSP = lol.slice(0, 5);\nexport const DSS = lol.slice(4);\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n// #region Defaults\n// #region Default durations\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n// #endregion\n// #region Default strings\n// #endregion\n// #region Default booleans\n// Should elements be patched using the ViewTransition API?\nexport const DefaultElementsUseViewTransitions = false;\n// Should a given set of signals patch if they are missing?\nexport const DefaultPatchSignalsOnlyIfMissing = false;\n// #endregion\n// #region Enums\n// The mode in which a element is patched into the DOM.\n// Morphs the element into the existing element.\nexport const ElementPatchModeOuter = \"outer\";\n// Replaces the inner HTML of the existing element.\nexport const ElementPatchModeInner = \"inner\";\n// Removes the existing element.\nexport const ElementPatchModeRemove = \"remove\";\n// Replaces the existing element with the new element.\nexport const ElementPatchModeReplace = \"replace\";\n// Prepends the element inside to the existing element.\nexport const ElementPatchModePrepend = \"prepend\";\n// Appends the element inside the existing element.\nexport const ElementPatchModeAppend = \"append\";\n// Inserts the element before the existing element.\nexport const ElementPatchModeBefore = \"before\";\n// Inserts the element after the existing element.\nexport const ElementPatchModeAfter = \"after\";\n// Default value for ElementPatchMode\nexport const DefaultElementPatchMode = ElementPatchModeOuter;\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\n// An event for patching HTML elements into the DOM.\nexport const EventTypePatchElements = \"datastar-patch-elements\";\n// An event for patching signals.\nexport const EventTypePatchSignals = \"datastar-patch-signals\";\n// #endregion\n// #endregion\n", "export function isHTMLOrSVG(el) {\n    return el instanceof HTMLElement || el instanceof SVGElement;\n}\n", "export const isPojo = (obj) => obj !== null &&\n    typeof obj === 'object' &&\n    (Object.getPrototypeOf(obj) === Object.prototype ||\n        Object.getPrototypeOf(obj) === null);\nexport function isEmpty(obj) {\n    for (const prop in obj) {\n        if (Object.hasOwn(obj, prop)) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function updateLeaves(obj, fn) {\n    for (const key in obj) {\n        const val = obj[key];\n        if (isPojo(val) || Array.isArray(val)) {\n            updateLeaves(val, fn);\n        }\n        else {\n            obj[key] = fn(val);\n        }\n    }\n}\nexport const pathToObj = (paths) => {\n    const result = {};\n    for (const [path, value] of paths) {\n        const keys = path.split('.');\n        const lastKey = keys.pop();\n        const obj = keys.reduce((acc, key) => (acc[key] ??= {}), result);\n        obj[lastKey] = value;\n    }\n    return result;\n};\n", "export const isBoolString = (str) => str.trim() === 'true';\nexport const kebab = (str) => str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase();\nexport const camel = (str) => kebab(str).replace(/-./g, (x) => x[1].toUpperCase());\nexport const snake = (str) => kebab(str).replace(/-/g, '_');\nexport const pascal = (str) => camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase());\nexport const jsStrToObject = (raw) => {\n    try {\n        return JSON.parse(raw);\n    }\n    catch {\n        // If JSON parsing fails, try to evaluate as a JavaScript object\n        // This is less safe and should be used with caution\n        return Function(`return (${raw})`)();\n    }\n};\nconst caseFns = { kebab, snake, pascal };\nexport function modifyCasing(str, mods) {\n    for (const c of mods.get('case') || []) {\n        const fn = caseFns[c];\n        if (fn)\n            str = fn(str);\n    }\n    return str;\n}\n", "import { snake } from '../utils/text';\nimport { DATASTAR } from './consts';\nconst url = 'https://data-star.dev/errors';\nfunction dserr(type, reason, metadata = {}) {\n    const e = new Error();\n    e.name = `${DATASTAR} ${type} error`;\n    const r = snake(reason);\n    const q = new URLSearchParams({\n        metadata: JSON.stringify(metadata),\n    }).toString();\n    const c = JSON.stringify(metadata, null, 2);\n    e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`;\n    return e;\n}\nexport function internalErr(from, reason, args = {}) {\n    return dserr('internal', reason, Object.assign({ from }, args));\n}\nexport function initErr(ctx, reason, metadata = {}) {\n    const errCtx = {\n        plugin: {\n            name: ctx.plugin.name,\n            type: ctx.plugin.type,\n        },\n    };\n    return dserr('init', reason, Object.assign(errCtx, metadata));\n}\nexport function runtimeErr(ctx, reason, metadata = {}) {\n    const errCtx = {\n        plugin: {\n            name: ctx.plugin.name,\n            type: ctx.plugin.type,\n        },\n        element: {\n            id: ctx.el.id,\n            tag: ctx.el.tagName,\n        },\n        expression: {\n            rawKey: ctx.rawKey,\n            key: ctx.key,\n            value: ctx.value,\n            // validSignals:\n            fnContent: ctx.fnContent,\n        },\n    };\n    return dserr('runtime', reason, Object.assign(errCtx, metadata));\n}\n", "import { DATASTAR } from './consts';\nexport const DATASTAR_SIGNAL_PATCH_EVENT = `${DATASTAR}-signal-patch`;\n", "import { isHTMLOrSVG } from '../utils/dom';\nimport { isPojo, pathToObj } from '../utils/paths';\nimport { camel, snake } from '../utils/text';\nimport { DATASTAR, DSP, DSS } from './consts';\nimport { initErr, runtimeErr } from './errors';\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from './types';\nvar ReactiveFlags;\n(function (ReactiveFlags) {\n    ReactiveFlags[ReactiveFlags[\"None\"] = 0] = \"None\";\n    ReactiveFlags[ReactiveFlags[\"Mutable\"] = 1] = \"Mutable\";\n    ReactiveFlags[ReactiveFlags[\"Watching\"] = 2] = \"Watching\";\n    ReactiveFlags[ReactiveFlags[\"RecursedCheck\"] = 4] = \"RecursedCheck\";\n    ReactiveFlags[ReactiveFlags[\"Recursed\"] = 8] = \"Recursed\";\n    ReactiveFlags[ReactiveFlags[\"Dirty\"] = 16] = \"Dirty\";\n    ReactiveFlags[ReactiveFlags[\"Pending\"] = 32] = \"Pending\";\n})(ReactiveFlags || (ReactiveFlags = {}));\nvar EffectFlags;\n(function (EffectFlags) {\n    EffectFlags[EffectFlags[\"Queued\"] = 64] = \"Queued\";\n})(EffectFlags || (EffectFlags = {}));\nconst currentPatch = [];\nconst queuedEffects = [];\nlet batchDepth = 0;\nlet notifyIndex = 0;\nlet queuedEffectsLength = 0;\nlet activeSub;\nconst startBatch = () => {\n    batchDepth++;\n};\nconst endBatch = () => {\n    if (!--batchDepth) {\n        flush();\n        dispatch();\n    }\n};\nconst signal = (initialValue) => {\n    return signalOper.bind(0, {\n        previousValue: initialValue,\n        value_: initialValue,\n        flags_: 1,\n    });\n};\nconst computedSymbol = Symbol('computed');\nconst computed = (getter) => {\n    const c = computedOper.bind(0, {\n        flags_: 17,\n        getter,\n    });\n    // @ts-ignore\n    c[computedSymbol] = 1;\n    return c;\n};\nconst effect = (fn) => {\n    const e = {\n        fn_: fn,\n        flags_: 2,\n    };\n    if (activeSub) {\n        link(e, activeSub);\n    }\n    const prev = setCurrentSub(e);\n    startBatch();\n    try {\n        e.fn_();\n    }\n    finally {\n        endBatch();\n        setCurrentSub(prev);\n    }\n    return effectOper.bind(0, e);\n};\nconst peek = (fn) => {\n    const prev = setCurrentSub(undefined);\n    try {\n        return fn();\n    }\n    finally {\n        setCurrentSub(prev);\n    }\n};\nconst flush = () => {\n    while (notifyIndex < queuedEffectsLength) {\n        const effect = queuedEffects[notifyIndex];\n        queuedEffects[notifyIndex++] = undefined;\n        run(effect, (effect.flags_ &= ~EffectFlags.Queued));\n    }\n    notifyIndex = 0;\n    queuedEffectsLength = 0;\n};\nconst update = (signal) => {\n    if ('getter' in signal) {\n        return updateComputed(signal);\n    }\n    return updateSignal(signal, signal.value_);\n};\nconst setCurrentSub = (sub) => {\n    const prevSub = activeSub;\n    activeSub = sub;\n    return prevSub;\n};\nconst updateComputed = (c) => {\n    const prevSub = setCurrentSub(c);\n    startTracking(c);\n    try {\n        const oldValue = c.value_;\n        return oldValue !== (c.value_ = c.getter(oldValue));\n    }\n    finally {\n        setCurrentSub(prevSub);\n        endTracking(c);\n    }\n};\nconst updateSignal = (s, value) => {\n    s.flags_ = 1;\n    return s.previousValue !== (s.previousValue = value);\n};\nconst notify = (e) => {\n    const flags = e.flags_;\n    if (!(flags & EffectFlags.Queued)) {\n        e.flags_ = flags | EffectFlags.Queued;\n        const subs = e.subs_;\n        if (subs) {\n            notify(subs.sub_);\n        }\n        else {\n            queuedEffects[queuedEffectsLength++] = e;\n        }\n    }\n};\nconst run = (e, flags) => {\n    if (flags & 16 ||\n        (flags & 32 && checkDirty(e.deps_, e))) {\n        const prev = setCurrentSub(e);\n        startTracking(e);\n        startBatch();\n        try {\n            e.fn_();\n        }\n        finally {\n            endBatch();\n            setCurrentSub(prev);\n            endTracking(e);\n        }\n        return;\n    }\n    if (flags & 32) {\n        e.flags_ = flags & ~32;\n    }\n    let link = e.deps_;\n    while (link) {\n        const dep = link.dep_;\n        const depFlags = dep.flags_;\n        if (depFlags & EffectFlags.Queued) {\n            run(dep, (dep.flags_ = depFlags & ~EffectFlags.Queued));\n        }\n        link = link.nextDep_;\n    }\n};\nconst computedOper = (c) => {\n    const flags = c.flags_;\n    if (flags & 16 ||\n        (flags & 32 && checkDirty(c.deps_, c))) {\n        if (updateComputed(c)) {\n            const subs = c.subs_;\n            if (subs) {\n                shallowPropagate(subs);\n            }\n        }\n    }\n    else if (flags & 32) {\n        c.flags_ = flags & ~32;\n    }\n    if (activeSub) {\n        link(c, activeSub);\n    }\n    return c.value_;\n};\nconst signalOper = (s, ...value) => {\n    if (value.length) {\n        const newValue = value[0];\n        if (s.value_ !== (s.value_ = newValue)) {\n            s.flags_ = 17;\n            const subs = s.subs_;\n            if (subs) {\n                propagate(subs);\n                if (!batchDepth) {\n                    flush();\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    const currentValue = s.value_;\n    if (s.flags_ & 16) {\n        if (updateSignal(s, currentValue)) {\n            const subs_ = s.subs_;\n            if (subs_) {\n                shallowPropagate(subs_);\n            }\n        }\n    }\n    if (activeSub) {\n        link(s, activeSub);\n    }\n    return currentValue;\n};\nconst effectOper = (e) => {\n    let dep = e.deps_;\n    while (dep) {\n        dep = unlink(dep, e);\n    }\n    const sub = e.subs_;\n    if (sub) {\n        unlink(sub);\n    }\n    e.flags_ = 0;\n};\nconst link = (dep, sub) => {\n    const prevDep = sub.depsTail_;\n    if (prevDep && prevDep.dep_ === dep) {\n        return;\n    }\n    let nextDep;\n    const recursedCheck = sub.flags_ & 4;\n    if (recursedCheck) {\n        nextDep = prevDep ? prevDep.nextDep_ : sub.deps_;\n        if (nextDep && nextDep.dep_ === dep) {\n            sub.depsTail_ = nextDep;\n            return;\n        }\n    }\n    const prevSub = dep.subsTail_;\n    if (prevSub &&\n        prevSub.sub_ === sub &&\n        (!recursedCheck || isValidLink(prevSub, sub))) {\n        return;\n    }\n    const newLink = (sub.depsTail_ =\n        dep.subsTail_ =\n            {\n                dep_: dep,\n                sub_: sub,\n                prevDep_: prevDep,\n                nextDep_: nextDep,\n                prevSub_: prevSub,\n            });\n    if (nextDep) {\n        nextDep.prevDep_ = newLink;\n    }\n    if (prevDep) {\n        prevDep.nextDep_ = newLink;\n    }\n    else {\n        sub.deps_ = newLink;\n    }\n    if (prevSub) {\n        prevSub.nextSub_ = newLink;\n    }\n    else {\n        dep.subs_ = newLink;\n    }\n};\nconst unlink = (link, sub_ = link.sub_) => {\n    const dep_ = link.dep_;\n    const prevDep_ = link.prevDep_;\n    const nextDep_ = link.nextDep_;\n    const nextSub_ = link.nextSub_;\n    const prevSub_ = link.prevSub_;\n    if (nextDep_) {\n        nextDep_.prevDep_ = prevDep_;\n    }\n    else {\n        sub_.depsTail_ = prevDep_;\n    }\n    if (prevDep_) {\n        prevDep_.nextDep_ = nextDep_;\n    }\n    else {\n        sub_.deps_ = nextDep_;\n    }\n    if (nextSub_) {\n        nextSub_.prevSub_ = prevSub_;\n    }\n    else {\n        dep_.subsTail_ = prevSub_;\n    }\n    if (prevSub_) {\n        prevSub_.nextSub_ = nextSub_;\n    }\n    else if (!(dep_.subs_ = nextSub_)) {\n        if ('getter' in dep_) {\n            let toRemove = dep_.deps_;\n            if (toRemove) {\n                dep_.flags_ = 17;\n                do {\n                    toRemove = unlink(toRemove, dep_);\n                } while (toRemove);\n            }\n        }\n        else if (!('previousValue' in dep_)) {\n            effectOper(dep_);\n        }\n    }\n    return nextDep_;\n};\nconst propagate = (link) => {\n    let next = link.nextSub_;\n    let stack;\n    top: while (true) {\n        const sub = link.sub_;\n        let flags = sub.flags_;\n        if (flags & 3) {\n            if (!(flags &\n                60)) {\n                sub.flags_ = flags | 32;\n            }\n            else if (!(flags & 12)) {\n                flags = 0;\n            }\n            else if (!(flags & 4)) {\n                sub.flags_ =\n                    (flags & ~8) |\n                        32;\n            }\n            else if (!(flags & 48) &&\n                isValidLink(link, sub)) {\n                sub.flags_ =\n                    flags | 40;\n                flags &= 1;\n            }\n            else {\n                flags = 0;\n            }\n            if (flags & 2) {\n                notify(sub);\n            }\n            if (flags & 1) {\n                const subSubs = sub.subs_;\n                if (subSubs) {\n                    link = subSubs;\n                    if (subSubs.nextSub_) {\n                        stack = { value_: next, prev_: stack };\n                        next = link.nextSub_;\n                    }\n                    continue;\n                }\n            }\n        }\n        if ((link = next)) {\n            next = link.nextSub_;\n            continue;\n        }\n        while (stack) {\n            link = stack.value_;\n            stack = stack.prev_;\n            if (link) {\n                next = link.nextSub_;\n                continue top;\n            }\n        }\n        break;\n    }\n};\nconst startTracking = (sub) => {\n    sub.depsTail_ = undefined;\n    sub.flags_ =\n        (sub.flags_ &\n            ~56) |\n            4;\n};\nconst endTracking = (sub) => {\n    const depsTail_ = sub.depsTail_;\n    let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_;\n    while (toRemove) {\n        toRemove = unlink(toRemove, sub);\n    }\n    sub.flags_ &= ~4;\n};\nconst checkDirty = (link, sub) => {\n    let stack;\n    let checkDepth = 0;\n    top: while (true) {\n        const dep = link.dep_;\n        const depFlags = dep.flags_;\n        let dirty = false;\n        if (sub.flags_ & 16) {\n            dirty = true;\n        }\n        else if ((depFlags & 17) ===\n            17) {\n            if (update(dep)) {\n                const subs = dep.subs_;\n                if (subs.nextSub_) {\n                    shallowPropagate(subs);\n                }\n                dirty = true;\n            }\n        }\n        else if ((depFlags & 33) ===\n            33) {\n            if (link.nextSub_ || link.prevSub_) {\n                stack = { value_: link, prev_: stack };\n            }\n            link = dep.deps_;\n            sub = dep;\n            ++checkDepth;\n            continue;\n        }\n        if (!dirty && link.nextDep_) {\n            link = link.nextDep_;\n            continue;\n        }\n        while (checkDepth) {\n            --checkDepth;\n            const firstSub = sub.subs_;\n            const hasMultipleSubs = firstSub.nextSub_;\n            if (hasMultipleSubs) {\n                link = stack.value_;\n                stack = stack.prev_;\n            }\n            else {\n                link = firstSub;\n            }\n            if (dirty) {\n                if (update(sub)) {\n                    if (hasMultipleSubs) {\n                        shallowPropagate(firstSub);\n                    }\n                    sub = link.sub_;\n                    continue;\n                }\n            }\n            else {\n                sub.flags_ &= ~32;\n            }\n            sub = link.sub_;\n            if (link.nextDep_) {\n                link = link.nextDep_;\n                continue top;\n            }\n            dirty = false;\n        }\n        return dirty;\n    }\n};\nconst shallowPropagate = (link) => {\n    do {\n        const sub = link.sub_;\n        const nextSub = link.nextSub_;\n        const subFlags = sub.flags_;\n        if ((subFlags & 48) ===\n            32) {\n            sub.flags_ = subFlags | 16;\n            if (subFlags & 2) {\n                notify(sub);\n            }\n        }\n        link = nextSub;\n    } while (link);\n};\nconst isValidLink = (checkLink, sub) => {\n    const depsTail = sub.depsTail_;\n    if (depsTail) {\n        let link = sub.deps_;\n        do {\n            if (link === checkLink) {\n                return true;\n            }\n            if (link === depsTail) {\n                break;\n            }\n            link = link.nextDep_;\n        } while (link);\n    }\n    return false;\n};\nconst getPath = (path) => {\n    let result = root;\n    const split = path.split('.');\n    for (const path of split) {\n        if (result == null || !Object.hasOwn(result, path)) {\n            return;\n        }\n        result = result[path];\n    }\n    return result;\n};\nexport const DELETE = Symbol('delete');\nconst deep = (value, prefix = '') => {\n    const isArr = Array.isArray(value);\n    if (isArr || isPojo(value)) {\n        const deepObj = (isArr ? [] : {});\n        for (const key in value) {\n            deepObj[key] = signal(deep(value[key], `${prefix + key}.`));\n        }\n        const keys = signal(0);\n        return new Proxy(deepObj, {\n            get(_, prop) {\n                if (!(prop === 'toJSON' && !Object.hasOwn(deepObj, prop))) {\n                    if (isArr && prop in Array.prototype) {\n                        keys();\n                        return deepObj[prop];\n                    }\n                    else {\n                        if (typeof prop === 'symbol') {\n                            return deepObj[prop];\n                        }\n                        if (!Object.hasOwn(deepObj, prop) || deepObj[prop]() == null) {\n                            deepObj[prop] = signal('');\n                            dispatch(prefix + prop, '');\n                            keys(keys() + 1);\n                        }\n                        return deepObj[prop]();\n                    }\n                }\n            },\n            set(_, prop, newValue) {\n                const path = prefix + prop;\n                if (newValue === DELETE) {\n                    if (Object.hasOwn(deepObj, prop)) {\n                        delete deepObj[prop];\n                        dispatch(path, DELETE);\n                        keys(keys() + 1);\n                    }\n                }\n                else {\n                    if (isArr && prop === 'length') {\n                        const diff = deepObj[prop] - newValue;\n                        deepObj[prop] = newValue;\n                        if (diff > 0) {\n                            const patch = {};\n                            for (let i = newValue; i < deepObj[prop]; i++) {\n                                patch[i] = null;\n                            }\n                            dispatch(prefix.slice(0, -1), patch);\n                            keys(keys() + 1);\n                        }\n                    }\n                    else {\n                        if (Object.hasOwn(deepObj, prop)) {\n                            if (newValue == null) {\n                                if (deepObj[prop](null)) {\n                                    dispatch(path, null);\n                                }\n                            }\n                            else {\n                                if (Object.hasOwn(newValue, computedSymbol)) {\n                                    deepObj[prop] = newValue;\n                                    dispatch(path, '');\n                                }\n                                else {\n                                    if (deepObj[prop](deep(newValue, `${path}.`))) {\n                                        dispatch(path, newValue);\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            if (newValue != null) {\n                                if (Object.hasOwn(newValue, computedSymbol)) {\n                                    deepObj[prop] = newValue;\n                                    dispatch(path, '');\n                                }\n                                else {\n                                    deepObj[prop] = signal(deep(newValue, `${path}.`));\n                                    dispatch(path, newValue);\n                                }\n                                keys(keys() + 1);\n                            }\n                        }\n                    }\n                }\n                return true;\n            },\n            deleteProperty(_, prop) {\n                if (Object.hasOwn(deepObj, prop)) {\n                    if (deepObj[prop](null)) {\n                        dispatch(prefix + prop, null);\n                    }\n                }\n                return true;\n            },\n            ownKeys() {\n                keys();\n                return Reflect.ownKeys(deepObj);\n            },\n            has(_, prop) {\n                keys();\n                return prop in deepObj;\n            },\n        });\n    }\n    return value;\n};\nconst dispatch = (path, value) => {\n    if (path !== undefined && value !== undefined) {\n        currentPatch.push([path, value]);\n    }\n    if (!batchDepth && currentPatch.length) {\n        const detail = pathToObj(currentPatch);\n        currentPatch.length = 0;\n        document.dispatchEvent(new CustomEvent(DATASTAR_SIGNAL_PATCH_EVENT, {\n            detail,\n        }));\n    }\n};\nconst mergePatch = (patch, { ifMissing } = {}) => {\n    startBatch();\n    for (const key in patch) {\n        if (patch[key] == null) {\n            if (!ifMissing) {\n                delete root[key];\n            }\n        }\n        else {\n            mergeInner(patch[key], key, root, '', ifMissing);\n        }\n    }\n    endBatch();\n};\nconst mergePaths = (paths, options = {}) => mergePatch(pathToObj(paths), options);\nconst mergeInner = (patch, target, targetParent, prefix, ifMissing) => {\n    if (isPojo(patch)) {\n        if (!(Object.hasOwn(targetParent, target) &&\n            (isPojo(targetParent[target]) || Array.isArray(targetParent[target])))) {\n            targetParent[target] = {};\n        }\n        for (const key in patch) {\n            if (patch[key] == null) {\n                if (!ifMissing) {\n                    delete targetParent[target][key];\n                }\n            }\n            else {\n                mergeInner(patch[key], key, targetParent[target], `${prefix + target}.`, ifMissing);\n            }\n        }\n    }\n    else if (!(ifMissing && Object.hasOwn(targetParent, target))) {\n        targetParent[target] = patch;\n    }\n};\nfunction filtered({ include = /.*/, exclude = /(?!)/ } = {}, obj = root) {\n    // We need to find all valid signal paths in the object\n    const paths = [];\n    const stack = [[obj, '']];\n    while (stack.length) {\n        const [node, prefix] = stack.pop();\n        for (const key in node) {\n            const path = prefix + key;\n            if (isPojo(node[key])) {\n                stack.push([node[key], `${path}.`]);\n            }\n            else if (toRegExp(include).test(path) &&\n                !toRegExp(exclude).test(path)) {\n                paths.push([path, getPath(path)]);\n            }\n        }\n    }\n    return pathToObj(paths);\n}\nfunction toRegExp(val) {\n    if (typeof val === 'string') {\n        return RegExp(val.replace(/^\\/|\\/$/g, ''));\n    }\n    return val;\n}\nconst root = deep({});\n/**\n * Turn data-* attributes into reactive expressions\n * This is the core of the Datastar\n */\nconst actions = {};\nconst plugins = [];\nlet pluginRegexs = [];\n// Map of cleanup functions by element, keyed by a dataset key-value hash\nconst removals = new Map();\nlet mutationObserver = null;\nlet alias = '';\nexport function setAlias(value) {\n    alias = value;\n}\nexport function aliasify(name) {\n    return alias ? `data-${alias}-${name}` : `data-${name}`;\n}\nexport function load(...pluginsToLoad) {\n    for (const plugin of pluginsToLoad) {\n        const ctx = {\n            plugin,\n            actions,\n            root,\n            filtered,\n            signal,\n            computed,\n            effect,\n            mergePatch,\n            mergePaths,\n            peek,\n            getPath,\n            startBatch,\n            endBatch,\n            initErr: 0,\n        };\n        ctx.initErr = initErr.bind(0, ctx);\n        if (plugin.type === 'action') {\n            actions[plugin.name] = plugin;\n        }\n        else if (plugin.type === 'attribute') {\n            plugins.push(plugin);\n            plugin.onGlobalInit?.(ctx);\n        }\n        else if (plugin.type === 'watcher') {\n            plugin.onGlobalInit?.(ctx);\n        }\n        else {\n            throw ctx.initErr('InvalidPluginType');\n        }\n    }\n    // Sort attribute plugins by descending length then alphabetically\n    plugins.sort((a, b) => {\n        const lenDiff = b.name.length - a.name.length;\n        if (lenDiff !== 0)\n            return lenDiff;\n        return a.name.localeCompare(b.name);\n    });\n    pluginRegexs = plugins.map((plugin) => RegExp(`^${plugin.name}([A-Z]|_|$)`));\n}\nfunction applyEls(els) {\n    const ignore = `[${aliasify('ignore')}]`;\n    for (const el of els) {\n        if (!el.closest(ignore)) {\n            for (const key in el.dataset) {\n                applyAttributePlugin(el, key, el.dataset[key]);\n            }\n        }\n    }\n}\nfunction cleanupEls(els) {\n    for (const el of els) {\n        const cleanups = removals.get(el);\n        // If removals has el, delete it and run all cleanup functions\n        if (removals.delete(el)) {\n            for (const cleanup of cleanups.values()) {\n                cleanup();\n            }\n            cleanups.clear();\n        }\n    }\n}\n// Apply all plugins to the entire DOM or a provided element\nexport function apply(root = document.body) {\n    // Delay applying plugins to give custom plugins a chance to load\n    queueMicrotask(() => {\n        applyEls([root]);\n        applyEls(root.querySelectorAll('*'));\n        // Monitor the entire document body or a provided element for changes\n        // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n        if (!mutationObserver) {\n            mutationObserver = new MutationObserver(observe);\n            mutationObserver.observe(root, {\n                subtree: true,\n                childList: true,\n                attributes: true,\n            });\n        }\n    });\n}\nfunction applyAttributePlugin(el, attrKey, value) {\n    if (attrKey.startsWith(alias)) {\n        const rawKey = camel(alias ? attrKey.slice(alias.length) : attrKey);\n        const plugin = plugins.find((_, i) => pluginRegexs[i].test(rawKey));\n        if (plugin) {\n            // Extract the key and modifiers\n            let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/__+/);\n            const hasKey = !!key;\n            if (hasKey) {\n                key = camel(key);\n            }\n            const hasValue = !!value;\n            // Create the runtime context\n            const ctx = {\n                plugin,\n                actions,\n                root,\n                filtered,\n                signal,\n                computed,\n                effect,\n                mergePatch,\n                mergePaths,\n                peek,\n                getPath,\n                startBatch,\n                endBatch,\n                initErr: 0,\n                el,\n                rawKey,\n                key,\n                value,\n                mods: new Map(),\n                runtimeErr: 0,\n                rx: 0,\n            };\n            ctx.initErr = initErr.bind(0, ctx);\n            ctx.runtimeErr = runtimeErr.bind(0, ctx);\n            if (plugin.shouldEvaluate === undefined ||\n                plugin.shouldEvaluate === true) {\n                ctx.rx = generateReactiveExpression(ctx);\n            }\n            // Check the requirements\n            const keyReq = plugin.keyReq || 'allowed';\n            if (hasKey) {\n                if (keyReq === 'denied') {\n                    throw ctx.runtimeErr(`${plugin.name}KeyNotAllowed`);\n                }\n            }\n            else if (keyReq === 'must') {\n                throw ctx.runtimeErr(`${plugin.name}KeyRequired`);\n            }\n            const valReq = plugin.valReq || 'allowed';\n            if (hasValue) {\n                if (valReq === 'denied') {\n                    throw ctx.runtimeErr(`${plugin.name}ValueNotAllowed`);\n                }\n            }\n            else if (valReq === 'must') {\n                throw ctx.runtimeErr(`${plugin.name}ValueRequired`);\n            }\n            // Check for exclusive requirements\n            if (keyReq === 'exclusive' || valReq === 'exclusive') {\n                if (hasKey && hasValue) {\n                    throw ctx.runtimeErr(`${plugin.name}KeyAndValueProvided`);\n                }\n                if (!hasKey && !hasValue) {\n                    throw ctx.runtimeErr(`${plugin.name}KeyOrValueRequired`);\n                }\n            }\n            for (const rawMod of rawModifiers) {\n                const [label, ...mod] = rawMod.split('.');\n                ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())));\n            }\n            const cleanup = plugin.onLoad(ctx);\n            if (cleanup) {\n                let cleanups = removals.get(el);\n                if (cleanups) {\n                    cleanups.get(rawKey)?.();\n                }\n                else {\n                    cleanups = new Map();\n                    removals.set(el, cleanups);\n                }\n                cleanups.set(rawKey, cleanup);\n            }\n        }\n    }\n}\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe(mutations) {\n    const ignore = `[${aliasify('ignore')}]`;\n    for (const { target, type, attributeName, addedNodes, removedNodes, } of mutations) {\n        if (type === 'childList') {\n            for (const node of removedNodes) {\n                if (isHTMLOrSVG(node)) {\n                    cleanupEls([node]);\n                    cleanupEls(node.querySelectorAll('*'));\n                }\n            }\n            for (const node of addedNodes) {\n                if (isHTMLOrSVG(node)) {\n                    applyEls([node]);\n                    applyEls(node.querySelectorAll('*'));\n                }\n            }\n        }\n        else if (type === 'attributes') {\n            // If el has a parent with data-ignore, skip it\n            if (isHTMLOrSVG(target) && !target.closest(ignore)) {\n                const key = camel(attributeName.slice(5));\n                const value = target.getAttribute(attributeName);\n                if (value === null) {\n                    const cleanups = removals.get(target);\n                    if (cleanups) {\n                        cleanups.get(key)?.();\n                        cleanups.delete(key);\n                    }\n                }\n                else {\n                    applyAttributePlugin(target, key, value);\n                }\n            }\n        }\n    }\n}\nfunction generateReactiveExpression(ctx) {\n    let expr = '';\n    const attrPlugin = ctx.plugin || undefined;\n    // plugin is guaranteed to be an attribute plugin\n    if (attrPlugin?.returnsValue) {\n        // This regex allows Datastar expressions to support nested\n        // regex and strings that contain ; without breaking.\n        //\n        // Each of these regex defines a block type we want to match\n        // (importantly we ignore the content within these blocks):\n        //\n        // regex            \\/(\\\\\\/|[^\\/])*\\/\n        // double quotes      \"(\\\\\"|[^\\\"])*\"\n        // single quotes      '(\\\\'|[^'])*'\n        // ticks              `(\\\\`|[^`])*`\n        // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n        //\n        // The iife support is (intentionally) limited. It only supports\n        // function and arrow syntax with no arguments, and no nested IIFEs.\n        //\n        // We also want to match the non delimiter part of statements\n        // note we only support ; statement delimiters:\n        //\n        // [^;]\n        //\n        const statementRe = /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm;\n        const statements = ctx.value.trim().match(statementRe);\n        if (statements) {\n            const lastIdx = statements.length - 1;\n            const last = statements[lastIdx].trim();\n            if (!last.startsWith('return')) {\n                statements[lastIdx] = `return (${last});`;\n            }\n            expr = statements.join(';\\n');\n        }\n    }\n    else {\n        expr = ctx.value.trim();\n    }\n    // Replace signal references with bracket notation\n    // Examples:\n    //   $count          \u2192 $['count']\n    //   $count--        \u2192 $['count']--\n    //   $count++        \u2192 $['count']++\n    //   $count += 5     \u2192 $['count'] += 5\n    //   $foo = 5        \u2192 $['foo'] = 5\n    //   $foo.bar        \u2192 $['foo']['bar']\n    //   $foo-bar        \u2192 $['foo-bar']\n    //   $foo.bar-baz    \u2192 $['foo']['bar-baz']\n    //   $foo-$bar       \u2192 $['foo']-$['bar']\n    //   $arr[$index]    \u2192 $['arr'][$['index']]\n    //   $['foo']        \u2192 $['foo']\n    //   $foo[obj.bar]   \u2192 $['foo'][obj.bar]\n    //   $foo['bar.baz'] \u2192 $['foo']['bar.baz']\n    //   $1              \u2192 $['1']\n    //   $123            \u2192 $['123']\n    //   $foo.0.name     \u2192 $['foo']['0']['name']\n    //   $foo.0.1.2.bar.0 \u2192 $['foo']['0']['1']['2']['bar']['0']\n    // Transform all signal patterns\n    expr = expr\n        // $['x'] \u2192 $x (normalize existing bracket notation)\n        .replace(/\\$\\['([a-zA-Z_$\\d][\\w$]*)'\\]/g, '$$$1')\n        // $x \u2192 $['x'] (including dots and hyphens)\n        .replace(/\\$([a-zA-Z_\\d]\\w*(?:[.-]\\w+)*)/g, (_, signalName) => {\n        const parts = signalName.split('.');\n        return parts.reduce((acc, part) => `${acc}['${part}']`, '$');\n    })\n        // $ inside brackets: [$x] \u2192 [$['x']]\n        .replace(/\\[(\\$[a-zA-Z_\\d]\\w*)\\]/g, (_, varName) => `[$['${varName.slice(1)}']]`);\n    // Ignore any escaped values\n    const escaped = new Map();\n    const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm');\n    let counter = 0;\n    for (const match of expr.matchAll(escapeRe)) {\n        const k = match[1];\n        const v = `dsEscaped${counter++}`;\n        escaped.set(v, k);\n        expr = expr.replace(DSP + k + DSS, v);\n    }\n    const nameGen = (prefix, name) => {\n        return `${prefix}${snake(name).replaceAll(/\\./g, '_')}`;\n    };\n    // Replace any action calls\n    const actionsCalled = new Set();\n    const actionsRe = RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm');\n    const actionMatches = [...expr.matchAll(actionsRe)];\n    const actionNames = new Set();\n    const actionFns = new Set();\n    if (actionMatches.length) {\n        const actionPrefix = `${DATASTAR}Act_`;\n        for (const match of actionMatches) {\n            const actionName = match[1];\n            const action = actions[actionName];\n            if (!action) {\n                continue;\n            }\n            actionsCalled.add(actionName);\n            const name = nameGen(actionPrefix, actionName);\n            // Add ctx to action calls\n            expr = expr.replace(`@${actionName}(`, `${name}(`);\n            actionNames.add(name);\n            actionFns.add((...args) => action.fn(ctx, ...args));\n        }\n    }\n    // Replace any escaped values\n    for (const [k, v] of escaped) {\n        expr = expr.replace(k, v);\n    }\n    ctx.fnContent = expr;\n    try {\n        const fn = Function('el', '$', ...(attrPlugin?.argNames || []), ...actionNames, expr);\n        return (...args) => {\n            try {\n                return fn(ctx.el, root, ...args, ...actionFns);\n            }\n            catch (e) {\n                throw ctx.runtimeErr('ExecuteExpression', {\n                    error: e.message,\n                });\n            }\n        };\n    }\n    catch (error) {\n        throw ctx.runtimeErr('GenerateExpression', {\n            error: error.message,\n        });\n    }\n}\n", "// Icon: ion:eye\n// Slug: Access signals without subscribing to changes.\n// Description: Allows accessing signals without subscribing to their changes in expressions.\nexport const Peek = {\n    type: 'action',\n    name: 'peek',\n    fn: ({ peek }, fn) => {\n        return peek(fn);\n    },\n};\n", "// Icon: ion:checkmark-round\n// Slug: Sets the value of all matching signals.\n// Description: Sets the value of all matching signals (or all signals if no filter is used) to the expression provided in the first argument.\nimport { updateLeaves } from '../../utils/paths';\nexport const SetAll = {\n    type: 'action',\n    name: 'setAll',\n    fn: ({ filtered, mergePatch, peek }, value, filter) => {\n        peek(() => {\n            const masked = filtered(filter);\n            updateLeaves(masked, () => value);\n            mergePatch(masked);\n        });\n    },\n};\n", "// Icon: material-symbols:toggle-off\n// Slug: Toggles the value of all matching signals.\n// Description: Toggles the boolean value of all matching signals (or all signals if no filter is used).\nimport { updateLeaves } from '../../utils/paths';\nexport const ToggleAll = {\n    type: 'action',\n    name: 'toggleAll',\n    fn: ({ filtered, mergePatch, peek }, filter) => {\n        peek(() => {\n            const masked = filtered(filter);\n            updateLeaves(masked, (oldValue) => !oldValue);\n            mergePatch(masked);\n        });\n    },\n};\n", "// Icon: material-symbols:edit-attributes-outline\n// Slug: Syncs the value of an attribute with an expression.\n// Description: Sets the value of any HTML attribute to an expression, and keeps it in sync.\nimport { kebab } from '../../utils/text';\nexport const Attr = {\n    type: 'attribute',\n    name: 'attr',\n    valReq: 'must',\n    returnsValue: true,\n    onLoad: ({ el, effect, key, rx }) => {\n        const syncAttr = (key, val) => {\n            if (val === '' || val === true) {\n                el.setAttribute(key, '');\n            }\n            else if (val === false || val == null) {\n                el.removeAttribute(key);\n            }\n            else if (typeof val === 'string') {\n                el.setAttribute(key, val);\n            }\n            else {\n                el.setAttribute(key, JSON.stringify(val));\n            }\n        };\n        key = kebab(key);\n        const update = key\n            ? () => {\n                observer.disconnect();\n                const val = rx();\n                syncAttr(key, val);\n                observer.observe(el, {\n                    attributeFilter: [key],\n                });\n            }\n            : () => {\n                observer.disconnect();\n                const obj = rx();\n                const attributeFilter = Object.keys(obj);\n                for (const key of attributeFilter) {\n                    syncAttr(key, obj[key]);\n                }\n                observer.observe(el, {\n                    attributeFilter,\n                });\n            };\n        const observer = new MutationObserver(update);\n        const cleanup = effect(update);\n        return () => {\n            observer.disconnect();\n            cleanup();\n        };\n    },\n};\n", "// Icon: akar-icons:link-chain\n// Slug: Creates a signal with two-way data binding.\n// Description: Creates a signal (if one doesn\u2019t already exist) and sets up two-way data binding between it and an element\u2019s value.\nimport { aliasify } from '../../engine/engine';\nimport { modifyCasing } from '../../utils/text';\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/;\nconst empty = Symbol('empty');\nexport const Bind = {\n    type: 'attribute',\n    name: 'bind',\n    keyReq: 'exclusive',\n    valReq: 'exclusive',\n    shouldEvaluate: false,\n    onLoad: ({ el, key, mods, value, effect, mergePaths, runtimeErr, getPath, }) => {\n        const signalName = key ? modifyCasing(key, mods) : value;\n        let get = (el, type) => type === 'number' ? +el.value : el.value;\n        let set = (value) => {\n            ;\n            el.value = `${value}`;\n        };\n        if (el instanceof HTMLInputElement) {\n            switch (el.type) {\n                case 'range':\n                case 'number':\n                    get = (el, type) => type === 'string' ? el.value : +el.value;\n                    break;\n                case 'checkbox':\n                    get = (el, type) => {\n                        if (el.value !== 'on') {\n                            if (type === 'boolean') {\n                                return el.checked;\n                            }\n                            else {\n                                return el.checked ? el.value : '';\n                            }\n                        }\n                        else {\n                            if (type === 'string') {\n                                return el.checked ? el.value : '';\n                            }\n                            else {\n                                return el.checked;\n                            }\n                        }\n                    };\n                    set = (value) => {\n                        el.checked = typeof value === 'string' ? value === el.value : value;\n                    };\n                    break;\n                case 'radio':\n                    // Set up radio button name attribute if not present\n                    if (!el.getAttribute('name')?.length) {\n                        el.setAttribute('name', signalName);\n                    }\n                    get = (el, type) => el.checked ? (type === 'number' ? +el.value : el.value) : empty;\n                    set = (value) => {\n                        el.checked =\n                            value === (typeof value === 'number' ? +el.value : el.value);\n                    };\n                    break;\n                case 'file': {\n                    const syncSignal = () => {\n                        const files = [...(el.files || [])];\n                        const contents = [];\n                        const mimes = [];\n                        const names = [];\n                        Promise.all(files.map((f) => new Promise((resolve) => {\n                            const reader = new FileReader();\n                            reader.onload = () => {\n                                if (typeof reader.result !== 'string') {\n                                    throw runtimeErr('InvalidFileResultType', {\n                                        resultType: typeof reader.result,\n                                    });\n                                }\n                                const match = reader.result.match(dataURIRegex);\n                                if (!match?.groups) {\n                                    throw runtimeErr('InvalidDataUri', {\n                                        result: reader.result,\n                                    });\n                                }\n                                contents.push(match.groups.contents);\n                                mimes.push(match.groups.mime);\n                                names.push(f.name);\n                            };\n                            reader.onloadend = () => resolve();\n                            reader.readAsDataURL(f);\n                        }))).then(() => {\n                            mergePaths([\n                                [signalName, contents],\n                                [`${signalName}Mimes`, mimes],\n                                [`${signalName}Names`, names],\n                            ]);\n                        });\n                    };\n                    el.addEventListener('change', syncSignal);\n                    el.addEventListener('input', syncSignal);\n                    return () => {\n                        el.removeEventListener('change', syncSignal);\n                        el.removeEventListener('input', syncSignal);\n                    };\n                }\n            }\n        }\n        else if (el instanceof HTMLSelectElement) {\n            if (el.multiple) {\n                const typeMap = new Map();\n                get = (el) => [...el.selectedOptions].map((option) => {\n                    const type = typeMap.get(option.value);\n                    return type === 'string' || type == null\n                        ? option.value\n                        : +option.value;\n                });\n                set = (value) => {\n                    for (const option of el.options) {\n                        if (value.includes(option.value)) {\n                            typeMap.set(option.value, 'string');\n                            option.selected = true;\n                        }\n                        else if (value.includes(+option.value)) {\n                            typeMap.set(option.value, 'number');\n                            option.selected = true;\n                        }\n                        else {\n                            option.selected = false;\n                        }\n                    }\n                };\n            }\n        }\n        else if (el instanceof HTMLTextAreaElement) {\n            // default case\n        }\n        else {\n            // web component\n            get = (el) => 'value' in el ? el.value : el.getAttribute('value');\n            set = (value) => {\n                if ('value' in el) {\n                    el.value = value;\n                }\n                else {\n                    el.setAttribute('value', value);\n                }\n            };\n        }\n        const initialValue = getPath(signalName);\n        const type = typeof initialValue;\n        let path = signalName;\n        if (Array.isArray(initialValue) &&\n            !(el instanceof HTMLSelectElement && el.multiple)) {\n            const inputs = document.querySelectorAll(`[${aliasify('bind')}-${key}],[${aliasify('bind')}=\"${value}\"]`);\n            const paths = [];\n            let i = 0;\n            for (const input of inputs) {\n                paths.push([`${path}.${i}`, get(input, 'none')]);\n                if (el === input) {\n                    break;\n                }\n                i++;\n            }\n            mergePaths(paths, { ifMissing: true });\n            path = `${path}.${i}`;\n        }\n        else {\n            mergePaths([[path, get(el, type)]], {\n                ifMissing: true,\n            });\n        }\n        const syncSignal = () => {\n            const signalValue = getPath(path);\n            if (signalValue != null) {\n                const value = get(el, typeof signalValue);\n                if (value !== empty) {\n                    mergePaths([[path, value]]);\n                }\n            }\n        };\n        el.addEventListener('input', syncSignal);\n        el.addEventListener('change', syncSignal);\n        const cleanup = effect(() => {\n            set(getPath(path));\n        });\n        return () => {\n            cleanup();\n            el.removeEventListener('input', syncSignal);\n            el.removeEventListener('change', syncSignal);\n        };\n    },\n};\n", "// Icon: ic:baseline-format-paint\n// Slug: Adds or removes a class based on an expression.\n// Description: Adds or removes a class to or from an element based on an expression.\nimport { kebab, modifyCasing } from '../../utils/text';\nexport const Class = {\n    type: 'attribute',\n    name: 'class',\n    valReq: 'must',\n    returnsValue: true,\n    onLoad: ({ key, el, effect, mods, rx }) => {\n        if (key) {\n            key = modifyCasing(kebab(key), mods);\n        }\n        const callback = () => {\n            observer.disconnect();\n            const classes = key\n                ? { [key]: rx() }\n                : rx();\n            for (const k in classes) {\n                const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0);\n                if (classes[k]) {\n                    for (const name of classNames) {\n                        if (!el.classList.contains(name)) {\n                            el.classList.add(name);\n                        }\n                    }\n                }\n                else {\n                    for (const name of classNames) {\n                        if (el.classList.contains(name)) {\n                            el.classList.remove(name);\n                        }\n                    }\n                }\n            }\n            observer.observe(el, { attributeFilter: ['class'] });\n        };\n        const observer = new MutationObserver(callback);\n        const cleanup = effect(callback);\n        return () => {\n            observer.disconnect();\n            cleanup();\n            const classes = key\n                ? { [key]: rx() }\n                : rx();\n            for (const k in classes) {\n                const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0);\n                for (const name of classNames) {\n                    el.classList.remove(name);\n                }\n            }\n        };\n    },\n};\n", "// Icon: streamline-ultimate:wifi-signal-2\n// Slug: Creates a computed signal.\n// Description: Creates a signal that is computed based on an expression.\nimport { modifyCasing } from '../../utils/text';\nexport const Computed = {\n    type: 'attribute',\n    name: 'computed',\n    keyReq: 'must',\n    valReq: 'must',\n    returnsValue: true,\n    onLoad: ({ key, mods, rx, computed, mergePaths }) => {\n        mergePaths([[modifyCasing(key, mods), computed(rx)]]);\n    },\n};\n", "// Icon: oui:security-signal\n// Slug: Executes an expression when signals change.\n// Description: Executes an expression on page load and whenever any signals in the expression change.\nexport const Effect = {\n    type: 'attribute',\n    name: 'effect',\n    keyReq: 'denied',\n    valReq: 'must',\n    onLoad: ({ effect, rx }) => effect(rx),\n};\n", "import { DATASTAR } from '../../engine/consts';\nexport const DATASTAR_FETCH_EVENT = `${DATASTAR}-fetch`;\nexport const STARTED = 'started';\nexport const FINISHED = 'finished';\nexport const ERROR = 'error';\nexport const RETRYING = 'retrying';\nexport const RETRIES_FAILED = 'retries-failed';\nexport function datastarSSEEventWatcher(eventType, fn) {\n    document.addEventListener(DATASTAR_FETCH_EVENT, (event) => {\n        if (event.detail.type === eventType) {\n            const { argsRaw } = event.detail;\n            fn(argsRaw);\n        }\n    });\n}\n", "// Icon: streamline:signal-loading-remix\n// Slug: Creates an indicator for whether an SSE request is in flight.\n// Description: Creates a signal and sets its value to `true` while an SSE request request is in flight, otherwise `false`.\nimport { modifyCasing } from '../../utils/text';\nimport { DATASTAR_FETCH_EVENT, FINISHED, STARTED, } from '../backend/shared';\nexport const Indicator = {\n    type: 'attribute',\n    name: 'indicator',\n    keyReq: 'exclusive',\n    valReq: 'exclusive',\n    shouldEvaluate: false,\n    onLoad: ({ el, key, mods, mergePaths, value }) => {\n        const signalName = key ? modifyCasing(key, mods) : value;\n        mergePaths([[signalName, false]], { ifMissing: true });\n        const watcher = ((event) => {\n            const { type, el: elt } = event.detail;\n            if (elt !== el) {\n                return;\n            }\n            switch (type) {\n                case STARTED:\n                    mergePaths([[signalName, true]]);\n                    break;\n                case FINISHED:\n                    mergePaths([[signalName, false]]);\n                    break;\n            }\n        });\n        document.addEventListener(DATASTAR_FETCH_EVENT, watcher);\n        return () => {\n            mergePaths([[signalName, false]]);\n            document.removeEventListener(DATASTAR_FETCH_EVENT, watcher);\n        };\n    },\n};\n", "// Icon: si:json-fill\n// Slug: Outputs a JSON stringified version of signals.\n// Description: Sets the text content of an element to a reactive JSON stringified version of signals.\nimport { jsStrToObject } from '../../utils/text';\nexport const JsonSignals = {\n    type: 'attribute',\n    name: 'jsonSignals',\n    keyReq: 'denied',\n    onLoad: ({ el, effect, value, filtered, mods }) => {\n        const spaces = mods.has('terse') ? 0 : 2;\n        let filters = {};\n        if (value) {\n            filters = jsStrToObject(value);\n        }\n        const callback = () => {\n            observer.disconnect();\n            el.textContent = JSON.stringify(filtered(filters), null, spaces);\n            observer.observe(el, {\n                childList: true,\n                characterData: true,\n                subtree: true,\n            });\n        };\n        const observer = new MutationObserver(callback);\n        const cleanup = effect(callback);\n        return () => {\n            observer.disconnect();\n            cleanup();\n        };\n    },\n};\n", "export function tagToMs(args) {\n    if (!args || args.size <= 0)\n        return 0;\n    for (const arg of args) {\n        if (arg.endsWith('ms')) {\n            return +arg.replace('ms', '');\n        }\n        if (arg.endsWith('s')) {\n            return +arg.replace('s', '') * 1000;\n        }\n        try {\n            return Number.parseFloat(arg);\n        }\n        catch (_) { }\n    }\n    return 0;\n}\nexport function tagHas(tags, tag, defaultValue = false) {\n    if (!tags)\n        return defaultValue;\n    return tags.has(tag.toLowerCase());\n}\nexport function tagFirst(tags, defaultValue = '') {\n    if (tags && tags.size > 0) {\n        for (const tag of tags) {\n            return tag;\n        }\n    }\n    return defaultValue;\n}\n", "import { tagHas, tagToMs } from './tags';\nexport function delay(callback, wait) {\n    return (...args) => {\n        setTimeout(() => {\n            callback(...args);\n        }, wait);\n    };\n}\nexport function debounce(callback, wait, leading = false, trailing = true) {\n    let timer = 0;\n    return (...args) => {\n        timer && clearTimeout(timer);\n        if (leading && !timer) {\n            callback(...args);\n        }\n        timer = setTimeout(() => {\n            if (trailing) {\n                callback(...args);\n            }\n            timer && clearTimeout(timer);\n        }, wait);\n    };\n}\nexport function throttle(callback, wait, leading = true, trailing = false) {\n    let waiting = false;\n    return (...args) => {\n        if (waiting)\n            return;\n        if (leading) {\n            callback(...args);\n        }\n        waiting = true;\n        setTimeout(() => {\n            waiting = false;\n            if (trailing) {\n                callback(...args);\n            }\n        }, wait);\n    };\n}\nexport function modifyTiming(callback, mods) {\n    const delayArgs = mods.get('delay');\n    if (delayArgs) {\n        const wait = tagToMs(delayArgs);\n        callback = delay(callback, wait);\n    }\n    const debounceArgs = mods.get('debounce');\n    if (debounceArgs) {\n        const wait = tagToMs(debounceArgs);\n        const leading = tagHas(debounceArgs, 'leading', false);\n        const trailing = !tagHas(debounceArgs, 'notrail', false);\n        callback = debounce(callback, wait, leading, trailing);\n    }\n    const throttleArgs = mods.get('throttle');\n    if (throttleArgs) {\n        const wait = tagToMs(throttleArgs);\n        const leading = !tagHas(throttleArgs, 'noleading', false);\n        const trailing = tagHas(throttleArgs, 'trail', false);\n        callback = throttle(callback, wait, leading, trailing);\n    }\n    return callback;\n}\n", "export const supportsViewTransitions = !!document.startViewTransition;\nexport function modifyViewTransition(callback, mods) {\n    if (mods.has('viewtransition') && supportsViewTransitions) {\n        const cb = callback; // I hate javascript\n        callback = (...args) => document.startViewTransition(() => cb(...args));\n    }\n    return callback;\n}\n", "// Icon: material-symbols:mail\n// Slug: Attaches an event listener to an element.\n// Description: Attaches an event listener to an element, executing an expression whenever the event is triggered.\nimport { DATASTAR_SIGNAL_PATCH_EVENT, } from '../../engine/types';\nimport { kebab, modifyCasing } from '../../utils/text';\nimport { modifyTiming } from '../../utils/timing';\nimport { modifyViewTransition } from '../../utils/view-transitions';\nimport { DATASTAR_FETCH_EVENT } from '../backend/shared';\nexport const On = {\n    type: 'attribute',\n    name: 'on',\n    keyReq: 'must',\n    valReq: 'must',\n    argNames: ['evt'],\n    onLoad: (ctx) => {\n        const { el, key, mods, rx, startBatch, endBatch } = ctx;\n        let target = el;\n        if (mods.has('window'))\n            target = window;\n        let callback = (evt) => {\n            if (evt) {\n                if (mods.has('prevent')) {\n                    evt.preventDefault();\n                }\n                if (mods.has('stop')) {\n                    evt.stopPropagation();\n                }\n                ctx.evt = evt;\n            }\n            startBatch();\n            rx(evt);\n            endBatch();\n        };\n        callback = modifyTiming(callback, mods);\n        callback = modifyViewTransition(callback, mods);\n        const evtListOpts = {\n            capture: mods.has('capture'),\n            passive: mods.has('passive'),\n            once: mods.has('once'),\n        };\n        if (mods.has('outside')) {\n            target = document;\n            const cb = callback;\n            callback = (evt) => {\n                if (!el.contains(evt?.target)) {\n                    cb(evt);\n                }\n            };\n        }\n        // Default to kebab-case and allow modifying\n        let eventName = kebab(key);\n        eventName = modifyCasing(eventName, mods);\n        // Listen for Datastar events on the document\n        if (eventName === DATASTAR_FETCH_EVENT ||\n            eventName === DATASTAR_SIGNAL_PATCH_EVENT) {\n            target = document;\n        }\n        // Prevent default on form submit events\n        if (el instanceof HTMLFormElement && eventName === 'submit') {\n            const cb = callback;\n            callback = (evt) => {\n                evt?.preventDefault();\n                cb(evt);\n            };\n        }\n        target.addEventListener(eventName, callback, evtListOpts);\n        return () => {\n            target.removeEventListener(eventName, callback);\n        };\n    },\n};\n", "// Icon: mdi-light:vector-intersection\n// Slug: Runs an expression on intersection.\n// Description: Runs an expression when the element intersects with the viewport.\nimport { modifyTiming } from '../../utils/timing';\nimport { modifyViewTransition } from '../../utils/view-transitions';\nconst once = new WeakSet();\nexport const OnIntersect = {\n    type: 'attribute',\n    name: 'onIntersect',\n    keyReq: 'denied',\n    onLoad: ({ el, mods, rx, startBatch, endBatch }) => {\n        let callback = () => {\n            startBatch();\n            rx();\n            endBatch();\n        };\n        callback = modifyTiming(callback, mods);\n        callback = modifyViewTransition(callback, mods);\n        const options = { threshold: 0 };\n        if (mods.has('full')) {\n            options.threshold = 1;\n        }\n        else if (mods.has('half')) {\n            options.threshold = 0.5;\n        }\n        let observer = new IntersectionObserver((entries) => {\n            for (const entry of entries) {\n                if (entry.isIntersecting) {\n                    callback();\n                    if (observer && once.has(el)) {\n                        observer.disconnect();\n                    }\n                }\n            }\n        }, options);\n        observer.observe(el);\n        if (mods.has('once')) {\n            once.add(el);\n        }\n        return () => {\n            if (!mods.has('once')) {\n                once.delete(el);\n            }\n            if (observer) {\n                observer.disconnect();\n                observer = null;\n            }\n        };\n    },\n};\n", "// Icon: material-symbols:timer-outline\n// Slug: Runs an expression at a regular interval.\n// Description: Runs an expression at a regular interval.\nimport { tagHas, tagToMs } from '../../utils/tags';\nimport { modifyViewTransition } from '../../utils/view-transitions';\nexport const OnInterval = {\n    type: 'attribute',\n    name: 'onInterval',\n    keyReq: 'denied',\n    valReq: 'must',\n    onLoad: ({ mods, rx, startBatch, endBatch }) => {\n        let callback = () => {\n            startBatch();\n            rx();\n            endBatch();\n        };\n        callback = modifyViewTransition(callback, mods);\n        let duration = 1000;\n        const durationArgs = mods.get('duration');\n        if (durationArgs) {\n            duration = tagToMs(durationArgs);\n            const leading = tagHas(durationArgs, 'leading', false);\n            if (leading) {\n                callback();\n            }\n        }\n        const intervalId = setInterval(callback, duration);\n        return () => {\n            clearInterval(intervalId);\n        };\n    },\n};\n", "// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when loaded into the DOM.\n// Description: Runs an expression when the element is loaded into the DOM.\nimport { tagToMs } from '../../utils/tags';\nimport { delay } from '../../utils/timing';\nimport { modifyViewTransition } from '../../utils/view-transitions';\nexport const OnLoad = {\n    type: 'attribute',\n    name: 'onLoad',\n    keyReq: 'denied',\n    valReq: 'must',\n    onLoad: ({ rx, mods, startBatch, endBatch }) => {\n        let callback = () => {\n            startBatch();\n            rx();\n            endBatch();\n        };\n        callback = modifyViewTransition(callback, mods);\n        let wait = 0;\n        const delayArgs = mods.get('delay');\n        if (delayArgs) {\n            wait = tagToMs(delayArgs);\n            if (wait > 0) {\n                callback = delay(callback, wait);\n            }\n        }\n        callback();\n    },\n};\n", "// Icon: material-symbols:change-circle-outline\n// Slug: Runs an expression when signals are patched.\n// Description: Runs an expression whenever one or more signals are patched.\nimport { DATASTAR_SIGNAL_PATCH_EVENT, } from '../../engine/types';\nimport { isEmpty } from '../../utils/paths';\nimport { jsStrToObject } from '../../utils/text';\nimport { modifyTiming } from '../../utils/timing';\nexport const OnSignalPatch = {\n    type: 'attribute',\n    name: 'onSignalPatch',\n    valReq: 'must',\n    argNames: ['patch'],\n    returnsValue: true,\n    onLoad: ({ el, key, mods, plugin, rx, filtered, runtimeErr, startBatch, endBatch, }) => {\n        // Throw an error if the key exists and is not `filter`\n        if (!!key && key !== 'filter') {\n            throw runtimeErr(`${plugin.name}KeyNotAllowed`);\n        }\n        // Look for data-on-signal-patch-filter data attribute\n        const filtersRaw = el.getAttribute('data-on-signal-patch-filter');\n        let filters = {};\n        if (filtersRaw) {\n            filters = jsStrToObject(filtersRaw);\n        }\n        const callback = modifyTiming((evt) => {\n            const watched = filtered(filters, evt.detail);\n            if (!isEmpty(watched)) {\n                startBatch();\n                rx(watched);\n                endBatch();\n            }\n        }, mods);\n        document.addEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback);\n        return () => {\n            document.removeEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback);\n        };\n    },\n};\n", "// Icon: mdi:cursor-pointer\n// Slug: Creates a reference to an element.\n// Description: Creates a new signal that is a reference to the element on which the data attribute is placed.\nimport { modifyCasing } from '../../utils/text';\n// Sets the value of the element\nexport const Ref = {\n    type: 'attribute',\n    name: 'ref',\n    keyReq: 'exclusive',\n    valReq: 'exclusive',\n    shouldEvaluate: false,\n    onLoad: ({ el, key, mods, value, mergePaths }) => {\n        const signalName = key ? modifyCasing(key, mods) : value;\n        mergePaths([[signalName, el]]);\n    },\n};\n", "// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Shows or hides an element.\n// Description: Shows or hides an element based on whether an expression evaluates to `true` or `false`.\nconst NONE = 'none';\nconst DISPLAY = 'display';\nexport const Show = {\n    type: 'attribute',\n    name: 'show',\n    keyReq: 'denied',\n    valReq: 'must',\n    returnsValue: true,\n    onLoad: ({ el, effect, rx }) => {\n        const update = () => {\n            observer.disconnect();\n            const shouldShow = rx();\n            if (shouldShow) {\n                if (el.style.display === NONE)\n                    el.style.removeProperty(DISPLAY);\n            }\n            else {\n                el.style.setProperty(DISPLAY, NONE);\n            }\n            observer.observe(el, { attributeFilter: ['style'] });\n        };\n        const observer = new MutationObserver(update);\n        const cleanup = effect(update);\n        return () => {\n            observer.disconnect();\n            cleanup();\n        };\n    },\n};\n", "// Icon: streamline:wifi-signal-full-remix\n// Slug: Patches signals into the existing signals.\n// Description: Patches (adds, updates or removes) one or more signals into the existing signals.\nimport { modifyCasing } from '../../utils/text';\nexport const Signals = {\n    type: 'attribute',\n    name: 'signals',\n    returnsValue: true,\n    onLoad: ({ key, mods, rx, mergePatch, mergePaths }) => {\n        const ifMissing = mods.has('ifmissing');\n        if (key) {\n            key = modifyCasing(key, mods);\n            mergePaths([[key, rx()]], { ifMissing });\n        }\n        else {\n            const patch = Object.assign({}, rx());\n            mergePatch(patch, { ifMissing });\n        }\n    },\n};\n", "// Icon: material-symbols:format-paint-outline\n// Slug: Sets inline styles on an element based on an expression.\n// Description: Sets CSS styles on an element using either key-based or object syntax, and keeps them in sync with reactive signals.\nimport { kebab } from '../../utils/text';\nexport const Style = {\n    type: 'attribute',\n    name: 'style',\n    valReq: 'must',\n    returnsValue: true,\n    onLoad: ({ key, el, effect, rx }) => {\n        const { style } = el;\n        const initialStyles = new Map();\n        key &&= kebab(key);\n        const apply = (prop, value) => {\n            const initial = initialStyles.get(prop);\n            if (!value && value !== 0) {\n                initial !== undefined &&\n                    (initial\n                        ? style.setProperty(prop, initial)\n                        : style.removeProperty(prop));\n            }\n            else {\n                initial === undefined &&\n                    initialStyles.set(prop, style.getPropertyValue(prop));\n                style.setProperty(prop, String(value));\n            }\n        };\n        const update = () => {\n            observer.disconnect();\n            if (key) {\n                apply(key, rx());\n            }\n            else {\n                const styles = rx();\n                for (const [prop, initial] of initialStyles) {\n                    prop in styles ||\n                        (initial\n                            ? style.setProperty(prop, initial)\n                            : style.removeProperty(prop));\n                }\n                for (const prop in styles) {\n                    apply(kebab(prop), styles[prop]);\n                }\n            }\n            observer.observe(el, { attributeFilter: ['style'] });\n        };\n        const observer = new MutationObserver(update);\n        const cleanup = effect(update);\n        return () => {\n            observer.disconnect();\n            cleanup();\n            for (const [prop, initial] of initialStyles) {\n                initial ? style.setProperty(prop, initial) : style.removeProperty(prop);\n            }\n        };\n    },\n};\n", "// Icon: icon-park-outline:text\n// Slug: Binds the text content of an element.\n// Description: Binds the text content of an element to an expression.\nexport const Text = {\n    type: 'attribute',\n    name: 'text',\n    keyReq: 'denied',\n    valReq: 'must',\n    returnsValue: true,\n    onLoad: ({ el, effect, rx }) => {\n        const update = () => {\n            observer.disconnect();\n            el.textContent = `${rx()}`;\n            observer.observe(el, {\n                childList: true,\n                characterData: true,\n                subtree: true,\n            });\n        };\n        const observer = new MutationObserver(update);\n        const cleanup = effect(update);\n        return () => {\n            observer.disconnect();\n            cleanup();\n        };\n    },\n};\n", "import { DATASTAR, DATASTAR_REQUEST, DefaultSseRetryDurationMs, EventTypePatchElements, EventTypePatchSignals, } from '../../../engine/consts';\nimport { kebab } from '../../../utils/text';\nimport { DATASTAR_FETCH_EVENT, ERROR, FINISHED, RETRIES_FAILED, RETRYING, STARTED, } from '../shared';\n// Global store for active SSE controllers per element\nconst fetchAbortControllers = new WeakMap();\n// Helper to create HTTP method plugins with consistent structure\nexport const createHttpMethod = (name, method) => ({\n    type: 'action',\n    name,\n    fn: async (ctx, url, args) => {\n        const { el } = ctx;\n        const requestCancellation = args?.requestCancellation ?? 'auto';\n        const controller = requestCancellation instanceof AbortController\n            ? requestCancellation\n            : new AbortController();\n        const isDisabled = requestCancellation === 'disabled';\n        if (!isDisabled) {\n            fetchAbortControllers.get(el)?.abort();\n        }\n        if (!isDisabled && !(requestCancellation instanceof AbortController)) {\n            fetchAbortControllers.set(el, controller);\n        }\n        try {\n            await fetcher(ctx, method, url, args, controller.signal);\n        }\n        finally {\n            if (fetchAbortControllers.get(el) === controller) {\n                fetchAbortControllers.delete(el);\n            }\n        }\n    },\n});\nconst dispatchFetch = (type, el, argsRaw) => document.dispatchEvent(new CustomEvent(DATASTAR_FETCH_EVENT, {\n    detail: { type, el, argsRaw },\n}));\nconst isWrongContent = (err) => `${err}`.includes('text/event-stream');\nconst fetcher = async ({ el, evt, filtered, runtimeErr }, method, url, { selector, headers: userHeaders, contentType = 'json', filterSignals: { include = /.*/, exclude = /(^|\\.)_/ } = {}, openWhenHidden = false, retryInterval = DefaultSseRetryDurationMs, retryScaler = 2, retryMaxWaitMs = 30_000, retryMaxCount = 10, } = {}, abort) => {\n    const action = method.toLowerCase();\n    let cleanupFn = () => { };\n    try {\n        if (!url?.length) {\n            throw runtimeErr('FetchNoUrlProvided', { action });\n        }\n        const initialHeaders = {\n            Accept: 'text/event-stream, text/html, application/json',\n            [DATASTAR_REQUEST]: true,\n        };\n        if (contentType === 'json') {\n            initialHeaders['Content-Type'] = 'application/json';\n        }\n        const headers = Object.assign({}, initialHeaders, userHeaders);\n        // We ignore the content-type header if using form data\n        // if missing the boundary will be set automatically\n        const req = {\n            method,\n            headers,\n            openWhenHidden,\n            retryInterval,\n            retryScaler,\n            retryMaxWaitMs,\n            retryMaxCount,\n            signal: abort,\n            onopen: async (response) => {\n                if (response.status >= 400)\n                    dispatchFetch(ERROR, el, { status: response.status.toString() });\n            },\n            onmessage: (evt) => {\n                if (!evt.event.startsWith(DATASTAR))\n                    return;\n                const type = evt.event;\n                const argsRawLines = {};\n                for (const line of evt.data.split('\\n')) {\n                    const i = line.indexOf(' ');\n                    const k = line.slice(0, i);\n                    const v = line.slice(i + 1);\n                    (argsRawLines[k] ||= []).push(v);\n                }\n                const argsRaw = Object.fromEntries(Object.entries(argsRawLines).map(([k, v]) => [k, v.join('\\n')]));\n                dispatchFetch(type, el, argsRaw);\n            },\n            onerror: (error) => {\n                if (isWrongContent(error)) {\n                    // don't retry if the content-type is wrong\n                    throw runtimeErr('InvalidContentType', { url });\n                }\n                // do nothing and it will retry\n                if (error) {\n                    console.error(error.message);\n                    dispatchFetch(RETRYING, el, { message: error.message });\n                }\n            },\n        };\n        const urlInstance = new URL(url, window.location.href);\n        const queryParams = new URLSearchParams(urlInstance.search);\n        if (contentType === 'json') {\n            const res = JSON.stringify(filtered({ include, exclude }));\n            if (method === 'GET') {\n                queryParams.set(DATASTAR, res);\n            }\n            else {\n                req.body = res;\n            }\n        }\n        else if (contentType === 'form') {\n            const formEl = (selector ? document.querySelector(selector) : el.closest('form'));\n            if (!formEl) {\n                throw runtimeErr(selector ? 'FetchFormNotFound' : 'FetchClosestFormNotFound', { action, selector });\n            }\n            // Validate the form\n            if (!formEl.checkValidity()) {\n                formEl.reportValidity();\n                cleanupFn();\n                return;\n            }\n            // Collect the form data\n            const formData = new FormData(formEl);\n            let submitter = el;\n            if (el === formEl && evt instanceof SubmitEvent) {\n                // Get the submitter from the event\n                submitter = evt.submitter;\n            }\n            else {\n                // Prevent the form being submitted\n                const preventDefault = (evt) => evt.preventDefault();\n                formEl.addEventListener('submit', preventDefault);\n                cleanupFn = () => formEl.removeEventListener('submit', preventDefault);\n            }\n            // Append the value of the form submitter if it is a button with a name\n            if (submitter instanceof HTMLButtonElement) {\n                const name = submitter.getAttribute('name');\n                if (name)\n                    formData.append(name, submitter.value);\n            }\n            const multipart = formEl.getAttribute('enctype') === 'multipart/form-data';\n            // Leave the `Content-Type` header empty for multipart encoding so the browser can set it automatically with the correct boundary\n            if (!multipart) {\n                headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            }\n            const formParams = new URLSearchParams(formData);\n            if (method === 'GET') {\n                for (const [key, value] of formParams) {\n                    queryParams.append(key, value);\n                }\n            }\n            else if (multipart) {\n                // Upload progress events are only available for: HTTPS connections (required for streaming uploads) with Multipart form data uploads\n                if (__USE_UPLOAD_PROGRESS__ && urlInstance.protocol === 'https:') {\n                    const boundary = `----FormDataBoundary${Math.random().toString(36).substring(2, 11)}`;\n                    const encoder = new TextEncoder();\n                    // Calculate total size\n                    let total = 0;\n                    const parts = [];\n                    for (const [name, value] of formData) {\n                        parts.push({ field: name, value });\n                        total += encoder.encode(`--${boundary}\\r\\n`).byteLength;\n                        if (value instanceof File) {\n                            total += encoder.encode(`Content-Disposition: form-data; name=\"${name}\"; filename=\"${value.name}\"\\r\\n` +\n                                `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`).byteLength;\n                            total += value.size + 2;\n                        }\n                        else {\n                            total += encoder.encode(`Content-Disposition: form-data; name=\"${name}\"\\r\\n\\r\\n${value}\\r\\n`).byteLength;\n                        }\n                    }\n                    total += encoder.encode(`--${boundary}--\\r\\n`).byteLength;\n                    let loaded = 0;\n                    req.body = new ReadableStream({\n                        async start(controller) {\n                            const write = (data) => {\n                                controller.enqueue(data);\n                                loaded += data.byteLength;\n                                const progress = Math.round((loaded / total) * 100);\n                                dispatchFetch('upload-progress', el, {\n                                    progress: progress.toString(),\n                                    loaded: loaded.toString(),\n                                    total: total.toString(),\n                                });\n                            };\n                            dispatchFetch('upload-progress', el, {\n                                progress: '0',\n                                loaded: '0',\n                                total: total.toString(),\n                            });\n                            try {\n                                for (const { field, value } of parts) {\n                                    write(encoder.encode(`--${boundary}\\r\\n`));\n                                    if (value instanceof File) {\n                                        write(encoder.encode(`Content-Disposition: form-data; name=\"${field}\"; filename=\"${value.name}\"\\r\\n` +\n                                            `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`));\n                                        const reader = value.stream().getReader();\n                                        try {\n                                            while (true) {\n                                                const { done, value: chunk } = await reader.read();\n                                                if (done)\n                                                    break;\n                                                write(chunk);\n                                            }\n                                        }\n                                        finally {\n                                            reader.releaseLock();\n                                        }\n                                        write(encoder.encode('\\r\\n'));\n                                    }\n                                    else {\n                                        write(encoder.encode(`Content-Disposition: form-data; name=\"${field}\"\\r\\n\\r\\n${value}\\r\\n`));\n                                    }\n                                }\n                                write(encoder.encode(`--${boundary}--\\r\\n`));\n                                if (loaded < total) {\n                                    dispatchFetch('upload-progress', el, {\n                                        progress: '100',\n                                        loaded: total.toString(),\n                                        total: total.toString(),\n                                    });\n                                }\n                                controller.close();\n                            }\n                            catch (error) {\n                                controller.error(error);\n                            }\n                        },\n                    });\n                    // Override content-type header with the boundary\n                    headers['Content-Type'] = `multipart/form-data; boundary=${boundary}`;\n                    req.duplex = 'half';\n                }\n                else {\n                    req.body = formData;\n                }\n            }\n            else {\n                req.body = formParams;\n            }\n        }\n        else {\n            throw runtimeErr('FetchInvalidContentType', { action, contentType });\n        }\n        dispatchFetch(STARTED, el, {});\n        urlInstance.search = queryParams.toString();\n        try {\n            await fetchEventSource(urlInstance.toString(), el, req);\n        }\n        catch (error) {\n            if (!isWrongContent(error)) {\n                throw runtimeErr('FetchFailed', { method, url, error });\n            }\n            // exit gracefully and do nothing if the content-type is wrong\n            // this can happen if the client is sending a request\n            // where no response is expected, and they haven\u2019t\n            // set the content-type to text/event-stream\n        }\n    }\n    finally {\n        dispatchFetch(FINISHED, el, {});\n        cleanupFn();\n    }\n};\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(stream, onChunk) {\n    const reader = stream.getReader();\n    let result = await reader.read();\n    while (!result.done) {\n        onChunk(result.value);\n        result = await reader.read();\n    }\n}\nfunction getLines(onLine) {\n    let buffer;\n    let position; // current read position\n    let fieldLength; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr) {\n        if (!buffer) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        }\n        else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === 10)\n                    lineStart = ++position; // skip to next char\n                discardTrailingNewline = false;\n            }\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case 58: // :\n                        if (fieldLength === -1) {\n                            // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    // biome-ignore lint/suspicious/noFallthroughSwitchClause: intentional fallthrough for CR to LF\n                    case 13: // \\r\n                        discardTrailingNewline = true;\n                    case 10: // \\n\n                        lineEnd = position;\n                        break;\n                }\n            }\n            if (lineEnd === -1)\n                break; // Wait for the next arr and then continue parsing\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n        if (lineStart === bufLength)\n            buffer = undefined; // we've finished reading it\n        else if (lineStart) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n    // return a function that can process each incoming line buffer:\n    return function onLine(line, fieldLength) {\n        if (!line.length) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        }\n        else if (fieldLength > 0) {\n            // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n            switch (field) {\n                case 'data':\n                    message.data = message.data ? `${message.data}\\n${value}` : value;\n                    break;\n                case 'event':\n                    message.event = value;\n                    break;\n                case 'id':\n                    onId((message.id = value));\n                    break;\n                case 'retry': {\n                    const retry = +value;\n                    if (!Number.isNaN(retry)) {\n                        // per spec, ignore non-integers\n                        onRetry((message.retry = retry));\n                    }\n                    break;\n                }\n            }\n        }\n    };\n}\nconst concat = (a, b) => {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n};\nconst newMessage = () => ({\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    data: '',\n    event: '',\n    id: '',\n    retry: undefined,\n});\nfunction fetchEventSource(input, el, { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch, retryInterval = 1_000, retryScaler = 2, retryMaxWaitMs = 30_000, retryMaxCount = 10, overrides, ...rest }) {\n    return new Promise((resolve, reject) => {\n        // make a copy of the input headers since we may modify it below:\n        const headers = {\n            ...inputHeaders,\n        };\n        let curRequestController;\n        function onVisibilityChange() {\n            curRequestController.abort(); // close existing request on every visibility change\n            if (!document.hidden)\n                create(); // page is now visible again, recreate request.\n        }\n        if (!openWhenHidden) {\n            document.addEventListener('visibilitychange', onVisibilityChange);\n        }\n        let retryTimer = 0;\n        function dispose() {\n            document.removeEventListener('visibilitychange', onVisibilityChange);\n            window.clearTimeout(retryTimer);\n            curRequestController.abort();\n        }\n        // if the incoming signal aborts, dispose resources and resolve:\n        inputSignal?.addEventListener('abort', () => {\n            dispose();\n            resolve(); // don't waste time constructing/logging errors\n        });\n        const fetch = inputFetch || window.fetch;\n        const onopen = inputOnOpen || (() => { });\n        let retries = 0;\n        let baseRetryInterval = retryInterval;\n        async function create() {\n            curRequestController = new AbortController();\n            try {\n                const response = await fetch(input, {\n                    ...rest,\n                    headers,\n                    signal: curRequestController.signal,\n                });\n                // on successful connection, reset the retry logic\n                retries = 0;\n                retryInterval = baseRetryInterval;\n                await onopen(response);\n                const dispatchNonSSE = async (dispatchType, response, name, overrides, ...argNames) => {\n                    const argsRaw = {\n                        [name]: await response.text(),\n                    };\n                    for (const n of argNames) {\n                        let v = response.headers.get(`datastar-${kebab(n)}`);\n                        if (overrides) {\n                            const o = overrides[n];\n                            if (o)\n                                v = typeof o === 'string' ? o : JSON.stringify(o);\n                        }\n                        if (v)\n                            argsRaw[n] = v;\n                    }\n                    dispatchFetch(dispatchType, el, argsRaw);\n                    dispose();\n                    resolve();\n                };\n                const ct = response.headers.get('Content-Type');\n                if (ct?.includes('text/html')) {\n                    return await dispatchNonSSE(EventTypePatchElements, response, 'elements', overrides, 'selector', 'mode', 'useViewTransition');\n                }\n                if (ct?.includes('application/json')) {\n                    return await dispatchNonSSE(EventTypePatchSignals, response, 'signals', overrides, 'onlyIfMissing');\n                }\n                if (ct?.includes('text/javascript')) {\n                    const script = document.createElement('script');\n                    const scriptAttributesHeader = response.headers.get('datastar-script-attributes');\n                    if (scriptAttributesHeader) {\n                        for (const [name, value] of Object.entries(JSON.parse(scriptAttributesHeader))) {\n                            script.setAttribute(name, value);\n                        }\n                    }\n                    script.textContent = await response.text();\n                    document.head.appendChild(script);\n                    dispose();\n                    return;\n                }\n                await getBytes(response.body, getLines(getMessages((id) => {\n                    if (id) {\n                        // signals the id and send it back on the next retry:\n                        headers['last-event-id'] = id;\n                    }\n                    else {\n                        // don't send the last-event-id header anymore:\n                        delete headers['last-event-id'];\n                    }\n                }, (retry) => {\n                    baseRetryInterval = retryInterval = retry;\n                }, onmessage)));\n                onclose?.();\n                dispose();\n                resolve();\n            }\n            catch (err) {\n                if (!curRequestController.signal.aborted) {\n                    // if we haven\u2019t aborted the request ourselves:\n                    try {\n                        // check if we need to retry:\n                        const interval = onerror?.(err) || retryInterval;\n                        window.clearTimeout(retryTimer);\n                        retryTimer = window.setTimeout(create, interval);\n                        retryInterval = Math.min(retryInterval * retryScaler, retryMaxWaitMs); // exponential backoff\n                        if (++retries >= retryMaxCount) {\n                            dispatchFetch(RETRIES_FAILED, el, {});\n                            // we should not retry anymore:\n                            dispose();\n                            reject('Max retries reached.'); // Max retries reached, check your server or network connection\n                        }\n                        else {\n                            console.error(`Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`);\n                        }\n                    }\n                    catch (innerErr) {\n                        // we should not retry anymore:\n                        dispose();\n                        reject(innerErr);\n                    }\n                }\n            }\n        }\n        create();\n    });\n}\n", "// Icon: material-symbols:delete-outline\n// Slug: Sends a `DELETE` request.\n// Description: Sends a `DELETE` request to the backend using `fetch`.\nimport { createHttpMethod } from './fetch';\nexport const DELETE = createHttpMethod('delete', 'DELETE');\n", "// Icon: ic:baseline-get-app\n// Slug: Sends a `GET` request.\n// Description: Sends a `GET` request to the backend using `fetch`.\nimport { createHttpMethod } from './fetch';\nexport const GET = createHttpMethod('get', 'GET');\n", "// Icon: fluent:patch-24-filled\n// Slug: Sends a `PATCH` request.\n// Description: Sends a `PATCH` request to the backend using `fetch`.\nimport { createHttpMethod } from './fetch';\nexport const PATCH = createHttpMethod('patch', 'PATCH');\n", "// Icon: ri:signpost-fill\n// Slug: Sends a `POST` request.\n// Description: Sends a `POST` request to the backend using `fetch`.\nimport { createHttpMethod } from './fetch';\nexport const POST = createHttpMethod('post', 'POST');\n", "// Icon: material-symbols:arrows-input\n// Slug: Sends a `PUT` request.\n// Description: Sends a `PUT` request to the backend using `fetch`.\nimport { createHttpMethod } from './fetch';\nexport const PUT = createHttpMethod('put', 'PUT');\n", "// Icon: material-symbols:cloud-download\n// Slug: Patches elements into the DOM.\n// Description: Patches elements into the DOM.\nimport { DefaultElementPatchMode, ElementPatchModeAfter, ElementPatchModeAppend, ElementPatchModeBefore, ElementPatchModeInner, ElementPatchModeOuter, ElementPatchModePrepend, ElementPatchModeRemove, ElementPatchModeReplace, EventTypePatchElements, } from '../../../engine/consts';\nimport { aliasify } from '../../../engine/engine';\nimport { kebab } from '../../../utils/text';\nimport { supportsViewTransitions } from '../../../utils/view-transitions';\nimport { datastarSSEEventWatcher } from '../shared';\nexport const PatchElements = {\n    type: 'watcher',\n    name: EventTypePatchElements,\n    async onGlobalInit(ctx) {\n        datastarSSEEventWatcher(EventTypePatchElements, (args) => {\n            if (supportsViewTransitions &&\n                args.useViewTransition?.trim() === 'true') {\n                document.startViewTransition(() => onPatchElements(ctx, args));\n            }\n            else {\n                onPatchElements(ctx, args);\n            }\n        });\n    },\n};\nfunction onPatchElements(ctx, { elements = '', selector, mode = DefaultElementPatchMode, }) {\n    const { initErr } = ctx;\n    const elementsWithSvgsRemoved = elements.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n    const hasHtml = /<\\/html>/.test(elementsWithSvgsRemoved);\n    const hasHead = /<\\/head>/.test(elementsWithSvgsRemoved);\n    const hasBody = /<\\/body>/.test(elementsWithSvgsRemoved);\n    const newDocument = new DOMParser().parseFromString(hasHtml || hasHead || hasBody\n        ? elements\n        : `<body><template>${elements}</template></body>`, 'text/html');\n    let newContent = document.createDocumentFragment();\n    if (hasHtml) {\n        newContent.appendChild(newDocument.documentElement);\n    }\n    else if (hasHead && hasBody) {\n        newContent.appendChild(newDocument.head);\n        newContent.appendChild(newDocument.body);\n    }\n    else if (hasHead) {\n        newContent.appendChild(newDocument.head);\n    }\n    else if (hasBody) {\n        newContent.appendChild(newDocument.body);\n    }\n    else {\n        newContent = newDocument.querySelector('template').content;\n    }\n    if (!selector &&\n        (mode === ElementPatchModeOuter || mode === ElementPatchModeReplace)) {\n        for (const child of newContent.children) {\n            let target;\n            if (child instanceof HTMLHtmlElement) {\n                target = document.documentElement;\n            }\n            else if (child instanceof HTMLBodyElement) {\n                target = document.body;\n            }\n            else if (child instanceof HTMLHeadElement) {\n                target = document.head;\n            }\n            else {\n                target = document.getElementById(child.id);\n                if (!target) {\n                    console.error(initErr('NoTargetsFound', {\n                        id: child.id,\n                    }));\n                    continue;\n                }\n            }\n            applyToTargets(ctx, mode, child, [target]);\n        }\n    }\n    else {\n        const targets = document.querySelectorAll(selector);\n        if (!targets.length) {\n            console.error(initErr('NoTargetsFound', {\n                selector: selector,\n            }));\n            return;\n        }\n        applyToTargets(ctx, mode, newContent, targets);\n    }\n}\nconst scripts = new WeakSet();\nfor (const script of document.querySelectorAll('script')) {\n    scripts.add(script);\n}\nfunction execute(target) {\n    const elScripts = target instanceof HTMLScriptElement\n        ? [target]\n        : target.querySelectorAll('script');\n    for (const old of elScripts) {\n        if (!scripts.has(old)) {\n            const script = document.createElement('script');\n            for (const { name, value } of old.attributes) {\n                script.setAttribute(name, value);\n            }\n            script.text = old.text;\n            old.replaceWith(script);\n            scripts.add(script);\n        }\n    }\n}\nfunction applyToTargets({ initErr }, mode, element, capturedTargets) {\n    for (const target of capturedTargets) {\n        const cloned = element.cloneNode(true);\n        if (mode === ElementPatchModeRemove) {\n            target.remove();\n        }\n        else if (mode === ElementPatchModeOuter ||\n            mode === ElementPatchModeInner) {\n            morph(target, cloned, mode);\n            execute(target);\n        }\n        else {\n            execute(cloned);\n            if (mode === ElementPatchModeReplace) {\n                target.replaceWith(cloned);\n            }\n            else if (mode === ElementPatchModePrepend) {\n                target.prepend(cloned);\n            }\n            else if (mode === ElementPatchModeAppend) {\n                target.append(cloned);\n            }\n            else if (mode === ElementPatchModeBefore) {\n                target.before(cloned);\n            }\n            else if (mode === ElementPatchModeAfter) {\n                target.after(cloned);\n            }\n            else {\n                throw initErr('InvalidPatchMode', { mode });\n            }\n        }\n    }\n}\nconst oldIdTagNameMap = new Map();\nconst ctxIdMap = new Map();\nconst ctxPersistentIds = new Set();\nconst duplicateIds = new Set();\nconst ctxPantry = document.createElement('div');\nctxPantry.hidden = true;\nfunction morph(oldElt, newContent, mode) {\n    const ignore = aliasify('ignore-morph');\n    if ((oldElt.hasAttribute(ignore) &&\n        newContent instanceof HTMLElement &&\n        newContent.hasAttribute(ignore)) ||\n        oldElt.parentElement?.closest(`[${ignore}]`)) {\n        return;\n    }\n    const normalizedElt = document.createElement('div');\n    normalizedElt.append(newContent);\n    document.body.insertAdjacentElement('afterend', ctxPantry);\n    // Computes the set of IDs that persist between the two contents excluding duplicates\n    const oldIdElements = oldElt.querySelectorAll('[id]');\n    for (const { id, tagName } of oldIdElements) {\n        if (oldIdTagNameMap.has(id)) {\n            duplicateIds.add(id);\n        }\n        else {\n            oldIdTagNameMap.set(id, tagName);\n        }\n    }\n    if (oldElt.id) {\n        if (oldIdTagNameMap.has(oldElt.id)) {\n            duplicateIds.add(oldElt.id);\n        }\n        else {\n            oldIdTagNameMap.set(oldElt.id, oldElt.tagName);\n        }\n    }\n    ctxPersistentIds.clear();\n    const newIdElements = normalizedElt.querySelectorAll('[id]');\n    for (const { id, tagName } of newIdElements) {\n        if (ctxPersistentIds.has(id)) {\n            duplicateIds.add(id);\n        }\n        else if (oldIdTagNameMap.get(id) === tagName) {\n            ctxPersistentIds.add(id);\n        }\n    }\n    oldIdTagNameMap.clear();\n    for (const id of duplicateIds) {\n        ctxPersistentIds.delete(id);\n    }\n    duplicateIds.clear();\n    // Computes a map of nodes to all IDs contained within that node (inclusive of the node).\n    // This map can be used to ask if two nodes have intersecting sets of IDs,\n    // which allows for a looser definition of \"matching\" than traditional ID matching,\n    // and allows child nodes to contribute to a parent nodes matching.\n    // const idMap = new Map<Node, Set<string>>()\n    ctxIdMap.clear();\n    populateIdMapWithTree(mode === 'outer' ? oldElt.parentElement : oldElt, oldIdElements);\n    populateIdMapWithTree(normalizedElt, newIdElements);\n    morphChildren(mode === 'outer' ? oldElt.parentElement : oldElt, normalizedElt, mode === 'outer' ? oldElt : null, oldElt.nextSibling);\n    ctxPantry.remove();\n}\n// This is the core algorithm for matching up children.\n// The idea is to use ID sets to try to match up nodes as faithfully as possible.\n// We greedily match, which allows us to keep the algorithm fast,\n// but by using ID sets, we are able to better match up with content deeper in the DOM.\nfunction morphChildren(oldParent, // the old content that we are merging the new content into\nnewParent, // the parent element of the new content\ninsertionPoint = null, // // the point in the DOM we start morphing at (defaults to first child)\nendPoint = null) {\n    // normalize\n    if (oldParent instanceof HTMLTemplateElement &&\n        newParent instanceof HTMLTemplateElement) {\n        // we can pretend the DocumentElement is an Element\n        oldParent = oldParent.content;\n        newParent = newParent.content;\n    }\n    insertionPoint ??= oldParent.firstChild;\n    // run through all the new content\n    for (const newChild of newParent.childNodes) {\n        // once we reach the end of the old parent content skip to the end and insert the rest\n        if (insertionPoint && insertionPoint !== endPoint) {\n            const bestMatch = findBestMatch(newChild, insertionPoint, endPoint);\n            if (bestMatch) {\n                // if the node to morph is not at the insertion point then remove/move up to it\n                if (bestMatch !== insertionPoint) {\n                    let cursor = insertionPoint;\n                    // Remove nodes between the start and end nodes\n                    while (cursor && cursor !== bestMatch) {\n                        const tempNode = cursor;\n                        cursor = cursor.nextSibling;\n                        removeNode(tempNode);\n                    }\n                }\n                morphNode(bestMatch, newChild);\n                insertionPoint = bestMatch.nextSibling;\n                continue;\n            }\n        }\n        // @ts-ignore\n        const ncId = newChild.id;\n        // if the matching node is elsewhere in the original content\n        if (newChild instanceof Element && ctxPersistentIds.has(ncId)) {\n            // move it and all its children here and morph, will always be found\n            // Search for an element by ID within the document and pantry, and move it using moveBefore.\n            const movedChild = window[ncId];\n            // Removes an element from its ancestors' ID maps.\n            // This is needed when an element is moved from the \"future\" via `moveBeforeId`.\n            // Otherwise, its erstwhile ancestors could be mistakenly moved to the pantry rather than being deleted,\n            // preventing their removal hooks from being called.\n            let current = movedChild;\n            while ((current = current.parentNode)) {\n                const idSet = ctxIdMap.get(current);\n                if (idSet) {\n                    idSet.delete(ncId);\n                    if (!idSet.size) {\n                        ctxIdMap.delete(current);\n                    }\n                }\n            }\n            moveBefore(oldParent, movedChild, insertionPoint);\n            morphNode(movedChild, newChild);\n            insertionPoint = movedChild.nextSibling;\n            continue;\n        }\n        // This performs the action of inserting a new node while handling situations where the node contains\n        // elements with persistent IDs and possible state info we can still preserve by moving in and then morphing\n        if (ctxIdMap.has(newChild)) {\n            // node has children with IDs with possible state so create a dummy elt of same type and apply full morph algorithm\n            const newEmptyChild = document.createElement(newChild.tagName);\n            oldParent.insertBefore(newEmptyChild, insertionPoint);\n            morphNode(newEmptyChild, newChild);\n            insertionPoint = newEmptyChild.nextSibling;\n        }\n        else {\n            // optimization: no id state to preserve so we can just insert a clone of the newChild and its descendants\n            const newClonedChild = document.importNode(newChild, true); // importNode to not mutate newParent\n            oldParent.insertBefore(newClonedChild, insertionPoint);\n            insertionPoint = newClonedChild.nextSibling;\n        }\n    }\n    // remove any remaining old nodes that didn't match up with new content\n    while (insertionPoint && insertionPoint !== endPoint) {\n        const tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling;\n        removeNode(tempNode);\n    }\n}\n// Scans forward from the startPoint to the endPoint looking for a match for the node.\n// It looks for an id set match first, then a soft match.\n// We abort soft matching if we find two future soft matches, to reduce churn.\nfunction findBestMatch(node, startPoint, endPoint) {\n    let bestMatch = null;\n    let nextSibling = node.nextSibling;\n    let siblingSoftMatchCount = 0;\n    let displaceMatchCount = 0;\n    // Max ID matches we are willing to displace in our search\n    const nodeMatchCount = ctxIdMap.get(node)?.size || 0;\n    let cursor = startPoint;\n    while (cursor && cursor !== endPoint) {\n        // soft matching is a prerequisite for id set matching\n        if (isSoftMatch(cursor, node)) {\n            let isIdSetMatch = false;\n            const oldSet = ctxIdMap.get(cursor);\n            const newSet = ctxIdMap.get(node);\n            if (newSet && oldSet) {\n                for (const id of oldSet) {\n                    // a potential match is an id in the new and old nodes that\n                    // has not already been merged into the DOM\n                    // But the newNode content we call this on has not been\n                    // merged yet and we don't allow duplicate IDs so it is simple\n                    if (newSet.has(id)) {\n                        isIdSetMatch = true;\n                        break;\n                    }\n                }\n            }\n            if (isIdSetMatch) {\n                return cursor; // found an id set match, we're done!\n            }\n            // we haven\u2019t yet saved a soft match fallback\n            // the current soft match will hard match something else in the future, leave it\n            if (!bestMatch && !ctxIdMap.has(cursor)) {\n                // optimization: if node can't id set match, we can just return the soft match immediately\n                if (!nodeMatchCount) {\n                    return cursor;\n                }\n                // save this as the fallback if we get through the loop without finding a hard match\n                bestMatch = cursor;\n            }\n        }\n        // check for IDs we may be displaced when matching\n        displaceMatchCount += ctxIdMap.get(cursor)?.size || 0;\n        if (displaceMatchCount > nodeMatchCount) {\n            // if we are going to displace more IDs than the node contains then\n            // we do not have a good candidate for an ID match, so return\n            break;\n        }\n        if (bestMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {\n            // The next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling;\n            // If there are two future soft matches, block soft matching for this node to allow\n            // future siblings to soft match. This is to reduce churn in the DOM when an element\n            // is prepended.\n            if (siblingSoftMatchCount >= 2) {\n                bestMatch = undefined;\n            }\n        }\n        // if the current node contains active element, stop looking for better future matches,\n        // because if one is found, this node will be moved to the pantry, re-parenting it and thus losing focus\n        if (cursor.contains(document.activeElement))\n            break;\n        cursor = cursor.nextSibling;\n    }\n    return bestMatch || null;\n}\nfunction isSoftMatch(oldNode, newNode) {\n    // ok to cast: if one is not element, `id` and `tagName` will be null and we'll just compare that.\n    const oldId = oldNode.id;\n    return (oldNode.nodeType === newNode.nodeType &&\n        oldNode.tagName === newNode.tagName &&\n        // If oldElt has an `id` with possible state and it doesn\u2019t match newElt.id then avoid morphing.\n        // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n        // its not persistent, and new nodes can't have any hidden state.\n        (!oldId || oldId === newNode.id));\n}\n// Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n// - Persistent nodes will be moved to the pantry for later reuse\n// - Other nodes will have their hooks called, and then are removed\nfunction removeNode(node) {\n    // are we going to id set match this later?\n    if (ctxIdMap.has(node)) {\n        // skip callbacks and move to pantry\n        moveBefore(ctxPantry, node, null);\n    }\n    else {\n        // remove for realsies\n        node.parentNode?.removeChild(node);\n    }\n}\n// Moves an element before another element within the same parent.\n// Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n// This is essentially a forward-compat wrapper.\nconst moveBefore = \n// @ts-ignore\nremoveNode.call.bind(ctxPantry.moveBefore ?? ctxPantry.insertBefore);\nfunction morphNode(oldNode, // root node to merge content into\nnewNode) {\n    // syncs the oldNode to the newNode, copying over all attributes and\n    // inner element state from the newNode to the oldNode\n    const type = newNode.nodeType;\n    // if is an element type, sync the attributes from the\n    // new node into the new node\n    if (type === 1 /* element type */) {\n        const ignore = aliasify('ignore-morph');\n        if (oldNode.hasAttribute(ignore) &&\n            newNode.hasAttribute(ignore)) {\n            return oldNode;\n        }\n        //  many bothans died to bring us this information:\n        //  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n        //  https://github.com/choojs/nanomorph/blob/master/lib/morph.js#L113\n        if (oldNode instanceof HTMLInputElement &&\n            newNode instanceof HTMLInputElement &&\n            newNode.type !== 'file') {\n            // https://github.com/bigskysoftware/idiomorph/issues/27\n            // | old input value | new input value  | behaviour                              |\n            // | --------------- | ---------------- | -------------------------------------- |\n            // | `null`          | `null`           | preserve old input value               |\n            // | some value      | the same value   | preserve old input value               |\n            // | some value      | `null`           | set old input value to `\"\"`            |\n            // | `null`          | some value       | set old input value to new input value |\n            // | some value      | some other value | set old input value to new input value |\n            if (newNode.getAttribute('value') !== oldNode.getAttribute('value')) {\n                oldNode.value = newNode.getAttribute('value') ?? '';\n            }\n        }\n        else if (oldNode instanceof HTMLTextAreaElement &&\n            newNode instanceof HTMLTextAreaElement) {\n            const newValue = newNode.value;\n            if (newValue !== oldNode.value) {\n                oldNode.value = newValue;\n            }\n            if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {\n                oldNode.firstChild.nodeValue = newValue;\n            }\n        }\n        const preserveAttrs = (newNode.getAttribute(aliasify('preserve-attr')) ?? '').split(' ');\n        for (const { name, value } of newNode.attributes) {\n            if (oldNode.getAttribute(name) !== value &&\n                !preserveAttrs.includes(kebab(name))) {\n                ;\n                oldNode.setAttribute(name, value);\n            }\n        }\n        const oldAttrs = oldNode.attributes;\n        for (let i = oldAttrs.length - 1; i >= 0; i--) {\n            const { name } = oldAttrs[i];\n            if (!newNode.hasAttribute(name) &&\n                !preserveAttrs.includes(kebab(name))) {\n                ;\n                oldNode.removeAttribute(name);\n            }\n        }\n    }\n    if (type === 8 /* comment */ || type === 3 /* text */) {\n        if (oldNode.nodeValue !== newNode.nodeValue) {\n            oldNode.nodeValue = newNode.nodeValue;\n        }\n    }\n    if (!oldNode.isEqualNode(newNode)) {\n        morphChildren(oldNode, newNode);\n    }\n    return oldNode;\n}\n// A bottom-up algorithm that populates a map of Element -> IdSet.\n// The ID set for a given element is the set of all IDs contained within its subtree.\n// As an optimization, we filter these IDs through the given list of persistent IDs,\n// because we don't need to bother considering IDed elements that won't be in the new content.\nfunction populateIdMapWithTree(root, elements) {\n    for (const elt of elements) {\n        if (ctxPersistentIds.has(elt.id)) {\n            let current = elt;\n            // walk up the parent hierarchy of that element, adding the ID of element to the parent's ID set\n            while (current && current !== root) {\n                let idSet = ctxIdMap.get(current);\n                // if the ID set doesn\u2019t exist, create it and insert it in the map\n                if (!idSet) {\n                    idSet = new Set();\n                    ctxIdMap.set(current, idSet);\n                }\n                idSet.add(elt.id);\n                current = current.parentElement;\n            }\n        }\n    }\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Patches signals.\n// Description: Patches signals.\nimport { DefaultPatchSignalsOnlyIfMissing, EventTypePatchSignals, } from '../../../engine/consts';\nimport { isBoolString, jsStrToObject } from '../../../utils/text';\nimport { datastarSSEEventWatcher } from '../shared';\nexport const PatchSignals = {\n    type: 'watcher',\n    name: EventTypePatchSignals,\n    onGlobalInit: (ctx) => datastarSSEEventWatcher(EventTypePatchSignals, ({ signals: raw = '{}', onlyIfMissing: onlyIfMissingRaw = `${DefaultPatchSignalsOnlyIfMissing}`, }) => ctx.mergePatch(jsStrToObject(raw), {\n        ifMissing: isBoolString(onlyIfMissingRaw),\n    })),\n};\n", "import { apply, load, setAlias } from '../engine';\nimport { Peek } from '../plugins/actions/peek';\nimport { SetAll } from '../plugins/actions/setAll';\nimport { ToggleAll } from '../plugins/actions/toggleAll';\nimport { Attr } from '../plugins/attributes/attr';\nimport { Bind } from '../plugins/attributes/bind';\nimport { Class } from '../plugins/attributes/class';\nimport { Computed } from '../plugins/attributes/computed';\nimport { Effect } from '../plugins/attributes/effect';\nimport { Indicator } from '../plugins/attributes/indicator';\nimport { JsonSignals } from '../plugins/attributes/jsonSignals';\nimport { On } from '../plugins/attributes/on';\nimport { OnIntersect } from '../plugins/attributes/onIntersect';\nimport { OnInterval } from '../plugins/attributes/onInterval';\nimport { OnLoad } from '../plugins/attributes/onLoad';\nimport { OnSignalPatch } from \"../plugins/attributes/onSignalPatch\";\nimport { Ref } from '../plugins/attributes/ref';\nimport { Show } from '../plugins/attributes/show';\nimport { Signals } from '../plugins/attributes/signals';\nimport { Style } from '../plugins/attributes/style';\nimport { Text } from '../plugins/attributes/text';\nimport { DELETE } from '../plugins/backend/actions/delete';\nimport { GET } from '../plugins/backend/actions/get';\nimport { PATCH } from '../plugins/backend/actions/patch';\nimport { POST } from '../plugins/backend/actions/post';\nimport { PUT } from '../plugins/backend/actions/put';\nimport { PatchElements } from '../plugins/backend/watchers/patchElements';\nimport { PatchSignals } from '../plugins/backend/watchers/patchSignals';\nload(\n// Backend\nGET, POST, PUT, PATCH, DELETE, PatchElements, PatchSignals, \n// Attributes\nAttr, Bind, Class, Computed, Effect, Indicator, JsonSignals, On, OnIntersect, OnInterval, OnLoad, OnSignalPatch, Ref, Show, Signals, Style, Text, \n// Actions\nPeek, SetAll, ToggleAll);\napply();\nexport { apply, load, setAlias };\n"],
  "mappings": "AACA,IAAMA,GAAM,YAAY,OACXC,GAAMD,GAAI,MAAM,EAAG,CAAC,EACpBE,GAAMF,GAAI,MAAM,CAAC,EACjBG,EAAW,WACXC,GAAmB,mBAInBC,GAA4B,IAQlC,IAAMC,GAAmC,GAKnCC,GAAwB,QAExBC,GAAwB,QAExBC,GAAyB,SAEzBC,GAA0B,UAE1BC,GAA0B,UAE1BC,GAAyB,SAEzBC,GAAyB,SAEzBC,GAAwB,QAExBC,GAA0BR,GAG1BS,GAAyB,0BAEzBC,GAAwB,yBC3C9B,SAASC,GAAYC,EAAI,CAC5B,OAAOA,aAAc,aAAeA,aAAc,UACtD,CCFO,IAAMC,GAAUC,GAAQA,IAAQ,MACnC,OAAOA,GAAQ,WACd,OAAO,eAAeA,CAAG,IAAM,OAAO,WACnC,OAAO,eAAeA,CAAG,IAAM,MAChC,SAASC,GAAQD,EAAK,CACzB,QAAWE,KAAQF,EACf,GAAI,OAAO,OAAOA,EAAKE,CAAI,EACvB,MAAO,GAGf,MAAO,EACX,CACO,SAASC,GAAaH,EAAKI,EAAI,CAClC,QAAWC,KAAOL,EAAK,CACnB,IAAMM,EAAMN,EAAIK,CAAG,EACfN,GAAOO,CAAG,GAAK,MAAM,QAAQA,CAAG,EAChCH,GAAaG,EAAKF,CAAE,EAGpBJ,EAAIK,CAAG,EAAID,EAAGE,CAAG,CAEzB,CACJ,CACO,IAAMC,GAAaC,GAAU,CAChC,IAAMC,EAAS,CAAC,EAChB,OAAW,CAACC,EAAMC,CAAK,IAAKH,EAAO,CAC/B,IAAMI,EAAOF,EAAK,MAAM,GAAG,EACrBG,EAAUD,EAAK,IAAI,EACnBZ,EAAMY,EAAK,OAAO,CAACE,EAAKT,IAASS,EAAIT,CAAG,IAAM,CAAC,EAAII,CAAM,EAC/DT,EAAIa,CAAO,EAAIF,CACnB,CACA,OAAOF,CACX,EChCO,IAAMM,GAAgBC,GAAQA,EAAI,KAAK,IAAM,OACvCC,EAASD,GAAQA,EACzB,QAAQ,qBAAsB,OAAO,EACrC,QAAQ,oBAAqB,OAAO,EACpC,QAAQ,oBAAqB,OAAO,EACpC,YAAY,EACJE,GAASF,GAAQC,EAAMD,CAAG,EAAE,QAAQ,MAAQG,GAAMA,EAAE,CAAC,EAAE,YAAY,CAAC,EACpEC,GAASJ,GAAQC,EAAMD,CAAG,EAAE,QAAQ,KAAM,GAAG,EAC7CK,GAAUL,GAAQE,GAAMF,CAAG,EAAE,QAAQ,iBAAmBG,GAAMA,EAAE,CAAC,EAAE,YAAY,CAAC,EAChFG,GAAiBC,GAAQ,CAClC,GAAI,CACA,OAAO,KAAK,MAAMA,CAAG,CACzB,MACM,CAGF,OAAO,SAAS,WAAWA,CAAG,GAAG,EAAE,CACvC,CACJ,EACMC,GAAU,CAAE,MAAAP,EAAO,MAAAG,GAAO,OAAAC,EAAO,EAChC,SAASI,EAAaT,EAAKU,EAAM,CACpC,QAAWC,KAAKD,EAAK,IAAI,MAAM,GAAK,CAAC,EAAG,CACpC,IAAME,EAAKJ,GAAQG,CAAC,EAChBC,IACAZ,EAAMY,EAAGZ,CAAG,EACpB,CACA,OAAOA,CACX,CCzBA,IAAMa,GAAM,+BACZ,SAASC,GAAMC,EAAMC,EAAQC,EAAW,CAAC,EAAG,CACxC,IAAMC,EAAI,IAAI,MACdA,EAAE,KAAO,GAAGC,CAAQ,IAAIJ,CAAI,SAC5B,IAAMK,EAAIC,GAAML,CAAM,EAChBM,EAAI,IAAI,gBAAgB,CAC1B,SAAU,KAAK,UAAUL,CAAQ,CACrC,CAAC,EAAE,SAAS,EACNM,EAAI,KAAK,UAAUN,EAAU,KAAM,CAAC,EAC1C,OAAAC,EAAE,QAAU,GAAGF,CAAM;AAAA,aAAgBH,EAAG,IAAIE,CAAI,IAAIK,CAAC,IAAIE,CAAC;AAAA,WAAcC,CAAC,GAClEL,CACX,CAIO,SAASM,GAAQC,EAAKC,EAAQC,EAAW,CAAC,EAAG,CAChD,IAAMC,EAAS,CACX,OAAQ,CACJ,KAAMH,EAAI,OAAO,KACjB,KAAMA,EAAI,OAAO,IACrB,CACJ,EACA,OAAOI,GAAM,OAAQH,EAAQ,OAAO,OAAOE,EAAQD,CAAQ,CAAC,CAChE,CACO,SAASG,GAAWL,EAAKC,EAAQC,EAAW,CAAC,EAAG,CACnD,IAAMC,EAAS,CACX,OAAQ,CACJ,KAAMH,EAAI,OAAO,KACjB,KAAMA,EAAI,OAAO,IACrB,EACA,QAAS,CACL,GAAIA,EAAI,GAAG,GACX,IAAKA,EAAI,GAAG,OAChB,EACA,WAAY,CACR,OAAQA,EAAI,OACZ,IAAKA,EAAI,IACT,MAAOA,EAAI,MAEX,UAAWA,EAAI,SACnB,CACJ,EACA,OAAOI,GAAM,UAAWH,EAAQ,OAAO,OAAOE,EAAQD,CAAQ,CAAC,CACnE,CC5CO,IAAMI,EAA8B,GAAGC,CAAQ,gBCKtD,IAAIC,IACH,SAAUA,EAAe,CACtBA,EAAcA,EAAc,KAAU,CAAC,EAAI,OAC3CA,EAAcA,EAAc,QAAa,CAAC,EAAI,UAC9CA,EAAcA,EAAc,SAAc,CAAC,EAAI,WAC/CA,EAAcA,EAAc,cAAmB,CAAC,EAAI,gBACpDA,EAAcA,EAAc,SAAc,CAAC,EAAI,WAC/CA,EAAcA,EAAc,MAAW,EAAE,EAAI,QAC7CA,EAAcA,EAAc,QAAa,EAAE,EAAI,SACnD,GAAGA,KAAkBA,GAAgB,CAAC,EAAE,EACxC,IAAIC,GACH,SAAUA,EAAa,CACpBA,EAAYA,EAAY,OAAY,EAAE,EAAI,QAC9C,GAAGA,IAAgBA,EAAc,CAAC,EAAE,EACpC,IAAMC,GAAe,CAAC,EAChBC,GAAgB,CAAC,EACnBC,GAAa,EACbC,GAAc,EACdC,GAAsB,EACtBC,EACEC,GAAa,IAAM,CACrBJ,IACJ,EACMK,GAAW,IAAM,CACd,EAAEL,KACHM,GAAM,EACNC,EAAS,EAEjB,EACMC,GAAUC,GACLC,GAAW,KAAK,EAAG,CACtB,cAAeD,EACf,OAAQA,EACR,OAAQ,CACZ,CAAC,EAECE,GAAiB,OAAO,UAAU,EAClCC,GAAYC,GAAW,CACzB,IAAMC,EAAIC,GAAa,KAAK,EAAG,CAC3B,OAAQ,GACR,OAAAF,CACJ,CAAC,EAED,OAAAC,EAAEH,EAAc,EAAI,EACbG,CACX,EACME,GAAUC,GAAO,CACnB,IAAMC,EAAI,CACN,IAAKD,EACL,OAAQ,CACZ,EACId,GACAgB,GAAKD,EAAGf,CAAS,EAErB,IAAMiB,EAAOC,EAAcH,CAAC,EAC5Bd,GAAW,EACX,GAAI,CACAc,EAAE,IAAI,CACV,QACA,CACIb,GAAS,EACTgB,EAAcD,CAAI,CACtB,CACA,OAAOE,GAAW,KAAK,EAAGJ,CAAC,CAC/B,EACMK,GAAQN,GAAO,CACjB,IAAMG,EAAOC,EAAc,MAAS,EACpC,GAAI,CACA,OAAOJ,EAAG,CACd,QACA,CACII,EAAcD,CAAI,CACtB,CACJ,EACMd,GAAQ,IAAM,CAChB,KAAOL,GAAcC,IAAqB,CACtC,IAAMc,EAASjB,GAAcE,EAAW,EACxCF,GAAcE,IAAa,EAAI,OAC/BuB,GAAIR,EAASA,EAAO,QAAU,CAACnB,EAAY,MAAO,CACtD,CACAI,GAAc,EACdC,GAAsB,CAC1B,EACMuB,GAAUjB,GACR,WAAYA,EACLkB,GAAelB,CAAM,EAEzBmB,GAAanB,EAAQA,EAAO,MAAM,EAEvCa,EAAiBO,GAAQ,CAC3B,IAAMC,EAAU1B,EAChB,OAAAA,EAAYyB,EACLC,CACX,EACMH,GAAkBZ,GAAM,CAC1B,IAAMe,EAAUR,EAAcP,CAAC,EAC/BgB,GAAchB,CAAC,EACf,GAAI,CACA,IAAMiB,EAAWjB,EAAE,OACnB,OAAOiB,KAAcjB,EAAE,OAASA,EAAE,OAAOiB,CAAQ,EACrD,QACA,CACIV,EAAcQ,CAAO,EACrBG,GAAYlB,CAAC,CACjB,CACJ,EACMa,GAAe,CAACM,EAAGC,KACrBD,EAAE,OAAS,EACJA,EAAE,iBAAmBA,EAAE,cAAgBC,IAE5CC,GAAU,GAAM,CAClB,IAAMC,EAAQ,EAAE,OAChB,GAAI,EAAEA,EAAQvC,EAAY,QAAS,CAC/B,EAAE,OAASuC,EAAQvC,EAAY,OAC/B,IAAMwC,EAAO,EAAE,MACXA,EACAF,GAAOE,EAAK,IAAI,EAGhBtC,GAAcG,IAAqB,EAAI,CAE/C,CACJ,EACMsB,GAAM,CAAC,EAAGY,IAAU,CACtB,GAAIA,EAAQ,IACPA,EAAQ,IAAME,GAAW,EAAE,MAAO,CAAC,EAAI,CACxC,IAAMlB,EAAOC,EAAc,CAAC,EAC5BS,GAAc,CAAC,EACf1B,GAAW,EACX,GAAI,CACA,EAAE,IAAI,CACV,QACA,CACIC,GAAS,EACTgB,EAAcD,CAAI,EAClBY,GAAY,CAAC,CACjB,CACA,MACJ,CACII,EAAQ,KACR,EAAE,OAASA,EAAQ,KAEvB,IAAIjB,EAAO,EAAE,MACb,KAAOA,GAAM,CACT,IAAMoB,EAAMpB,EAAK,KACXqB,EAAWD,EAAI,OACjBC,EAAW3C,EAAY,QACvB2B,GAAIe,EAAMA,EAAI,OAASC,EAAW,CAAC3C,EAAY,MAAO,EAE1DsB,EAAOA,EAAK,QAChB,CACJ,EACMJ,GAAgBD,GAAM,CACxB,IAAMsB,EAAQtB,EAAE,OAChB,GAAIsB,EAAQ,IACPA,EAAQ,IAAME,GAAWxB,EAAE,MAAOA,CAAC,GACpC,GAAIY,GAAeZ,CAAC,EAAG,CACnB,IAAMuB,EAAOvB,EAAE,MACXuB,GACAI,GAAiBJ,CAAI,CAE7B,OAEKD,EAAQ,KACbtB,EAAE,OAASsB,EAAQ,KAEvB,OAAIjC,GACAgB,GAAKL,EAAGX,CAAS,EAEdW,EAAE,MACb,EACMJ,GAAa,CAACuB,KAAMC,IAAU,CAChC,GAAIA,EAAM,OAAQ,CACd,IAAMQ,EAAWR,EAAM,CAAC,EACxB,GAAID,EAAE,UAAYA,EAAE,OAASS,GAAW,CACpCT,EAAE,OAAS,GACX,IAAMI,EAAOJ,EAAE,MACf,OAAII,IACAM,GAAUN,CAAI,EACTrC,IACDM,GAAM,GAGP,EACX,CACA,MAAO,EACX,CACA,IAAMsC,EAAeX,EAAE,OACvB,GAAIA,EAAE,OAAS,IACPN,GAAaM,EAAGW,CAAY,EAAG,CAC/B,IAAMC,EAAQZ,EAAE,MACZY,GACAJ,GAAiBI,CAAK,CAE9B,CAEJ,OAAI1C,GACAgB,GAAKc,EAAG9B,CAAS,EAEdyC,CACX,EACMtB,GAAc,GAAM,CACtB,IAAIiB,EAAM,EAAE,MACZ,KAAOA,GACHA,EAAMO,GAAOP,EAAK,CAAC,EAEvB,IAAMX,EAAM,EAAE,MACVA,GACAkB,GAAOlB,CAAG,EAEd,EAAE,OAAS,CACf,EACMT,GAAO,CAACoB,EAAKX,IAAQ,CACvB,IAAMmB,EAAUnB,EAAI,UACpB,GAAImB,GAAWA,EAAQ,OAASR,EAC5B,OAEJ,IAAIS,EACEC,EAAgBrB,EAAI,OAAS,EACnC,GAAIqB,IACAD,EAAUD,EAAUA,EAAQ,SAAWnB,EAAI,MACvCoB,GAAWA,EAAQ,OAAST,GAAK,CACjCX,EAAI,UAAYoB,EAChB,MACJ,CAEJ,IAAMnB,EAAUU,EAAI,UACpB,GAAIV,GACAA,EAAQ,OAASD,IAChB,CAACqB,GAAiBC,GAAYrB,EAASD,CAAG,GAC3C,OAEJ,IAAMuB,EAAWvB,EAAI,UACjBW,EAAI,UACA,CACI,KAAMA,EACN,KAAMX,EACN,SAAUmB,EACV,SAAUC,EACV,SAAUnB,CACd,EACJmB,IACAA,EAAQ,SAAWG,GAEnBJ,EACAA,EAAQ,SAAWI,EAGnBvB,EAAI,MAAQuB,EAEZtB,EACAA,EAAQ,SAAWsB,EAGnBZ,EAAI,MAAQY,CAEpB,EACML,GAAS,CAAC3B,EAAMiC,EAAOjC,EAAK,OAAS,CACvC,IAAMkC,EAAOlC,EAAK,KACZmC,EAAWnC,EAAK,SAChBoC,EAAWpC,EAAK,SAChBqC,EAAWrC,EAAK,SAChBsC,EAAWtC,EAAK,SAmBtB,GAlBIoC,EACAA,EAAS,SAAWD,EAGpBF,EAAK,UAAYE,EAEjBA,EACAA,EAAS,SAAWC,EAGpBH,EAAK,MAAQG,EAEbC,EACAA,EAAS,SAAWC,EAGpBJ,EAAK,UAAYI,EAEjBA,EACAA,EAAS,SAAWD,UAEf,EAAEH,EAAK,MAAQG,GACpB,GAAI,WAAYH,EAAM,CAClB,IAAIK,EAAWL,EAAK,MACpB,GAAIK,EAAU,CACVL,EAAK,OAAS,GACd,GACIK,EAAWZ,GAAOY,EAAUL,CAAI,QAC3BK,EACb,CACJ,KACW,kBAAmBL,GAC1B/B,GAAW+B,CAAI,EAGvB,OAAOE,CACX,EACMZ,GAAaxB,GAAS,CACxB,IAAIwC,EAAOxC,EAAK,SACZyC,EACJC,EAAK,OAAa,CACd,IAAMjC,EAAMT,EAAK,KACbiB,EAAQR,EAAI,OAChB,GAAIQ,EAAQ,IACFA,EACF,GAGOA,EAAQ,GAGRA,EAAQ,EAKV,EAAEA,EAAQ,KACfc,GAAY/B,EAAMS,CAAG,GACrBA,EAAI,OACAQ,EAAQ,GACZA,GAAS,GAGTA,EAAQ,EAXRR,EAAI,OACCQ,EAAQ,GACL,GALRA,EAAQ,EAHRR,EAAI,OAASQ,EAAQ,GAmBrBA,EAAQ,GACRD,GAAOP,CAAG,EAEVQ,EAAQ,GAAG,CACX,IAAM0B,EAAUlC,EAAI,MACpB,GAAIkC,EAAS,CACT3C,EAAO2C,EACHA,EAAQ,WACRF,EAAQ,CAAE,OAAQD,EAAM,MAAOC,CAAM,EACrCD,EAAOxC,EAAK,UAEhB,QACJ,CACJ,CAEJ,GAAKA,EAAOwC,EAAO,CACfA,EAAOxC,EAAK,SACZ,QACJ,CACA,KAAOyC,GAGH,GAFAzC,EAAOyC,EAAM,OACbA,EAAQA,EAAM,MACVzC,EAAM,CACNwC,EAAOxC,EAAK,SACZ,SAAS0C,CACb,CAEJ,KACJ,CACJ,EACM/B,GAAiBF,GAAQ,CAC3BA,EAAI,UAAY,OAChBA,EAAI,OACCA,EAAI,OACD,IACA,CACZ,EACMI,GAAeJ,GAAQ,CACzB,IAAMmC,EAAYnC,EAAI,UAClB8B,EAAWK,EAAYA,EAAU,SAAWnC,EAAI,MACpD,KAAO8B,GACHA,EAAWZ,GAAOY,EAAU9B,CAAG,EAEnCA,EAAI,QAAU,EAClB,EACMU,GAAa,CAACnB,EAAMS,IAAQ,CAC9B,IAAIgC,EACAI,EAAa,EACjBH,EAAK,OAAa,CACd,IAAMtB,EAAMpB,EAAK,KACXqB,EAAWD,EAAI,OACjB0B,EAAQ,GACZ,GAAIrC,EAAI,OAAS,GACbqC,EAAQ,YAEFzB,EAAW,MACjB,IACA,GAAIf,GAAOc,CAAG,EAAG,CACb,IAAMF,EAAOE,EAAI,MACbF,EAAK,UACLI,GAAiBJ,CAAI,EAEzB4B,EAAQ,EACZ,WAEMzB,EAAW,MACjB,GAAI,EACArB,EAAK,UAAYA,EAAK,YACtByC,EAAQ,CAAE,OAAQzC,EAAM,MAAOyC,CAAM,GAEzCzC,EAAOoB,EAAI,MACXX,EAAMW,EACN,EAAEyB,EACF,QACJ,CACA,GAAI,CAACC,GAAS9C,EAAK,SAAU,CACzBA,EAAOA,EAAK,SACZ,QACJ,CACA,KAAO6C,GAAY,CACf,EAAEA,EACF,IAAME,EAAWtC,EAAI,MACfuC,EAAkBD,EAAS,SAQjC,GAPIC,GACAhD,EAAOyC,EAAM,OACbA,EAAQA,EAAM,OAGdzC,EAAO+C,EAEPD,GACA,GAAIxC,GAAOG,CAAG,EAAG,CACTuC,GACA1B,GAAiByB,CAAQ,EAE7BtC,EAAMT,EAAK,KACX,QACJ,OAGAS,EAAI,QAAU,IAGlB,GADAA,EAAMT,EAAK,KACPA,EAAK,SAAU,CACfA,EAAOA,EAAK,SACZ,SAAS0C,CACb,CACAI,EAAQ,EACZ,CACA,OAAOA,CACX,CACJ,EACMxB,GAAoBtB,GAAS,CAC/B,EAAG,CACC,IAAMS,EAAMT,EAAK,KACXiD,EAAUjD,EAAK,SACfkD,EAAWzC,EAAI,QAChByC,EAAW,MACZ,KACAzC,EAAI,OAASyC,EAAW,GACpBA,EAAW,GACXlC,GAAOP,CAAG,GAGlBT,EAAOiD,CACX,OAASjD,EACb,EACM+B,GAAc,CAACoB,EAAW1C,IAAQ,CACpC,IAAM2C,EAAW3C,EAAI,UACrB,GAAI2C,EAAU,CACV,IAAIpD,EAAOS,EAAI,MACf,EAAG,CACC,GAAIT,IAASmD,EACT,MAAO,GAEX,GAAInD,IAASoD,EACT,MAEJpD,EAAOA,EAAK,QAChB,OAASA,EACb,CACA,MAAO,EACX,EACMqD,GAAWC,GAAS,CACtB,IAAIC,EAASC,EACPC,EAAQH,EAAK,MAAM,GAAG,EAC5B,QAAWA,KAAQG,EAAO,CACtB,GAAIF,GAAU,MAAQ,CAAC,OAAO,OAAOA,EAAQD,CAAI,EAC7C,OAEJC,EAASA,EAAOD,CAAI,CACxB,CACA,OAAOC,CACX,EACaG,GAAS,OAAO,QAAQ,EAC/BC,GAAO,CAAC5C,EAAO6C,EAAS,KAAO,CACjC,IAAMC,EAAQ,MAAM,QAAQ9C,CAAK,EACjC,GAAI8C,GAASC,GAAO/C,CAAK,EAAG,CACxB,IAAMgD,EAAWF,EAAQ,CAAC,EAAI,CAAC,EAC/B,QAAWG,KAAOjD,EACdgD,EAAQC,CAAG,EAAI3E,GAAOsE,GAAK5C,EAAMiD,CAAG,EAAG,GAAGJ,EAASI,CAAG,GAAG,CAAC,EAE9D,IAAMC,EAAO5E,GAAO,CAAC,EACrB,OAAO,IAAI,MAAM0E,EAAS,CACtB,IAAIG,EAAGC,EAAM,CACT,GAAI,EAAEA,IAAS,UAAY,CAAC,OAAO,OAAOJ,EAASI,CAAI,GACnD,OAAIN,GAASM,KAAQ,MAAM,WACvBF,EAAK,EACEF,EAAQI,CAAI,GAGf,OAAOA,GAAS,SACTJ,EAAQI,CAAI,IAEnB,CAAC,OAAO,OAAOJ,EAASI,CAAI,GAAKJ,EAAQI,CAAI,EAAE,GAAK,QACpDJ,EAAQI,CAAI,EAAI9E,GAAO,EAAE,EACzBD,EAASwE,EAASO,EAAM,EAAE,EAC1BF,EAAKA,EAAK,EAAI,CAAC,GAEZF,EAAQI,CAAI,EAAE,EAGjC,EACA,IAAID,EAAGC,EAAM5C,EAAU,CACnB,IAAM+B,EAAOM,EAASO,EACtB,GAAI5C,IAAamC,GACT,OAAO,OAAOK,EAASI,CAAI,IAC3B,OAAOJ,EAAQI,CAAI,EACnB/E,EAASkE,EAAMI,EAAM,EACrBO,EAAKA,EAAK,EAAI,CAAC,WAIfJ,GAASM,IAAS,SAAU,CAC5B,IAAMC,EAAOL,EAAQI,CAAI,EAAI5C,EAE7B,GADAwC,EAAQI,CAAI,EAAI5C,EACZ6C,EAAO,EAAG,CACV,IAAMC,EAAQ,CAAC,EACf,QAASC,EAAI/C,EAAU+C,EAAIP,EAAQI,CAAI,EAAGG,IACtCD,EAAMC,CAAC,EAAI,KAEflF,EAASwE,EAAO,MAAM,EAAG,EAAE,EAAGS,CAAK,EACnCJ,EAAKA,EAAK,EAAI,CAAC,CACnB,CACJ,MAEQ,OAAO,OAAOF,EAASI,CAAI,EACvB5C,GAAY,KACRwC,EAAQI,CAAI,EAAE,IAAI,GAClB/E,EAASkE,EAAM,IAAI,EAInB,OAAO,OAAO/B,EAAU/B,EAAc,GACtCuE,EAAQI,CAAI,EAAI5C,EAChBnC,EAASkE,EAAM,EAAE,GAGbS,EAAQI,CAAI,EAAER,GAAKpC,EAAU,GAAG+B,CAAI,GAAG,CAAC,GACxClE,EAASkE,EAAM/B,CAAQ,EAM/BA,GAAY,OACR,OAAO,OAAOA,EAAU/B,EAAc,GACtCuE,EAAQI,CAAI,EAAI5C,EAChBnC,EAASkE,EAAM,EAAE,IAGjBS,EAAQI,CAAI,EAAI9E,GAAOsE,GAAKpC,EAAU,GAAG+B,CAAI,GAAG,CAAC,EACjDlE,EAASkE,EAAM/B,CAAQ,GAE3B0C,EAAKA,EAAK,EAAI,CAAC,GAK/B,MAAO,EACX,EACA,eAAeC,EAAGC,EAAM,CACpB,OAAI,OAAO,OAAOJ,EAASI,CAAI,GACvBJ,EAAQI,CAAI,EAAE,IAAI,GAClB/E,EAASwE,EAASO,EAAM,IAAI,EAG7B,EACX,EACA,SAAU,CACN,OAAAF,EAAK,EACE,QAAQ,QAAQF,CAAO,CAClC,EACA,IAAIG,EAAGC,EAAM,CACT,OAAAF,EAAK,EACEE,KAAQJ,CACnB,CACJ,CAAC,CACL,CACA,OAAOhD,CACX,EACM3B,EAAW,CAACkE,EAAMvC,IAAU,CAI9B,GAHIuC,IAAS,QAAavC,IAAU,QAChCpC,GAAa,KAAK,CAAC2E,EAAMvC,CAAK,CAAC,EAE/B,CAAClC,IAAcF,GAAa,OAAQ,CACpC,IAAM4F,EAASC,GAAU7F,EAAY,EACrCA,GAAa,OAAS,EACtB,SAAS,cAAc,IAAI,YAAY8F,EAA6B,CAChE,OAAAF,CACJ,CAAC,CAAC,CACN,CACJ,EACMG,GAAa,CAACL,EAAO,CAAE,UAAAM,CAAU,EAAI,CAAC,IAAM,CAC9C1F,GAAW,EACX,QAAW+E,KAAOK,EACVA,EAAML,CAAG,GAAK,KACTW,GACD,OAAOnB,EAAKQ,CAAG,EAInBY,GAAWP,EAAML,CAAG,EAAGA,EAAKR,EAAM,GAAImB,CAAS,EAGvDzF,GAAS,CACb,EACM2F,GAAa,CAACC,EAAOC,EAAU,CAAC,IAAML,GAAWF,GAAUM,CAAK,EAAGC,CAAO,EAC1EH,GAAa,CAACP,EAAOW,EAAQC,EAAcrB,EAAQe,IAAc,CACnE,GAAIb,GAAOO,CAAK,EAAG,CACT,OAAO,OAAOY,EAAcD,CAAM,IACnClB,GAAOmB,EAAaD,CAAM,CAAC,GAAK,MAAM,QAAQC,EAAaD,CAAM,CAAC,KACnEC,EAAaD,CAAM,EAAI,CAAC,GAE5B,QAAWhB,KAAOK,EACVA,EAAML,CAAG,GAAK,KACTW,GACD,OAAOM,EAAaD,CAAM,EAAEhB,CAAG,EAInCY,GAAWP,EAAML,CAAG,EAAGA,EAAKiB,EAAaD,CAAM,EAAG,GAAGpB,EAASoB,CAAM,IAAKL,CAAS,CAG9F,MACWA,GAAa,OAAO,OAAOM,EAAcD,CAAM,IACtDC,EAAaD,CAAM,EAAIX,EAE/B,EACA,SAASa,GAAS,CAAE,QAAAC,EAAU,KAAM,QAAAC,EAAU,MAAO,EAAI,CAAC,EAAGC,EAAM7B,EAAM,CAErE,IAAMsB,EAAQ,CAAC,EACTrC,EAAQ,CAAC,CAAC4C,EAAK,EAAE,CAAC,EACxB,KAAO5C,EAAM,QAAQ,CACjB,GAAM,CAAC6C,EAAM1B,CAAM,EAAInB,EAAM,IAAI,EACjC,QAAWuB,KAAOsB,EAAM,CACpB,IAAMhC,EAAOM,EAASI,EAClBF,GAAOwB,EAAKtB,CAAG,CAAC,EAChBvB,EAAM,KAAK,CAAC6C,EAAKtB,CAAG,EAAG,GAAGV,CAAI,GAAG,CAAC,EAE7BiC,GAASJ,CAAO,EAAE,KAAK7B,CAAI,GAChC,CAACiC,GAASH,CAAO,EAAE,KAAK9B,CAAI,GAC5BwB,EAAM,KAAK,CAACxB,EAAMD,GAAQC,CAAI,CAAC,CAAC,CAExC,CACJ,CACA,OAAOkB,GAAUM,CAAK,CAC1B,CACA,SAASS,GAASC,EAAK,CACnB,OAAI,OAAOA,GAAQ,SACR,OAAOA,EAAI,QAAQ,WAAY,EAAE,CAAC,EAEtCA,CACX,CACA,IAAMhC,EAAOG,GAAK,CAAC,CAAC,EAKd8B,GAAU,CAAC,EACXC,GAAU,CAAC,EACbC,GAAe,CAAC,EAEdC,GAAW,IAAI,IACjBC,GAAmB,KACnBC,GAAQ,GACL,SAASC,GAAShF,EAAO,CAC5B+E,GAAQ/E,CACZ,CACO,SAASiF,EAASC,EAAM,CAC3B,OAAOH,GAAQ,QAAQA,EAAK,IAAIG,CAAI,GAAK,QAAQA,CAAI,EACzD,CACO,SAASC,MAAQC,EAAe,CACnC,QAAWC,KAAUD,EAAe,CAChC,IAAME,EAAM,CACR,OAAAD,EACA,QAAAX,GACA,KAAAjC,EACA,SAAA0B,GACA,OAAA7F,GACA,SAAAI,GACA,OAAAI,GACA,WAAA6E,GACA,WAAAG,GACA,KAAAzE,GACA,QAAAiD,GACA,WAAApE,GACA,SAAAC,GACA,QAAS,CACb,EAEA,GADAmH,EAAI,QAAUC,GAAQ,KAAK,EAAGD,CAAG,EAC7BD,EAAO,OAAS,SAChBX,GAAQW,EAAO,IAAI,EAAIA,UAElBA,EAAO,OAAS,YACrBV,GAAQ,KAAKU,CAAM,EACnBA,EAAO,eAAeC,CAAG,UAEpBD,EAAO,OAAS,UACrBA,EAAO,eAAeC,CAAG,MAGzB,OAAMA,EAAI,QAAQ,mBAAmB,CAE7C,CAEAX,GAAQ,KAAK,CAACa,EAAGC,IAAM,CACnB,IAAMC,EAAUD,EAAE,KAAK,OAASD,EAAE,KAAK,OACvC,OAAIE,IAAY,EACLA,EACJF,EAAE,KAAK,cAAcC,EAAE,IAAI,CACtC,CAAC,EACDb,GAAeD,GAAQ,IAAKU,GAAW,OAAO,IAAIA,EAAO,IAAI,aAAa,CAAC,CAC/E,CACA,SAASM,GAASC,EAAK,CACnB,IAAMC,EAAS,IAAIZ,EAAS,QAAQ,CAAC,IACrC,QAAWa,KAAMF,EACb,GAAI,CAACE,EAAG,QAAQD,CAAM,EAClB,QAAW5C,KAAO6C,EAAG,QACjBC,GAAqBD,EAAI7C,EAAK6C,EAAG,QAAQ7C,CAAG,CAAC,CAI7D,CACA,SAAS+C,GAAWJ,EAAK,CACrB,QAAWE,KAAMF,EAAK,CAClB,IAAMK,EAAWpB,GAAS,IAAIiB,CAAE,EAEhC,GAAIjB,GAAS,OAAOiB,CAAE,EAAG,CACrB,QAAWI,KAAWD,EAAS,OAAO,EAClCC,EAAQ,EAEZD,EAAS,MAAM,CACnB,CACJ,CACJ,CAEO,SAASE,GAAM1D,EAAO,SAAS,KAAM,CAExC,eAAe,IAAM,CACjBkD,GAAS,CAAClD,CAAI,CAAC,EACfkD,GAASlD,EAAK,iBAAiB,GAAG,CAAC,EAG9BqC,KACDA,GAAmB,IAAI,iBAAiBsB,EAAO,EAC/CtB,GAAiB,QAAQrC,EAAM,CAC3B,QAAS,GACT,UAAW,GACX,WAAY,EAChB,CAAC,EAET,CAAC,CACL,CACA,SAASsD,GAAqBD,EAAIO,EAASrG,EAAO,CAC9C,GAAIqG,EAAQ,WAAWtB,EAAK,EAAG,CAC3B,IAAMuB,EAASC,GAAMxB,GAAQsB,EAAQ,MAAMtB,GAAM,MAAM,EAAIsB,CAAO,EAC5DhB,EAASV,GAAQ,KAAK,CAACxB,EAAGI,IAAMqB,GAAarB,CAAC,EAAE,KAAK+C,CAAM,CAAC,EAClE,GAAIjB,EAAQ,CAER,GAAI,CAACpC,EAAK,GAAGuD,CAAY,EAAIF,EAAO,MAAMjB,EAAO,KAAK,MAAM,EAAE,MAAM,KAAK,EACnEoB,EAAS,CAAC,CAACxD,EACbwD,IACAxD,EAAMsD,GAAMtD,CAAG,GAEnB,IAAMyD,EAAW,CAAC,CAAC1G,EAEbsF,EAAM,CACR,OAAAD,EACA,QAAAX,GACA,KAAAjC,EACA,SAAA0B,GACA,OAAA7F,GACA,SAAAI,GACA,OAAAI,GACA,WAAA6E,GACA,WAAAG,GACA,KAAAzE,GACA,QAAAiD,GACA,WAAApE,GACA,SAAAC,GACA,QAAS,EACT,GAAA2H,EACA,OAAAQ,EACA,IAAArD,EACA,MAAAjD,EACA,KAAM,IAAI,IACV,WAAY,EACZ,GAAI,CACR,EACAsF,EAAI,QAAUC,GAAQ,KAAK,EAAGD,CAAG,EACjCA,EAAI,WAAaqB,GAAW,KAAK,EAAGrB,CAAG,GACnCD,EAAO,iBAAmB,QAC1BA,EAAO,iBAAmB,MAC1BC,EAAI,GAAKsB,GAA2BtB,CAAG,GAG3C,IAAMuB,EAASxB,EAAO,QAAU,UAChC,GAAIoB,GACA,GAAII,IAAW,SACX,MAAMvB,EAAI,WAAW,GAAGD,EAAO,IAAI,eAAe,UAGjDwB,IAAW,OAChB,MAAMvB,EAAI,WAAW,GAAGD,EAAO,IAAI,aAAa,EAEpD,IAAMyB,EAASzB,EAAO,QAAU,UAChC,GAAIqB,GACA,GAAII,IAAW,SACX,MAAMxB,EAAI,WAAW,GAAGD,EAAO,IAAI,iBAAiB,UAGnDyB,IAAW,OAChB,MAAMxB,EAAI,WAAW,GAAGD,EAAO,IAAI,eAAe,EAGtD,GAAIwB,IAAW,aAAeC,IAAW,YAAa,CAClD,GAAIL,GAAUC,EACV,MAAMpB,EAAI,WAAW,GAAGD,EAAO,IAAI,qBAAqB,EAE5D,GAAI,CAACoB,GAAU,CAACC,EACZ,MAAMpB,EAAI,WAAW,GAAGD,EAAO,IAAI,oBAAoB,CAE/D,CACA,QAAW0B,KAAUP,EAAc,CAC/B,GAAM,CAACQ,EAAO,GAAGC,CAAG,EAAIF,EAAO,MAAM,GAAG,EACxCzB,EAAI,KAAK,IAAIiB,GAAMS,CAAK,EAAG,IAAI,IAAIC,EAAI,IAAKC,GAAMA,EAAE,YAAY,CAAC,CAAC,CAAC,CACvE,CACA,IAAMhB,EAAUb,EAAO,OAAOC,CAAG,EACjC,GAAIY,EAAS,CACT,IAAID,EAAWpB,GAAS,IAAIiB,CAAE,EAC1BG,EACAA,EAAS,IAAIK,CAAM,IAAI,GAGvBL,EAAW,IAAI,IACfpB,GAAS,IAAIiB,EAAIG,CAAQ,GAE7BA,EAAS,IAAIK,EAAQJ,CAAO,CAChC,CACJ,CACJ,CACJ,CAEA,SAASE,GAAQe,EAAW,CACxB,IAAMtB,EAAS,IAAIZ,EAAS,QAAQ,CAAC,IACrC,OAAW,CAAE,OAAAhB,EAAQ,KAAAmD,EAAM,cAAAC,EAAe,WAAAC,EAAY,aAAAC,CAAc,IAAKJ,EACrE,GAAIC,IAAS,YAAa,CACtB,QAAW7C,KAAQgD,EACXC,GAAYjD,CAAI,IAChByB,GAAW,CAACzB,CAAI,CAAC,EACjByB,GAAWzB,EAAK,iBAAiB,GAAG,CAAC,GAG7C,QAAWA,KAAQ+C,EACXE,GAAYjD,CAAI,IAChBoB,GAAS,CAACpB,CAAI,CAAC,EACfoB,GAASpB,EAAK,iBAAiB,GAAG,CAAC,EAG/C,SACS6C,IAAS,cAEVI,GAAYvD,CAAM,GAAK,CAACA,EAAO,QAAQ4B,CAAM,EAAG,CAChD,IAAM5C,EAAMsD,GAAMc,EAAc,MAAM,CAAC,CAAC,EAClCrH,EAAQiE,EAAO,aAAaoD,CAAa,EAC/C,GAAIrH,IAAU,KAAM,CAChB,IAAMiG,EAAWpB,GAAS,IAAIZ,CAAM,EAChCgC,IACAA,EAAS,IAAIhD,CAAG,IAAI,EACpBgD,EAAS,OAAOhD,CAAG,EAE3B,MAEI8C,GAAqB9B,EAAQhB,EAAKjD,CAAK,CAE/C,CAGZ,CACA,SAAS4G,GAA2BtB,EAAK,CACrC,IAAImC,EAAO,GACLC,EAAapC,EAAI,QAAU,OAEjC,GAAIoC,GAAY,aAAc,CAqB1B,IAAMC,EAAc,4JACdC,EAAatC,EAAI,MAAM,KAAK,EAAE,MAAMqC,CAAW,EACrD,GAAIC,EAAY,CACZ,IAAMC,EAAUD,EAAW,OAAS,EAC9BE,EAAOF,EAAWC,CAAO,EAAE,KAAK,EACjCC,EAAK,WAAW,QAAQ,IACzBF,EAAWC,CAAO,EAAI,WAAWC,CAAI,MAEzCL,EAAOG,EAAW,KAAK;AAAA,CAAK,CAChC,CACJ,MAEIH,EAAOnC,EAAI,MAAM,KAAK,EAsB1BmC,EAAOA,EAEF,QAAQ,gCAAiC,MAAM,EAE/C,QAAQ,kCAAmC,CAACtE,EAAG4E,IAClCA,EAAW,MAAM,GAAG,EACrB,OAAO,CAACC,EAAKC,IAAS,GAAGD,CAAG,KAAKC,CAAI,KAAM,GAAG,CAC9D,EAEI,QAAQ,0BAA2B,CAAC9E,EAAG+E,IAAY,OAAOA,EAAQ,MAAM,CAAC,CAAC,KAAK,EAEpF,IAAMC,EAAU,IAAI,IACdC,EAAW,OAAO,MAAMC,EAAG,YAAYC,EAAG,IAAK,IAAI,EACrDC,EAAU,EACd,QAAWC,KAASf,EAAK,SAASW,CAAQ,EAAG,CACzC,IAAMK,EAAID,EAAM,CAAC,EACX,EAAI,YAAYD,GAAS,GAC/BJ,EAAQ,IAAI,EAAGM,CAAC,EAChBhB,EAAOA,EAAK,QAAQY,GAAMI,EAAIH,GAAK,CAAC,CACxC,CACA,IAAMI,EAAU,CAAC7F,EAAQqC,IACd,GAAGrC,CAAM,GAAG8F,GAAMzD,CAAI,EAAE,WAAW,MAAO,GAAG,CAAC,GAGnD0D,EAAgB,IAAI,IACpBC,EAAY,OAAO,KAAK,OAAO,KAAKnE,EAAO,EAAE,KAAK,GAAG,CAAC,OAAQ,IAAI,EAClEoE,EAAgB,CAAC,GAAGrB,EAAK,SAASoB,CAAS,CAAC,EAC5CE,EAAc,IAAI,IAClBC,EAAY,IAAI,IACtB,GAAIF,EAAc,OAAQ,CACtB,IAAMG,EAAe,GAAGC,CAAQ,OAChC,QAAWV,KAASM,EAAe,CAC/B,IAAMK,EAAaX,EAAM,CAAC,EACpBY,EAAS1E,GAAQyE,CAAU,EACjC,GAAI,CAACC,EACD,SAEJR,EAAc,IAAIO,CAAU,EAC5B,IAAMjE,EAAOwD,EAAQO,EAAcE,CAAU,EAE7C1B,EAAOA,EAAK,QAAQ,IAAI0B,CAAU,IAAK,GAAGjE,CAAI,GAAG,EACjD6D,EAAY,IAAI7D,CAAI,EACpB8D,EAAU,IAAI,IAAIK,IAASD,EAAO,GAAG9D,EAAK,GAAG+D,CAAI,CAAC,CACtD,CACJ,CAEA,OAAW,CAACZ,EAAGa,CAAC,IAAKnB,EACjBV,EAAOA,EAAK,QAAQgB,EAAGa,CAAC,EAE5BhE,EAAI,UAAYmC,EAChB,GAAI,CACA,IAAM1I,EAAK,SAAS,KAAM,IAAK,GAAI2I,GAAY,UAAY,CAAC,EAAI,GAAGqB,EAAatB,CAAI,EACpF,MAAO,IAAI4B,IAAS,CAChB,GAAI,CACA,OAAOtK,EAAGuG,EAAI,GAAI7C,EAAM,GAAG4G,EAAM,GAAGL,CAAS,CACjD,OACOhK,EAAG,CACN,MAAMsG,EAAI,WAAW,oBAAqB,CACtC,MAAOtG,EAAE,OACb,CAAC,CACL,CACJ,CACJ,OACOuK,EAAO,CACV,MAAMjE,EAAI,WAAW,qBAAsB,CACvC,MAAOiE,EAAM,OACjB,CAAC,CACL,CACJ,CC1/BO,IAAMC,GAAO,CAChB,KAAM,SACN,KAAM,OACN,GAAI,CAAC,CAAE,KAAAC,CAAK,EAAGC,IACJD,EAAKC,CAAE,CAEtB,ECLO,IAAMC,GAAS,CAClB,KAAM,SACN,KAAM,SACN,GAAI,CAAC,CAAE,SAAAC,EAAU,WAAAC,EAAY,KAAAC,CAAK,EAAGC,EAAOC,IAAW,CACnDF,EAAK,IAAM,CACP,IAAMG,EAASL,EAASI,CAAM,EAC9BE,GAAaD,EAAQ,IAAMF,CAAK,EAChCF,EAAWI,CAAM,CACrB,CAAC,CACL,CACJ,ECVO,IAAME,GAAY,CACrB,KAAM,SACN,KAAM,YACN,GAAI,CAAC,CAAE,SAAAC,EAAU,WAAAC,EAAY,KAAAC,CAAK,EAAGC,IAAW,CAC5CD,EAAK,IAAM,CACP,IAAME,EAASJ,EAASG,CAAM,EAC9BE,GAAaD,EAASE,GAAa,CAACA,CAAQ,EAC5CL,EAAWG,CAAM,CACrB,CAAC,CACL,CACJ,ECVO,IAAMG,GAAO,CAChB,KAAM,YACN,KAAM,OACN,OAAQ,OACR,aAAc,GACd,OAAQ,CAAC,CAAE,GAAAC,EAAI,OAAAC,EAAQ,IAAAC,EAAK,GAAAC,CAAG,IAAM,CACjC,IAAMC,EAAW,CAACF,EAAKG,IAAQ,CACvBA,IAAQ,IAAMA,IAAQ,GACtBL,EAAG,aAAaE,EAAK,EAAE,EAElBG,IAAQ,IAASA,GAAO,KAC7BL,EAAG,gBAAgBE,CAAG,EAEjB,OAAOG,GAAQ,SACpBL,EAAG,aAAaE,EAAKG,CAAG,EAGxBL,EAAG,aAAaE,EAAK,KAAK,UAAUG,CAAG,CAAC,CAEhD,EACAH,EAAMI,EAAMJ,CAAG,EACf,IAAMK,EAASL,EACT,IAAM,CACJM,EAAS,WAAW,EACpB,IAAMH,EAAMF,EAAG,EACfC,EAASF,EAAKG,CAAG,EACjBG,EAAS,QAAQR,EAAI,CACjB,gBAAiB,CAACE,CAAG,CACzB,CAAC,CACL,EACE,IAAM,CACJM,EAAS,WAAW,EACpB,IAAMC,EAAMN,EAAG,EACTO,EAAkB,OAAO,KAAKD,CAAG,EACvC,QAAWP,KAAOQ,EACdN,EAASF,EAAKO,EAAIP,CAAG,CAAC,EAE1BM,EAAS,QAAQR,EAAI,CACjB,gBAAAU,CACJ,CAAC,CACL,EACEF,EAAW,IAAI,iBAAiBD,CAAM,EACtCI,EAAUV,EAAOM,CAAM,EAC7B,MAAO,IAAM,CACTC,EAAS,WAAW,EACpBG,EAAQ,CACZ,CACJ,CACJ,EC/CA,IAAMC,GAAe,+CACfC,GAAQ,OAAO,OAAO,EACfC,GAAO,CAChB,KAAM,YACN,KAAM,OACN,OAAQ,YACR,OAAQ,YACR,eAAgB,GAChB,OAAQ,CAAC,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,MAAAC,EAAO,OAAAC,EAAQ,WAAAC,EAAY,WAAAC,EAAY,QAAAC,CAAS,IAAM,CAC5E,IAAMC,EAAaP,EAAMQ,EAAaR,EAAKC,CAAI,EAAIC,EAC/CO,EAAM,CAACV,EAAIW,IAASA,IAAS,SAAW,CAACX,EAAG,MAAQA,EAAG,MACvDY,EAAOT,GAAU,CAEjBH,EAAG,MAAQ,GAAGG,CAAK,EACvB,EACA,GAAIH,aAAc,iBACd,OAAQA,EAAG,KAAM,CACb,IAAK,QACL,IAAK,SACDU,EAAM,CAACV,EAAIW,IAASA,IAAS,SAAWX,EAAG,MAAQ,CAACA,EAAG,MACvD,MACJ,IAAK,WACDU,EAAM,CAACV,EAAIW,IACHX,EAAG,QAAU,KACTW,IAAS,UACFX,EAAG,QAGHA,EAAG,QAAUA,EAAG,MAAQ,GAI/BW,IAAS,SACFX,EAAG,QAAUA,EAAG,MAAQ,GAGxBA,EAAG,QAItBY,EAAOT,GAAU,CACbH,EAAG,QAAU,OAAOG,GAAU,SAAWA,IAAUH,EAAG,MAAQG,CAClE,EACA,MACJ,IAAK,QAEIH,EAAG,aAAa,MAAM,GAAG,QAC1BA,EAAG,aAAa,OAAQQ,CAAU,EAEtCE,EAAM,CAACV,EAAIW,IAASX,EAAG,QAAWW,IAAS,SAAW,CAACX,EAAG,MAAQA,EAAG,MAASF,GAC9Ec,EAAOT,GAAU,CACbH,EAAG,QACCG,KAAW,OAAOA,GAAU,SAAW,CAACH,EAAG,MAAQA,EAAG,MAC9D,EACA,MACJ,IAAK,OAAQ,CACT,IAAMa,EAAa,IAAM,CACrB,IAAMC,EAAQ,CAAC,GAAId,EAAG,OAAS,CAAC,CAAE,EAC5Be,EAAW,CAAC,EACZC,EAAQ,CAAC,EACTC,EAAQ,CAAC,EACf,QAAQ,IAAIH,EAAM,IAAKI,GAAM,IAAI,QAASC,GAAY,CAClD,IAAMC,EAAS,IAAI,WACnBA,EAAO,OAAS,IAAM,CAClB,GAAI,OAAOA,EAAO,QAAW,SACzB,MAAMd,EAAW,wBAAyB,CACtC,WAAY,OAAOc,EAAO,MAC9B,CAAC,EAEL,IAAMC,EAAQD,EAAO,OAAO,MAAMvB,EAAY,EAC9C,GAAI,CAACwB,GAAO,OACR,MAAMf,EAAW,iBAAkB,CAC/B,OAAQc,EAAO,MACnB,CAAC,EAELL,EAAS,KAAKM,EAAM,OAAO,QAAQ,EACnCL,EAAM,KAAKK,EAAM,OAAO,IAAI,EAC5BJ,EAAM,KAAKC,EAAE,IAAI,CACrB,EACAE,EAAO,UAAY,IAAMD,EAAQ,EACjCC,EAAO,cAAcF,CAAC,CAC1B,CAAC,CAAC,CAAC,EAAE,KAAK,IAAM,CACZb,EAAW,CACP,CAACG,EAAYO,CAAQ,EACrB,CAAC,GAAGP,CAAU,QAASQ,CAAK,EAC5B,CAAC,GAAGR,CAAU,QAASS,CAAK,CAChC,CAAC,CACL,CAAC,CACL,EACA,OAAAjB,EAAG,iBAAiB,SAAUa,CAAU,EACxCb,EAAG,iBAAiB,QAASa,CAAU,EAChC,IAAM,CACTb,EAAG,oBAAoB,SAAUa,CAAU,EAC3Cb,EAAG,oBAAoB,QAASa,CAAU,CAC9C,CACJ,CACJ,SAEKb,aAAc,mBACnB,GAAIA,EAAG,SAAU,CACb,IAAMsB,EAAU,IAAI,IACpBZ,EAAOV,GAAO,CAAC,GAAGA,EAAG,eAAe,EAAE,IAAKuB,GAAW,CAClD,IAAMZ,EAAOW,EAAQ,IAAIC,EAAO,KAAK,EACrC,OAAOZ,IAAS,UAAYA,GAAQ,KAC9BY,EAAO,MACP,CAACA,EAAO,KAClB,CAAC,EACDX,EAAOT,GAAU,CACb,QAAWoB,KAAUvB,EAAG,QAChBG,EAAM,SAASoB,EAAO,KAAK,GAC3BD,EAAQ,IAAIC,EAAO,MAAO,QAAQ,EAClCA,EAAO,SAAW,IAEbpB,EAAM,SAAS,CAACoB,EAAO,KAAK,GACjCD,EAAQ,IAAIC,EAAO,MAAO,QAAQ,EAClCA,EAAO,SAAW,IAGlBA,EAAO,SAAW,EAG9B,CACJ,OAEKvB,aAAc,sBAKnBU,EAAOV,GAAO,UAAWA,EAAKA,EAAG,MAAQA,EAAG,aAAa,OAAO,EAChEY,EAAOT,GAAU,CACT,UAAWH,EACXA,EAAG,MAAQG,EAGXH,EAAG,aAAa,QAASG,CAAK,CAEtC,GAEJ,IAAMqB,EAAejB,EAAQC,CAAU,EACjCG,EAAO,OAAOa,EAChBC,EAAOjB,EACX,GAAI,MAAM,QAAQgB,CAAY,GAC1B,EAAExB,aAAc,mBAAqBA,EAAG,UAAW,CACnD,IAAM0B,EAAS,SAAS,iBAAiB,IAAIC,EAAS,MAAM,CAAC,IAAI1B,CAAG,MAAM0B,EAAS,MAAM,CAAC,KAAKxB,CAAK,IAAI,EAClGyB,EAAQ,CAAC,EACXC,EAAI,EACR,QAAWC,KAASJ,EAAQ,CAExB,GADAE,EAAM,KAAK,CAAC,GAAGH,CAAI,IAAII,CAAC,GAAInB,EAAIoB,EAAO,MAAM,CAAC,CAAC,EAC3C9B,IAAO8B,EACP,MAEJD,GACJ,CACAxB,EAAWuB,EAAO,CAAE,UAAW,EAAK,CAAC,EACrCH,EAAO,GAAGA,CAAI,IAAII,CAAC,EACvB,MAEIxB,EAAW,CAAC,CAACoB,EAAMf,EAAIV,EAAIW,CAAI,CAAC,CAAC,EAAG,CAChC,UAAW,EACf,CAAC,EAEL,IAAME,EAAa,IAAM,CACrB,IAAMkB,EAAcxB,EAAQkB,CAAI,EAChC,GAAIM,GAAe,KAAM,CACrB,IAAM5B,EAAQO,EAAIV,EAAI,OAAO+B,CAAW,EACpC5B,IAAUL,IACVO,EAAW,CAAC,CAACoB,EAAMtB,CAAK,CAAC,CAAC,CAElC,CACJ,EACAH,EAAG,iBAAiB,QAASa,CAAU,EACvCb,EAAG,iBAAiB,SAAUa,CAAU,EACxC,IAAMmB,EAAU5B,EAAO,IAAM,CACzBQ,EAAIL,EAAQkB,CAAI,CAAC,CACrB,CAAC,EACD,MAAO,IAAM,CACTO,EAAQ,EACRhC,EAAG,oBAAoB,QAASa,CAAU,EAC1Cb,EAAG,oBAAoB,SAAUa,CAAU,CAC/C,CACJ,CACJ,ECvLO,IAAMoB,GAAQ,CACjB,KAAM,YACN,KAAM,QACN,OAAQ,OACR,aAAc,GACd,OAAQ,CAAC,CAAE,IAAAC,EAAK,GAAAC,EAAI,OAAAC,EAAQ,KAAAC,EAAM,GAAAC,CAAG,IAAM,CACnCJ,IACAA,EAAMK,EAAaC,EAAMN,CAAG,EAAGG,CAAI,GAEvC,IAAMI,EAAW,IAAM,CACnBC,EAAS,WAAW,EACpB,IAAMC,EAAUT,EACV,CAAE,CAACA,CAAG,EAAGI,EAAG,CAAE,EACdA,EAAG,EACT,QAAWM,KAAKD,EAAS,CACrB,IAAME,EAAaD,EAAE,MAAM,KAAK,EAAE,OAAQE,GAAOA,EAAG,OAAS,CAAC,EAC9D,GAAIH,EAAQC,CAAC,EACT,QAAWG,KAAQF,EACVV,EAAG,UAAU,SAASY,CAAI,GAC3BZ,EAAG,UAAU,IAAIY,CAAI,MAK7B,SAAWA,KAAQF,EACXV,EAAG,UAAU,SAASY,CAAI,GAC1BZ,EAAG,UAAU,OAAOY,CAAI,CAIxC,CACAL,EAAS,QAAQP,EAAI,CAAE,gBAAiB,CAAC,OAAO,CAAE,CAAC,CACvD,EACMO,EAAW,IAAI,iBAAiBD,CAAQ,EACxCO,EAAUZ,EAAOK,CAAQ,EAC/B,MAAO,IAAM,CACTC,EAAS,WAAW,EACpBM,EAAQ,EACR,IAAML,EAAUT,EACV,CAAE,CAACA,CAAG,EAAGI,EAAG,CAAE,EACdA,EAAG,EACT,QAAWM,KAAKD,EAAS,CACrB,IAAME,EAAaD,EAAE,MAAM,KAAK,EAAE,OAAQE,GAAOA,EAAG,OAAS,CAAC,EAC9D,QAAWC,KAAQF,EACfV,EAAG,UAAU,OAAOY,CAAI,CAEhC,CACJ,CACJ,CACJ,ECjDO,IAAME,GAAW,CACpB,KAAM,YACN,KAAM,WACN,OAAQ,OACR,OAAQ,OACR,aAAc,GACd,OAAQ,CAAC,CAAE,IAAAC,EAAK,KAAAC,EAAM,GAAAC,EAAI,SAAAC,EAAU,WAAAC,CAAW,IAAM,CACjDA,EAAW,CAAC,CAACC,EAAaL,EAAKC,CAAI,EAAGE,EAASD,CAAE,CAAC,CAAC,CAAC,CACxD,CACJ,ECVO,IAAMI,GAAS,CAClB,KAAM,YACN,KAAM,SACN,OAAQ,SACR,OAAQ,OACR,OAAQ,CAAC,CAAE,OAAAC,EAAQ,GAAAC,CAAG,IAAMD,EAAOC,CAAE,CACzC,ECRO,IAAMC,EAAuB,GAAGC,CAAQ,SAClCC,GAAU,UACVC,GAAW,WACXC,GAAQ,QACRC,GAAW,WACXC,GAAiB,iBACvB,SAASC,GAAwBC,EAAWC,EAAI,CACnD,SAAS,iBAAiBT,EAAuBU,GAAU,CACvD,GAAIA,EAAM,OAAO,OAASF,EAAW,CACjC,GAAM,CAAE,QAAAG,CAAQ,EAAID,EAAM,OAC1BD,EAAGE,CAAO,CACd,CACJ,CAAC,CACL,CCTO,IAAMC,GAAY,CACrB,KAAM,YACN,KAAM,YACN,OAAQ,YACR,OAAQ,YACR,eAAgB,GAChB,OAAQ,CAAC,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,WAAAC,EAAY,MAAAC,CAAM,IAAM,CAC9C,IAAMC,EAAaJ,EAAMK,EAAaL,EAAKC,CAAI,EAAIE,EACnDD,EAAW,CAAC,CAACE,EAAY,EAAK,CAAC,EAAG,CAAE,UAAW,EAAK,CAAC,EACrD,IAAME,GAAYC,GAAU,CACxB,GAAM,CAAE,KAAAC,EAAM,GAAIC,CAAI,EAAIF,EAAM,OAChC,GAAIE,IAAQV,EAGZ,OAAQS,EAAM,CACV,KAAKE,GACDR,EAAW,CAAC,CAACE,EAAY,EAAI,CAAC,CAAC,EAC/B,MACJ,KAAKO,GACDT,EAAW,CAAC,CAACE,EAAY,EAAK,CAAC,CAAC,EAChC,KACR,CACJ,GACA,gBAAS,iBAAiBQ,EAAsBN,CAAO,EAChD,IAAM,CACTJ,EAAW,CAAC,CAACE,EAAY,EAAK,CAAC,CAAC,EAChC,SAAS,oBAAoBQ,EAAsBN,CAAO,CAC9D,CACJ,CACJ,EC9BO,IAAMO,GAAc,CACvB,KAAM,YACN,KAAM,cACN,OAAQ,SACR,OAAQ,CAAC,CAAE,GAAAC,EAAI,OAAAC,EAAQ,MAAAC,EAAO,SAAAC,EAAU,KAAAC,CAAK,IAAM,CAC/C,IAAMC,EAASD,EAAK,IAAI,OAAO,EAAI,EAAI,EACnCE,EAAU,CAAC,EACXJ,IACAI,EAAUC,GAAcL,CAAK,GAEjC,IAAMM,EAAW,IAAM,CACnBC,EAAS,WAAW,EACpBT,EAAG,YAAc,KAAK,UAAUG,EAASG,CAAO,EAAG,KAAMD,CAAM,EAC/DI,EAAS,QAAQT,EAAI,CACjB,UAAW,GACX,cAAe,GACf,QAAS,EACb,CAAC,CACL,EACMS,EAAW,IAAI,iBAAiBD,CAAQ,EACxCE,EAAUT,EAAOO,CAAQ,EAC/B,MAAO,IAAM,CACTC,EAAS,WAAW,EACpBC,EAAQ,CACZ,CACJ,CACJ,EC9BO,SAASC,EAAQC,EAAM,CAC1B,GAAI,CAACA,GAAQA,EAAK,MAAQ,EACtB,MAAO,GACX,QAAWC,KAAOD,EAAM,CACpB,GAAIC,EAAI,SAAS,IAAI,EACjB,MAAO,CAACA,EAAI,QAAQ,KAAM,EAAE,EAEhC,GAAIA,EAAI,SAAS,GAAG,EAChB,MAAO,CAACA,EAAI,QAAQ,IAAK,EAAE,EAAI,IAEnC,GAAI,CACA,OAAO,OAAO,WAAWA,CAAG,CAChC,MACU,CAAE,CAChB,CACA,MAAO,EACX,CACO,SAASC,GAAOC,EAAMC,EAAKC,EAAe,GAAO,CACpD,OAAKF,EAEEA,EAAK,IAAIC,EAAI,YAAY,CAAC,EADtBC,CAEf,CCpBO,SAASC,GAAMC,EAAUC,EAAM,CAClC,MAAO,IAAIC,IAAS,CAChB,WAAW,IAAM,CACbF,EAAS,GAAGE,CAAI,CACpB,EAAGD,CAAI,CACX,CACJ,CACO,SAASE,GAASH,EAAUC,EAAMG,EAAU,GAAOC,EAAW,GAAM,CACvE,IAAIC,EAAQ,EACZ,MAAO,IAAIJ,IAAS,CAChBI,GAAS,aAAaA,CAAK,EACvBF,GAAW,CAACE,GACZN,EAAS,GAAGE,CAAI,EAEpBI,EAAQ,WAAW,IAAM,CACjBD,GACAL,EAAS,GAAGE,CAAI,EAEpBI,GAAS,aAAaA,CAAK,CAC/B,EAAGL,CAAI,CACX,CACJ,CACO,SAASM,GAASP,EAAUC,EAAMG,EAAU,GAAMC,EAAW,GAAO,CACvE,IAAIG,EAAU,GACd,MAAO,IAAIN,IAAS,CACZM,IAEAJ,GACAJ,EAAS,GAAGE,CAAI,EAEpBM,EAAU,GACV,WAAW,IAAM,CACbA,EAAU,GACNH,GACAL,EAAS,GAAGE,CAAI,CAExB,EAAGD,CAAI,EACX,CACJ,CACO,SAASQ,GAAaT,EAAUU,EAAM,CACzC,IAAMC,EAAYD,EAAK,IAAI,OAAO,EAClC,GAAIC,EAAW,CACX,IAAMV,EAAOW,EAAQD,CAAS,EAC9BX,EAAWD,GAAMC,EAAUC,CAAI,CACnC,CACA,IAAMY,EAAeH,EAAK,IAAI,UAAU,EACxC,GAAIG,EAAc,CACd,IAAMZ,EAAOW,EAAQC,CAAY,EAC3BT,EAAUU,GAAOD,EAAc,UAAW,EAAK,EAC/CR,EAAW,CAACS,GAAOD,EAAc,UAAW,EAAK,EACvDb,EAAWG,GAASH,EAAUC,EAAMG,EAASC,CAAQ,CACzD,CACA,IAAMU,EAAeL,EAAK,IAAI,UAAU,EACxC,GAAIK,EAAc,CACd,IAAMd,EAAOW,EAAQG,CAAY,EAC3BX,EAAU,CAACU,GAAOC,EAAc,YAAa,EAAK,EAClDV,EAAWS,GAAOC,EAAc,QAAS,EAAK,EACpDf,EAAWO,GAASP,EAAUC,EAAMG,EAASC,CAAQ,CACzD,CACA,OAAOL,CACX,CC7DO,IAAMgB,GAA0B,CAAC,CAAC,SAAS,oBAC3C,SAASC,EAAqBC,EAAUC,EAAM,CACjD,GAAIA,EAAK,IAAI,gBAAgB,GAAKH,GAAyB,CACvD,IAAMI,EAAKF,EACXA,EAAW,IAAIG,IAAS,SAAS,oBAAoB,IAAMD,EAAG,GAAGC,CAAI,CAAC,CAC1E,CACA,OAAOH,CACX,CCCO,IAAMI,GAAK,CACd,KAAM,YACN,KAAM,KACN,OAAQ,OACR,OAAQ,OACR,SAAU,CAAC,KAAK,EAChB,OAASC,GAAQ,CACb,GAAM,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,GAAAC,EAAI,WAAAC,EAAY,SAAAC,CAAS,EAAIN,EAChDO,EAASN,EACTE,EAAK,IAAI,QAAQ,IACjBI,EAAS,QACb,IAAIC,EAAYC,GAAQ,CAChBA,IACIN,EAAK,IAAI,SAAS,GAClBM,EAAI,eAAe,EAEnBN,EAAK,IAAI,MAAM,GACfM,EAAI,gBAAgB,EAExBT,EAAI,IAAMS,GAEdJ,EAAW,EACXD,EAAGK,CAAG,EACNH,EAAS,CACb,EACAE,EAAWE,GAAaF,EAAUL,CAAI,EACtCK,EAAWG,EAAqBH,EAAUL,CAAI,EAC9C,IAAMS,EAAc,CAChB,QAAST,EAAK,IAAI,SAAS,EAC3B,QAASA,EAAK,IAAI,SAAS,EAC3B,KAAMA,EAAK,IAAI,MAAM,CACzB,EACA,GAAIA,EAAK,IAAI,SAAS,EAAG,CACrBI,EAAS,SACT,IAAMM,EAAKL,EACXA,EAAYC,GAAQ,CACXR,EAAG,SAASQ,GAAK,MAAM,GACxBI,EAAGJ,CAAG,CAEd,CACJ,CAEA,IAAIK,EAAYC,EAAMb,CAAG,EAQzB,GAPAY,EAAYE,EAAaF,EAAWX,CAAI,GAEpCW,IAAcG,GACdH,IAAcI,KACdX,EAAS,UAGTN,aAAc,iBAAmBa,IAAc,SAAU,CACzD,IAAMD,EAAKL,EACXA,EAAYC,GAAQ,CAChBA,GAAK,eAAe,EACpBI,EAAGJ,CAAG,CACV,CACJ,CACA,OAAAF,EAAO,iBAAiBO,EAAWN,EAAUI,CAAW,EACjD,IAAM,CACTL,EAAO,oBAAoBO,EAAWN,CAAQ,CAClD,CACJ,CACJ,ECjEA,IAAMW,GAAO,IAAI,QACJC,GAAc,CACvB,KAAM,YACN,KAAM,cACN,OAAQ,SACR,OAAQ,CAAC,CAAE,GAAAC,EAAI,KAAAC,EAAM,GAAAC,EAAI,WAAAC,EAAY,SAAAC,CAAS,IAAM,CAChD,IAAIC,EAAW,IAAM,CACjBF,EAAW,EACXD,EAAG,EACHE,EAAS,CACb,EACAC,EAAWC,GAAaD,EAAUJ,CAAI,EACtCI,EAAWE,EAAqBF,EAAUJ,CAAI,EAC9C,IAAMO,EAAU,CAAE,UAAW,CAAE,EAC3BP,EAAK,IAAI,MAAM,EACfO,EAAQ,UAAY,EAEfP,EAAK,IAAI,MAAM,IACpBO,EAAQ,UAAY,IAExB,IAAIC,EAAW,IAAI,qBAAsBC,GAAY,CACjD,QAAWC,KAASD,EACZC,EAAM,iBACNN,EAAS,EACLI,GAAYX,GAAK,IAAIE,CAAE,GACvBS,EAAS,WAAW,EAIpC,EAAGD,CAAO,EACV,OAAAC,EAAS,QAAQT,CAAE,EACfC,EAAK,IAAI,MAAM,GACfH,GAAK,IAAIE,CAAE,EAER,IAAM,CACJC,EAAK,IAAI,MAAM,GAChBH,GAAK,OAAOE,CAAE,EAEdS,IACAA,EAAS,WAAW,EACpBA,EAAW,KAEnB,CACJ,CACJ,EC5CO,IAAMG,GAAa,CACtB,KAAM,YACN,KAAM,aACN,OAAQ,SACR,OAAQ,OACR,OAAQ,CAAC,CAAE,KAAAC,EAAM,GAAAC,EAAI,WAAAC,EAAY,SAAAC,CAAS,IAAM,CAC5C,IAAIC,EAAW,IAAM,CACjBF,EAAW,EACXD,EAAG,EACHE,EAAS,CACb,EACAC,EAAWC,EAAqBD,EAAUJ,CAAI,EAC9C,IAAIM,EAAW,IACTC,EAAeP,EAAK,IAAI,UAAU,EACpCO,IACAD,EAAWE,EAAQD,CAAY,EACfE,GAAOF,EAAc,UAAW,EAAK,GAEjDH,EAAS,GAGjB,IAAMM,EAAa,YAAYN,EAAUE,CAAQ,EACjD,MAAO,IAAM,CACT,cAAcI,CAAU,CAC5B,CACJ,CACJ,ECzBO,IAAMC,GAAS,CAClB,KAAM,YACN,KAAM,SACN,OAAQ,SACR,OAAQ,OACR,OAAQ,CAAC,CAAE,GAAAC,EAAI,KAAAC,EAAM,WAAAC,EAAY,SAAAC,CAAS,IAAM,CAC5C,IAAIC,EAAW,IAAM,CACjBF,EAAW,EACXF,EAAG,EACHG,EAAS,CACb,EACAC,EAAWC,EAAqBD,EAAUH,CAAI,EAC9C,IAAIK,EAAO,EACLC,EAAYN,EAAK,IAAI,OAAO,EAC9BM,IACAD,EAAOE,EAAQD,CAAS,EACpBD,EAAO,IACPF,EAAWK,GAAML,EAAUE,CAAI,IAGvCF,EAAS,CACb,CACJ,ECrBO,IAAMM,GAAgB,CACzB,KAAM,YACN,KAAM,gBACN,OAAQ,OACR,SAAU,CAAC,OAAO,EAClB,aAAc,GACd,OAAQ,CAAC,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,OAAAC,EAAQ,GAAAC,EAAI,SAAAC,EAAU,WAAAC,EAAY,WAAAC,EAAY,SAAAC,CAAU,IAAM,CAEpF,GAAMP,GAAOA,IAAQ,SACjB,MAAMK,EAAW,GAAGH,EAAO,IAAI,eAAe,EAGlD,IAAMM,EAAaT,EAAG,aAAa,6BAA6B,EAC5DU,EAAU,CAAC,EACXD,IACAC,EAAUC,GAAcF,CAAU,GAEtC,IAAMG,EAAWC,GAAcC,GAAQ,CACnC,IAAMC,EAAUV,EAASK,EAASI,EAAI,MAAM,EACvCE,GAAQD,CAAO,IAChBR,EAAW,EACXH,EAAGW,CAAO,EACVP,EAAS,EAEjB,EAAGN,CAAI,EACP,gBAAS,iBAAiBe,EAA6BL,CAAQ,EACxD,IAAM,CACT,SAAS,oBAAoBK,EAA6BL,CAAQ,CACtE,CACJ,CACJ,EChCO,IAAMM,GAAM,CACf,KAAM,YACN,KAAM,MACN,OAAQ,YACR,OAAQ,YACR,eAAgB,GAChB,OAAQ,CAAC,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,MAAAC,EAAO,WAAAC,CAAW,IAAM,CAC9C,IAAMC,EAAaJ,EAAMK,EAAaL,EAAKC,CAAI,EAAIC,EACnDC,EAAW,CAAC,CAACC,EAAYL,CAAE,CAAC,CAAC,CACjC,CACJ,ECZA,IAAMO,GAAO,OACPC,GAAU,UACHC,GAAO,CAChB,KAAM,YACN,KAAM,OACN,OAAQ,SACR,OAAQ,OACR,aAAc,GACd,OAAQ,CAAC,CAAE,GAAAC,EAAI,OAAAC,EAAQ,GAAAC,CAAG,IAAM,CAC5B,IAAMC,EAAS,IAAM,CACjBC,EAAS,WAAW,EACDF,EAAG,EAEdF,EAAG,MAAM,UAAYH,IACrBG,EAAG,MAAM,eAAeF,EAAO,EAGnCE,EAAG,MAAM,YAAYF,GAASD,EAAI,EAEtCO,EAAS,QAAQJ,EAAI,CAAE,gBAAiB,CAAC,OAAO,CAAE,CAAC,CACvD,EACMI,EAAW,IAAI,iBAAiBD,CAAM,EACtCE,EAAUJ,EAAOE,CAAM,EAC7B,MAAO,IAAM,CACTC,EAAS,WAAW,EACpBC,EAAQ,CACZ,CACJ,CACJ,EC3BO,IAAMC,GAAU,CACnB,KAAM,YACN,KAAM,UACN,aAAc,GACd,OAAQ,CAAC,CAAE,IAAAC,EAAK,KAAAC,EAAM,GAAAC,EAAI,WAAAC,EAAY,WAAAC,CAAW,IAAM,CACnD,IAAMC,EAAYJ,EAAK,IAAI,WAAW,EACtC,GAAID,EACAA,EAAMM,EAAaN,EAAKC,CAAI,EAC5BG,EAAW,CAAC,CAACJ,EAAKE,EAAG,CAAC,CAAC,EAAG,CAAE,UAAAG,CAAU,CAAC,MAEtC,CACD,IAAME,EAAQ,OAAO,OAAO,CAAC,EAAGL,EAAG,CAAC,EACpCC,EAAWI,EAAO,CAAE,UAAAF,CAAU,CAAC,CACnC,CACJ,CACJ,ECfO,IAAMG,GAAQ,CACjB,KAAM,YACN,KAAM,QACN,OAAQ,OACR,aAAc,GACd,OAAQ,CAAC,CAAE,IAAAC,EAAK,GAAAC,EAAI,OAAAC,EAAQ,GAAAC,CAAG,IAAM,CACjC,GAAM,CAAE,MAAAC,CAAM,EAAIH,EACZI,EAAgB,IAAI,IAC1BL,IAAQM,EAAMN,CAAG,EACjB,IAAMO,EAAQ,CAACC,EAAMC,IAAU,CAC3B,IAAMC,EAAUL,EAAc,IAAIG,CAAI,EAClC,CAACC,GAASA,IAAU,EACpBC,IAAY,SACPA,EACKN,EAAM,YAAYI,EAAME,CAAO,EAC/BN,EAAM,eAAeI,CAAI,IAGnCE,IAAY,QACRL,EAAc,IAAIG,EAAMJ,EAAM,iBAAiBI,CAAI,CAAC,EACxDJ,EAAM,YAAYI,EAAM,OAAOC,CAAK,CAAC,EAE7C,EACME,EAAS,IAAM,CAEjB,GADAC,EAAS,WAAW,EAChBZ,EACAO,EAAMP,EAAKG,EAAG,CAAC,MAEd,CACD,IAAMU,EAASV,EAAG,EAClB,OAAW,CAACK,EAAME,CAAO,IAAKL,EAC1BG,KAAQK,IACHH,EACKN,EAAM,YAAYI,EAAME,CAAO,EAC/BN,EAAM,eAAeI,CAAI,GAEvC,QAAWA,KAAQK,EACfN,EAAMD,EAAME,CAAI,EAAGK,EAAOL,CAAI,CAAC,CAEvC,CACAI,EAAS,QAAQX,EAAI,CAAE,gBAAiB,CAAC,OAAO,CAAE,CAAC,CACvD,EACMW,EAAW,IAAI,iBAAiBD,CAAM,EACtCG,EAAUZ,EAAOS,CAAM,EAC7B,MAAO,IAAM,CACTC,EAAS,WAAW,EACpBE,EAAQ,EACR,OAAW,CAACN,EAAME,CAAO,IAAKL,EAC1BK,EAAUN,EAAM,YAAYI,EAAME,CAAO,EAAIN,EAAM,eAAeI,CAAI,CAE9E,CACJ,CACJ,ECrDO,IAAMO,GAAO,CAChB,KAAM,YACN,KAAM,OACN,OAAQ,SACR,OAAQ,OACR,aAAc,GACd,OAAQ,CAAC,CAAE,GAAAC,EAAI,OAAAC,EAAQ,GAAAC,CAAG,IAAM,CAC5B,IAAMC,EAAS,IAAM,CACjBC,EAAS,WAAW,EACpBJ,EAAG,YAAc,GAAGE,EAAG,CAAC,GACxBE,EAAS,QAAQJ,EAAI,CACjB,UAAW,GACX,cAAe,GACf,QAAS,EACb,CAAC,CACL,EACMI,EAAW,IAAI,iBAAiBD,CAAM,EACtCE,EAAUJ,EAAOE,CAAM,EAC7B,MAAO,IAAM,CACTC,EAAS,WAAW,EACpBC,EAAQ,CACZ,CACJ,CACJ,ECtBA,IAAMC,GAAwB,IAAI,QAErBC,EAAmB,CAACC,EAAMC,KAAY,CAC/C,KAAM,SACN,KAAAD,EACA,GAAI,MAAOE,EAAKC,EAAKC,IAAS,CAC1B,GAAM,CAAE,GAAAC,CAAG,EAAIH,EACTI,EAAsBF,GAAM,qBAAuB,OACnDG,EAAaD,aAA+B,gBAC5CA,EACA,IAAI,gBACJE,EAAaF,IAAwB,WACtCE,GACDV,GAAsB,IAAIO,CAAE,GAAG,MAAM,EAErC,CAACG,GAAc,EAAEF,aAA+B,kBAChDR,GAAsB,IAAIO,EAAIE,CAAU,EAE5C,GAAI,CACA,MAAME,GAAQP,EAAKD,EAAQE,EAAKC,EAAMG,EAAW,MAAM,CAC3D,QACA,CACQT,GAAsB,IAAIO,CAAE,IAAME,GAClCT,GAAsB,OAAOO,CAAE,CAEvC,CACJ,CACJ,GACMK,EAAgB,CAACC,EAAMN,EAAIO,IAAY,SAAS,cAAc,IAAI,YAAYC,EAAsB,CACtG,OAAQ,CAAE,KAAAF,EAAM,GAAAN,EAAI,QAAAO,CAAQ,CAChC,CAAC,CAAC,EACIE,GAAkBC,GAAQ,GAAGA,CAAG,GAAG,SAAS,mBAAmB,EAC/DN,GAAU,MAAO,CAAE,GAAAJ,EAAI,IAAAW,EAAK,SAAAC,EAAU,WAAAC,CAAW,EAAGjB,EAAQE,EAAK,CAAE,SAAAgB,EAAU,QAASC,EAAa,YAAAC,EAAc,OAAQ,cAAe,CAAE,QAAAC,EAAU,KAAM,QAAAC,EAAU,SAAU,EAAI,CAAC,EAAG,eAAAC,EAAiB,GAAO,cAAAC,EAAgBC,GAA2B,YAAAC,EAAc,EAAG,eAAAC,EAAiB,IAAQ,cAAAC,EAAgB,EAAI,EAAI,CAAC,EAAGC,IAAU,CAC3U,IAAMC,EAAS9B,EAAO,YAAY,EAC9B+B,EAAY,IAAM,CAAE,EACxB,GAAI,CACA,GAAI,CAAC7B,GAAK,OACN,MAAMe,EAAW,qBAAsB,CAAE,OAAAa,CAAO,CAAC,EAErD,IAAME,EAAiB,CACnB,OAAQ,iDACR,CAACC,EAAgB,EAAG,EACxB,EACIb,IAAgB,SAChBY,EAAe,cAAc,EAAI,oBAErC,IAAME,EAAU,OAAO,OAAO,CAAC,EAAGF,EAAgBb,CAAW,EAGvDgB,EAAM,CACR,OAAAnC,EACA,QAAAkC,EACA,eAAAX,EACA,cAAAC,EACA,YAAAE,EACA,eAAAC,EACA,cAAAC,EACA,OAAQC,EACR,OAAQ,MAAOO,GAAa,CACpBA,EAAS,QAAU,KACnB3B,EAAc4B,GAAOjC,EAAI,CAAE,OAAQgC,EAAS,OAAO,SAAS,CAAE,CAAC,CACvE,EACA,UAAYrB,GAAQ,CAChB,GAAI,CAACA,EAAI,MAAM,WAAWuB,CAAQ,EAC9B,OACJ,IAAM5B,EAAOK,EAAI,MACXwB,EAAe,CAAC,EACtB,QAAWC,KAAQzB,EAAI,KAAK,MAAM;AAAA,CAAI,EAAG,CACrC,IAAM0B,EAAID,EAAK,QAAQ,GAAG,EACpBE,EAAIF,EAAK,MAAM,EAAGC,CAAC,EACnBE,EAAIH,EAAK,MAAMC,EAAI,CAAC,GACzBF,EAAaG,CAAC,IAAM,CAAC,GAAG,KAAKC,CAAC,CACnC,CACA,IAAMhC,EAAU,OAAO,YAAY,OAAO,QAAQ4B,CAAY,EAAE,IAAI,CAAC,CAACG,EAAGC,CAAC,IAAM,CAACD,EAAGC,EAAE,KAAK;AAAA,CAAI,CAAC,CAAC,CAAC,EAClGlC,EAAcC,EAAMN,EAAIO,CAAO,CACnC,EACA,QAAUiC,GAAU,CAChB,GAAI/B,GAAe+B,CAAK,EAEpB,MAAM3B,EAAW,qBAAsB,CAAE,IAAAf,CAAI,CAAC,EAG9C0C,IACA,QAAQ,MAAMA,EAAM,OAAO,EAC3BnC,EAAcoC,GAAUzC,EAAI,CAAE,QAASwC,EAAM,OAAQ,CAAC,EAE9D,CACJ,EACME,EAAc,IAAI,IAAI5C,EAAK,OAAO,SAAS,IAAI,EAC/C6C,EAAc,IAAI,gBAAgBD,EAAY,MAAM,EAC1D,GAAI1B,IAAgB,OAAQ,CACxB,IAAM4B,EAAM,KAAK,UAAUhC,EAAS,CAAE,QAAAK,EAAS,QAAAC,CAAQ,CAAC,CAAC,EACrDtB,IAAW,MACX+C,EAAY,IAAIT,EAAUU,CAAG,EAG7Bb,EAAI,KAAOa,CAEnB,SACS5B,IAAgB,OAAQ,CAC7B,IAAM6B,EAAU/B,EAAW,SAAS,cAAcA,CAAQ,EAAId,EAAG,QAAQ,MAAM,EAC/E,GAAI,CAAC6C,EACD,MAAMhC,EAAWC,EAAW,oBAAsB,2BAA4B,CAAE,OAAAY,EAAQ,SAAAZ,CAAS,CAAC,EAGtG,GAAI,CAAC+B,EAAO,cAAc,EAAG,CACzBA,EAAO,eAAe,EACtBlB,EAAU,EACV,MACJ,CAEA,IAAMmB,EAAW,IAAI,SAASD,CAAM,EAChCE,EAAY/C,EAChB,GAAIA,IAAO6C,GAAUlC,aAAe,YAEhCoC,EAAYpC,EAAI,cAEf,CAED,IAAMqC,EAAkBrC,GAAQA,EAAI,eAAe,EACnDkC,EAAO,iBAAiB,SAAUG,CAAc,EAChDrB,EAAY,IAAMkB,EAAO,oBAAoB,SAAUG,CAAc,CACzE,CAEA,GAAID,aAAqB,kBAAmB,CACxC,IAAMpD,EAAOoD,EAAU,aAAa,MAAM,EACtCpD,GACAmD,EAAS,OAAOnD,EAAMoD,EAAU,KAAK,CAC7C,CACA,IAAME,EAAYJ,EAAO,aAAa,SAAS,IAAM,sBAEhDI,IACDnB,EAAQ,cAAc,EAAI,qCAE9B,IAAMoB,EAAa,IAAI,gBAAgBJ,CAAQ,EAC/C,GAAIlD,IAAW,MACX,OAAW,CAACuD,EAAKC,CAAK,IAAKF,EACvBP,EAAY,OAAOQ,EAAKC,CAAK,UAG5BH,EAEL,GAAI,yBAA2BP,EAAY,WAAa,SAAU,CAC9D,IAAMW,EAAW,uBAAuB,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,EAAG,EAAE,CAAC,GAC7EC,EAAU,IAAI,YAEhBC,EAAQ,EACNC,EAAQ,CAAC,EACf,OAAW,CAAC7D,EAAMyD,CAAK,IAAKN,EACxBU,EAAM,KAAK,CAAE,MAAO7D,EAAM,MAAAyD,CAAM,CAAC,EACjCG,GAASD,EAAQ,OAAO,KAAKD,CAAQ;AAAA,CAAM,EAAE,WACzCD,aAAiB,MACjBG,GAASD,EAAQ,OAAO,yCAAyC3D,CAAI,gBAAgByD,EAAM,IAAI;AAAA,gBAC1EA,EAAM,MAAQ,0BAA0B;AAAA;AAAA,CAAU,EAAE,WACzEG,GAASH,EAAM,KAAO,GAGtBG,GAASD,EAAQ,OAAO,yCAAyC3D,CAAI;AAAA;AAAA,EAAYyD,CAAK;AAAA,CAAM,EAAE,WAGtGG,GAASD,EAAQ,OAAO,KAAKD,CAAQ;AAAA,CAAQ,EAAE,WAC/C,IAAII,EAAS,EACb1B,EAAI,KAAO,IAAI,eAAe,CAC1B,MAAM,MAAM7B,EAAY,CACpB,IAAMwD,EAASC,GAAS,CACpBzD,EAAW,QAAQyD,CAAI,EACvBF,GAAUE,EAAK,WACf,IAAMC,EAAW,KAAK,MAAOH,EAASF,EAAS,GAAG,EAClDlD,EAAc,kBAAmBL,EAAI,CACjC,SAAU4D,EAAS,SAAS,EAC5B,OAAQH,EAAO,SAAS,EACxB,MAAOF,EAAM,SAAS,CAC1B,CAAC,CACL,EACAlD,EAAc,kBAAmBL,EAAI,CACjC,SAAU,IACV,OAAQ,IACR,MAAOuD,EAAM,SAAS,CAC1B,CAAC,EACD,GAAI,CACA,OAAW,CAAE,MAAAM,EAAO,MAAAT,CAAM,IAAKI,EAE3B,GADAE,EAAMJ,EAAQ,OAAO,KAAKD,CAAQ;AAAA,CAAM,CAAC,EACrCD,aAAiB,KAAM,CACvBM,EAAMJ,EAAQ,OAAO,yCAAyCO,CAAK,gBAAgBT,EAAM,IAAI;AAAA,gBACxEA,EAAM,MAAQ,0BAA0B;AAAA;AAAA,CAAU,CAAC,EACxE,IAAMU,GAASV,EAAM,OAAO,EAAE,UAAU,EACxC,GAAI,CACA,OAAa,CACT,GAAM,CAAE,KAAAW,GAAM,MAAOC,EAAM,EAAI,MAAMF,GAAO,KAAK,EACjD,GAAIC,GACA,MACJL,EAAMM,EAAK,CACf,CACJ,QACA,CACIF,GAAO,YAAY,CACvB,CACAJ,EAAMJ,EAAQ,OAAO;AAAA,CAAM,CAAC,CAChC,MAEII,EAAMJ,EAAQ,OAAO,yCAAyCO,CAAK;AAAA;AAAA,EAAYT,CAAK;AAAA,CAAM,CAAC,EAGnGM,EAAMJ,EAAQ,OAAO,KAAKD,CAAQ;AAAA,CAAQ,CAAC,EACvCI,EAASF,GACTlD,EAAc,kBAAmBL,EAAI,CACjC,SAAU,MACV,OAAQuD,EAAM,SAAS,EACvB,MAAOA,EAAM,SAAS,CAC1B,CAAC,EAELrD,EAAW,MAAM,CACrB,OACOsC,EAAO,CACVtC,EAAW,MAAMsC,CAAK,CAC1B,CACJ,CACJ,CAAC,EAEDV,EAAQ,cAAc,EAAI,iCAAiCuB,CAAQ,GACnEtB,EAAI,OAAS,MACjB,MAEIA,EAAI,KAAOe,OAIff,EAAI,KAAOmB,CAEnB,KAEI,OAAMrC,EAAW,0BAA2B,CAAE,OAAAa,EAAQ,YAAAV,CAAY,CAAC,EAEvEX,EAAc4D,GAASjE,EAAI,CAAC,CAAC,EAC7B0C,EAAY,OAASC,EAAY,SAAS,EAC1C,GAAI,CACA,MAAMuB,GAAiBxB,EAAY,SAAS,EAAG1C,EAAI+B,CAAG,CAC1D,OACOS,EAAO,CACV,GAAI,CAAC/B,GAAe+B,CAAK,EACrB,MAAM3B,EAAW,cAAe,CAAE,OAAAjB,EAAQ,IAAAE,EAAK,MAAA0C,CAAM,CAAC,CAM9D,CACJ,QACA,CACInC,EAAc8D,GAAUnE,EAAI,CAAC,CAAC,EAC9B2B,EAAU,CACd,CACJ,EAOA,eAAeyC,GAASC,EAAQC,EAAS,CACrC,IAAMR,EAASO,EAAO,UAAU,EAC5BE,EAAS,MAAMT,EAAO,KAAK,EAC/B,KAAO,CAACS,EAAO,MACXD,EAAQC,EAAO,KAAK,EACpBA,EAAS,MAAMT,EAAO,KAAK,CAEnC,CACA,SAASU,GAASC,EAAQ,CACtB,IAAIC,EACAC,EACAC,EACAC,EAAyB,GAE7B,OAAO,SAAiBC,EAAK,CACpBJ,EAODA,EAASK,GAAOL,EAAQI,CAAG,GAN3BJ,EAASI,EACTH,EAAW,EACXC,EAAc,IAMlB,IAAMI,EAAYN,EAAO,OACrBO,EAAY,EAChB,KAAON,EAAWK,GAAW,CACrBH,IACIH,EAAOC,CAAQ,IAAM,KACrBM,EAAY,EAAEN,GAClBE,EAAyB,IAG7B,IAAIK,EAAU,GACd,KAAOP,EAAWK,GAAaE,IAAY,GAAI,EAAEP,EAC7C,OAAQD,EAAOC,CAAQ,EAAG,CACtB,IAAK,IACGC,IAAgB,KAEhBA,EAAcD,EAAWM,GAE7B,MAGJ,IAAK,IACDJ,EAAyB,GAC7B,IAAK,IACDK,EAAUP,EACV,KACR,CAEJ,GAAIO,IAAY,GACZ,MAEJT,EAAOC,EAAO,SAASO,EAAWC,CAAO,EAAGN,CAAW,EACvDK,EAAYN,EACZC,EAAc,EAClB,CACIK,IAAcD,EACdN,EAAS,OACJO,IAGLP,EAASA,EAAO,SAASO,CAAS,EAClCN,GAAYM,EAEpB,CACJ,CACA,SAASE,GAAYC,EAAMC,EAASC,EAAW,CAC3C,IAAIC,EAAUC,GAAW,EACnBC,EAAU,IAAI,YAEpB,OAAO,SAAgBrD,EAAMwC,EAAa,CACtC,GAAI,CAACxC,EAAK,OAENkD,IAAYC,CAAO,EACnBA,EAAUC,GAAW,UAEhBZ,EAAc,EAAG,CAItB,IAAMf,EAAQ4B,EAAQ,OAAOrD,EAAK,SAAS,EAAGwC,CAAW,CAAC,EACpDc,EAAcd,GAAexC,EAAKwC,EAAc,CAAC,IAAM,GAAK,EAAI,GAChExB,EAAQqC,EAAQ,OAAOrD,EAAK,SAASsD,CAAW,CAAC,EACvD,OAAQ7B,EAAO,CACX,IAAK,OACD0B,EAAQ,KAAOA,EAAQ,KAAO,GAAGA,EAAQ,IAAI;AAAA,EAAKnC,CAAK,GAAKA,EAC5D,MACJ,IAAK,QACDmC,EAAQ,MAAQnC,EAChB,MACJ,IAAK,KACDgC,EAAMG,EAAQ,GAAKnC,CAAM,EACzB,MACJ,IAAK,QAAS,CACV,IAAMuC,EAAQ,CAACvC,EACV,OAAO,MAAMuC,CAAK,GAEnBN,EAASE,EAAQ,MAAQI,CAAM,EAEnC,KACJ,CACJ,CACJ,CACJ,CACJ,CACA,IAAMZ,GAAS,CAACa,EAAGC,IAAM,CACrB,IAAMjD,EAAM,IAAI,WAAWgD,EAAE,OAASC,EAAE,MAAM,EAC9C,OAAAjD,EAAI,IAAIgD,CAAC,EACThD,EAAI,IAAIiD,EAAGD,EAAE,MAAM,EACZhD,CACX,EACM4C,GAAa,KAAO,CAKtB,KAAM,GACN,MAAO,GACP,GAAI,GACJ,MAAO,MACX,GACA,SAAStB,GAAiB4B,EAAO9F,EAAI,CAAE,OAAQ+F,EAAa,QAASC,EAAc,OAAQC,EAAa,UAAAC,EAAW,QAAAC,EAAS,QAAAC,EAAS,eAAAjF,EAAgB,MAAOkF,EAAY,cAAAjF,EAAgB,IAAO,YAAAE,EAAc,EAAG,eAAAC,EAAiB,IAAQ,cAAAC,EAAgB,GAAI,UAAA8E,EAAW,GAAGC,CAAK,EAAG,CAC/Q,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CAEpC,IAAM3E,EAAU,CACZ,GAAGkE,CACP,EACIU,EACJ,SAASC,GAAqB,CAC1BD,EAAqB,MAAM,EACtB,SAAS,QACVE,EAAO,CACf,CACKzF,GACD,SAAS,iBAAiB,mBAAoBwF,CAAkB,EAEpE,IAAIE,EAAa,EACjB,SAASC,GAAU,CACf,SAAS,oBAAoB,mBAAoBH,CAAkB,EACnE,OAAO,aAAaE,CAAU,EAC9BH,EAAqB,MAAM,CAC/B,CAEAX,GAAa,iBAAiB,QAAS,IAAM,CACzCe,EAAQ,EACRN,EAAQ,CACZ,CAAC,EACD,IAAMO,EAAQV,GAAc,OAAO,MAC7BW,EAASf,IAAgB,IAAM,CAAE,GACnCgB,EAAU,EACVC,EAAoB9F,EACxB,eAAewF,GAAS,CACpBF,EAAuB,IAAI,gBAC3B,GAAI,CACA,IAAM1E,EAAW,MAAM+E,EAAMjB,EAAO,CAChC,GAAGS,EACH,QAAAzE,EACA,OAAQ4E,EAAqB,MACjC,CAAC,EAEDO,EAAU,EACV7F,EAAgB8F,EAChB,MAAMF,EAAOhF,CAAQ,EACrB,IAAMmF,EAAiB,MAAOC,EAAcpF,EAAUrC,EAAM2G,KAAce,IAAa,CACnF,IAAM9G,EAAU,CACZ,CAACZ,CAAI,EAAG,MAAMqC,EAAS,KAAK,CAChC,EACA,QAAWsF,KAAKD,EAAU,CACtB,IAAI9E,GAAIP,EAAS,QAAQ,IAAI,YAAYuF,EAAMD,CAAC,CAAC,EAAE,EACnD,GAAIhB,EAAW,CACX,IAAMkB,GAAIlB,EAAUgB,CAAC,EACjBE,KACAjF,GAAI,OAAOiF,IAAM,SAAWA,GAAI,KAAK,UAAUA,EAAC,EACxD,CACIjF,KACAhC,EAAQ+G,CAAC,EAAI/E,GACrB,CACAlC,EAAc+G,EAAcpH,EAAIO,CAAO,EACvCuG,EAAQ,EACRN,EAAQ,CACZ,EACMiB,EAAKzF,EAAS,QAAQ,IAAI,cAAc,EAC9C,GAAIyF,GAAI,SAAS,WAAW,EACxB,OAAO,MAAMN,EAAeO,GAAwB1F,EAAU,WAAYsE,EAAW,WAAY,OAAQ,mBAAmB,EAEhI,GAAImB,GAAI,SAAS,kBAAkB,EAC/B,OAAO,MAAMN,EAAeQ,GAAuB3F,EAAU,UAAWsE,EAAW,eAAe,EAEtG,GAAImB,GAAI,SAAS,iBAAiB,EAAG,CACjC,IAAMG,EAAS,SAAS,cAAc,QAAQ,EACxCC,EAAyB7F,EAAS,QAAQ,IAAI,4BAA4B,EAChF,GAAI6F,EACA,OAAW,CAAClI,EAAMyD,CAAK,IAAK,OAAO,QAAQ,KAAK,MAAMyE,CAAsB,CAAC,EACzED,EAAO,aAAajI,EAAMyD,CAAK,EAGvCwE,EAAO,YAAc,MAAM5F,EAAS,KAAK,EACzC,SAAS,KAAK,YAAY4F,CAAM,EAChCd,EAAQ,EACR,MACJ,CACA,MAAM1C,GAASpC,EAAS,KAAMwC,GAASW,GAAa2C,GAAO,CACnDA,EAEAhG,EAAQ,eAAe,EAAIgG,EAI3B,OAAOhG,EAAQ,eAAe,CAEtC,EAAI6D,GAAU,CACVuB,EAAoB9F,EAAgBuE,CACxC,EAAGO,CAAS,CAAC,CAAC,EACdC,IAAU,EACVW,EAAQ,EACRN,EAAQ,CACZ,OACO9F,EAAK,CACR,GAAI,CAACgG,EAAqB,OAAO,QAE7B,GAAI,CAEA,IAAMqB,EAAW3B,IAAU1F,CAAG,GAAKU,EACnC,OAAO,aAAayF,CAAU,EAC9BA,EAAa,OAAO,WAAWD,EAAQmB,CAAQ,EAC/C3G,EAAgB,KAAK,IAAIA,EAAgBE,EAAaC,CAAc,EAChE,EAAE0F,GAAWzF,GACbnB,EAAc2H,GAAgBhI,EAAI,CAAC,CAAC,EAEpC8G,EAAQ,EACRL,EAAO,sBAAsB,GAG7B,QAAQ,MAAM,4BAA4BX,EAAM,SAAS,CAAC,gBAAgBiC,CAAQ,KAAK,CAE/F,OACOE,EAAU,CAEbnB,EAAQ,EACRL,EAAOwB,CAAQ,CACnB,CAER,CACJ,CACArB,EAAO,CACX,CAAC,CACL,CC3fO,IAAMsB,GAASC,EAAiB,SAAU,QAAQ,ECAlD,IAAMC,GAAMC,EAAiB,MAAO,KAAK,ECAzC,IAAMC,GAAQC,EAAiB,QAAS,OAAO,ECA/C,IAAMC,GAAOC,EAAiB,OAAQ,MAAM,ECA5C,IAAMC,GAAMC,EAAiB,MAAO,KAAK,ECIzC,IAAMC,GAAgB,CACzB,KAAM,UACN,KAAMC,GACN,MAAM,aAAaC,EAAK,CACpBC,GAAwBF,GAAyBG,GAAS,CAClDC,IACAD,EAAK,mBAAmB,KAAK,IAAM,OACnC,SAAS,oBAAoB,IAAME,GAAgBJ,EAAKE,CAAI,CAAC,EAG7DE,GAAgBJ,EAAKE,CAAI,CAEjC,CAAC,CACL,CACJ,EACA,SAASE,GAAgBJ,EAAK,CAAE,SAAAK,EAAW,GAAI,SAAAC,EAAU,KAAAC,EAAOC,EAAyB,EAAG,CACxF,GAAM,CAAE,QAAAC,CAAQ,EAAIT,EACdU,EAA0BL,EAAS,QAAQ,uCAAwC,EAAE,EACrFM,EAAU,WAAW,KAAKD,CAAuB,EACjDE,EAAU,WAAW,KAAKF,CAAuB,EACjDG,EAAU,WAAW,KAAKH,CAAuB,EACjDI,EAAc,IAAI,UAAU,EAAE,gBAAgBH,GAAWC,GAAWC,EACpER,EACA,mBAAmBA,CAAQ,qBAAsB,WAAW,EAC9DU,EAAa,SAAS,uBAAuB,EAiBjD,GAhBIJ,EACAI,EAAW,YAAYD,EAAY,eAAe,EAE7CF,GAAWC,GAChBE,EAAW,YAAYD,EAAY,IAAI,EACvCC,EAAW,YAAYD,EAAY,IAAI,GAElCF,EACLG,EAAW,YAAYD,EAAY,IAAI,EAElCD,EACLE,EAAW,YAAYD,EAAY,IAAI,EAGvCC,EAAaD,EAAY,cAAc,UAAU,EAAE,QAEnD,CAACR,IACAC,IAASS,IAAyBT,IAASU,IAC5C,QAAWC,KAASH,EAAW,SAAU,CACrC,IAAII,EACJ,GAAID,aAAiB,gBACjBC,EAAS,SAAS,wBAEbD,aAAiB,gBACtBC,EAAS,SAAS,aAEbD,aAAiB,gBACtBC,EAAS,SAAS,aAGlBA,EAAS,SAAS,eAAeD,EAAM,EAAE,EACrC,CAACC,EAAQ,CACT,QAAQ,MAAMV,EAAQ,iBAAkB,CACpC,GAAIS,EAAM,EACd,CAAC,CAAC,EACF,QACJ,CAEJE,GAAepB,EAAKO,EAAMW,EAAO,CAACC,CAAM,CAAC,CAC7C,KAEC,CACD,IAAME,EAAU,SAAS,iBAAiBf,CAAQ,EAClD,GAAI,CAACe,EAAQ,OAAQ,CACjB,QAAQ,MAAMZ,EAAQ,iBAAkB,CACpC,SAAUH,CACd,CAAC,CAAC,EACF,MACJ,CACAc,GAAepB,EAAKO,EAAMQ,EAAYM,CAAO,CACjD,CACJ,CACA,IAAMC,GAAU,IAAI,QACpB,QAAWC,KAAU,SAAS,iBAAiB,QAAQ,EACnDD,GAAQ,IAAIC,CAAM,EAEtB,SAASC,GAAQL,EAAQ,CACrB,IAAMM,EAAYN,aAAkB,kBAC9B,CAACA,CAAM,EACPA,EAAO,iBAAiB,QAAQ,EACtC,QAAWO,KAAOD,EACd,GAAI,CAACH,GAAQ,IAAII,CAAG,EAAG,CACnB,IAAMH,EAAS,SAAS,cAAc,QAAQ,EAC9C,OAAW,CAAE,KAAAI,EAAM,MAAAC,CAAM,IAAKF,EAAI,WAC9BH,EAAO,aAAaI,EAAMC,CAAK,EAEnCL,EAAO,KAAOG,EAAI,KAClBA,EAAI,YAAYH,CAAM,EACtBD,GAAQ,IAAIC,CAAM,CACtB,CAER,CACA,SAASH,GAAe,CAAE,QAAAX,CAAQ,EAAGF,EAAMsB,EAASC,EAAiB,CACjE,QAAWX,KAAUW,EAAiB,CAClC,IAAMC,EAASF,EAAQ,UAAU,EAAI,EACrC,GAAItB,IAASyB,GACTb,EAAO,OAAO,UAETZ,IAASS,IACdT,IAAS0B,GACTC,GAAMf,EAAQY,EAAQxB,CAAI,EAC1BiB,GAAQL,CAAM,UAGdK,GAAQO,CAAM,EACVxB,IAASU,GACTE,EAAO,YAAYY,CAAM,UAEpBxB,IAAS4B,GACdhB,EAAO,QAAQY,CAAM,UAEhBxB,IAAS6B,GACdjB,EAAO,OAAOY,CAAM,UAEfxB,IAAS8B,GACdlB,EAAO,OAAOY,CAAM,UAEfxB,IAAS+B,GACdnB,EAAO,MAAMY,CAAM,MAGnB,OAAMtB,EAAQ,mBAAoB,CAAE,KAAAF,CAAK,CAAC,CAGtD,CACJ,CACA,IAAMgC,GAAkB,IAAI,IACtBC,EAAW,IAAI,IACfC,GAAmB,IAAI,IACvBC,GAAe,IAAI,IACnBC,GAAY,SAAS,cAAc,KAAK,EAC9CA,GAAU,OAAS,GACnB,SAAST,GAAMU,EAAQ7B,EAAYR,EAAM,CACrC,IAAMsC,EAASC,EAAS,cAAc,EACtC,GAAKF,EAAO,aAAaC,CAAM,GAC3B9B,aAAsB,aACtBA,EAAW,aAAa8B,CAAM,GAC9BD,EAAO,eAAe,QAAQ,IAAIC,CAAM,GAAG,EAC3C,OAEJ,IAAME,EAAgB,SAAS,cAAc,KAAK,EAClDA,EAAc,OAAOhC,CAAU,EAC/B,SAAS,KAAK,sBAAsB,WAAY4B,EAAS,EAEzD,IAAMK,EAAgBJ,EAAO,iBAAiB,MAAM,EACpD,OAAW,CAAE,GAAAK,EAAI,QAAAC,CAAQ,IAAKF,EACtBT,GAAgB,IAAIU,CAAE,EACtBP,GAAa,IAAIO,CAAE,EAGnBV,GAAgB,IAAIU,EAAIC,CAAO,EAGnCN,EAAO,KACHL,GAAgB,IAAIK,EAAO,EAAE,EAC7BF,GAAa,IAAIE,EAAO,EAAE,EAG1BL,GAAgB,IAAIK,EAAO,GAAIA,EAAO,OAAO,GAGrDH,GAAiB,MAAM,EACvB,IAAMU,EAAgBJ,EAAc,iBAAiB,MAAM,EAC3D,OAAW,CAAE,GAAAE,EAAI,QAAAC,CAAQ,IAAKC,EACtBV,GAAiB,IAAIQ,CAAE,EACvBP,GAAa,IAAIO,CAAE,EAEdV,GAAgB,IAAIU,CAAE,IAAMC,GACjCT,GAAiB,IAAIQ,CAAE,EAG/BV,GAAgB,MAAM,EACtB,QAAWU,KAAMP,GACbD,GAAiB,OAAOQ,CAAE,EAE9BP,GAAa,MAAM,EAMnBF,EAAS,MAAM,EACfY,GAAsB7C,IAAS,QAAUqC,EAAO,cAAgBA,EAAQI,CAAa,EACrFI,GAAsBL,EAAeI,CAAa,EAClDE,GAAc9C,IAAS,QAAUqC,EAAO,cAAgBA,EAAQG,EAAexC,IAAS,QAAUqC,EAAS,KAAMA,EAAO,WAAW,EACnID,GAAU,OAAO,CACrB,CAKA,SAASU,GAAcC,EACvBC,EACAC,EAAiB,KACjBC,EAAW,KAAM,CAETH,aAAqB,qBACrBC,aAAqB,sBAErBD,EAAYA,EAAU,QACtBC,EAAYA,EAAU,SAE1BC,IAAmBF,EAAU,WAE7B,QAAWI,KAAYH,EAAU,WAAY,CAEzC,GAAIC,GAAkBA,IAAmBC,EAAU,CAC/C,IAAME,EAAYC,GAAcF,EAAUF,EAAgBC,CAAQ,EAClE,GAAIE,EAAW,CAEX,GAAIA,IAAcH,EAAgB,CAC9B,IAAIK,EAASL,EAEb,KAAOK,GAAUA,IAAWF,GAAW,CACnC,IAAMG,EAAWD,EACjBA,EAASA,EAAO,YAChBE,GAAWD,CAAQ,CACvB,CACJ,CACAE,GAAUL,EAAWD,CAAQ,EAC7BF,EAAiBG,EAAU,YAC3B,QACJ,CACJ,CAEA,IAAMM,EAAOP,EAAS,GAEtB,GAAIA,aAAoB,SAAWjB,GAAiB,IAAIwB,CAAI,EAAG,CAG3D,IAAMC,EAAa,OAAOD,CAAI,EAK1BE,EAAUD,EACd,KAAQC,EAAUA,EAAQ,YAAa,CACnC,IAAMC,EAAQ5B,EAAS,IAAI2B,CAAO,EAC9BC,IACAA,EAAM,OAAOH,CAAI,EACZG,EAAM,MACP5B,EAAS,OAAO2B,CAAO,EAGnC,CACAE,GAAWf,EAAWY,EAAYV,CAAc,EAChDQ,GAAUE,EAAYR,CAAQ,EAC9BF,EAAiBU,EAAW,YAC5B,QACJ,CAGA,GAAI1B,EAAS,IAAIkB,CAAQ,EAAG,CAExB,IAAMY,EAAgB,SAAS,cAAcZ,EAAS,OAAO,EAC7DJ,EAAU,aAAagB,EAAed,CAAc,EACpDQ,GAAUM,EAAeZ,CAAQ,EACjCF,EAAiBc,EAAc,WACnC,KACK,CAED,IAAMC,EAAiB,SAAS,WAAWb,EAAU,EAAI,EACzDJ,EAAU,aAAaiB,EAAgBf,CAAc,EACrDA,EAAiBe,EAAe,WACpC,CACJ,CAEA,KAAOf,GAAkBA,IAAmBC,GAAU,CAClD,IAAMK,EAAWN,EACjBA,EAAiBA,EAAe,YAChCO,GAAWD,CAAQ,CACvB,CACJ,CAIA,SAASF,GAAcY,EAAMC,EAAYhB,EAAU,CAC/C,IAAIE,EAAY,KACZe,EAAcF,EAAK,YACnBG,EAAwB,EACxBC,EAAqB,EAEnBC,EAAiBrC,EAAS,IAAIgC,CAAI,GAAG,MAAQ,EAC/CX,EAASY,EACb,KAAOZ,GAAUA,IAAWJ,GAAU,CAElC,GAAIqB,GAAYjB,EAAQW,CAAI,EAAG,CAC3B,IAAIO,EAAe,GACbC,EAASxC,EAAS,IAAIqB,CAAM,EAC5BoB,EAASzC,EAAS,IAAIgC,CAAI,EAChC,GAAIS,GAAUD,GACV,QAAW/B,KAAM+B,EAKb,GAAIC,EAAO,IAAIhC,CAAE,EAAG,CAChB8B,EAAe,GACf,KACJ,EAGR,GAAIA,EACA,OAAOlB,EAIX,GAAI,CAACF,GAAa,CAACnB,EAAS,IAAIqB,CAAM,EAAG,CAErC,GAAI,CAACgB,EACD,OAAOhB,EAGXF,EAAYE,CAChB,CACJ,CAsBA,GApBAe,GAAsBpC,EAAS,IAAIqB,CAAM,GAAG,MAAQ,EAChDe,EAAqBC,IAKrBlB,IAAc,MAAQe,GAAeI,GAAYjB,EAAQa,CAAW,IAGpEC,IACAD,EAAcA,EAAY,YAItBC,GAAyB,IACzBhB,EAAY,SAKhBE,EAAO,SAAS,SAAS,aAAa,GACtC,MACJA,EAASA,EAAO,WACpB,CACA,OAAOF,GAAa,IACxB,CACA,SAASmB,GAAYI,EAASC,EAAS,CAEnC,IAAMC,EAAQF,EAAQ,GACtB,OAAQA,EAAQ,WAAaC,EAAQ,UACjCD,EAAQ,UAAYC,EAAQ,UAI3B,CAACC,GAASA,IAAUD,EAAQ,GACrC,CAIA,SAASpB,GAAWS,EAAM,CAElBhC,EAAS,IAAIgC,CAAI,EAEjBH,GAAW1B,GAAW6B,EAAM,IAAI,EAIhCA,EAAK,YAAY,YAAYA,CAAI,CAEzC,CAIA,IAAMH,GAENN,GAAW,KAAK,KAAKpB,GAAU,YAAcA,GAAU,YAAY,EACnE,SAASqB,GAAUkB,EACnBC,EAAS,CAGL,IAAME,EAAOF,EAAQ,SAGrB,GAAIE,IAAS,EAAsB,CAC/B,IAAMxC,EAASC,EAAS,cAAc,EACtC,GAAIoC,EAAQ,aAAarC,CAAM,GAC3BsC,EAAQ,aAAatC,CAAM,EAC3B,OAAOqC,EAKX,GAAIA,aAAmB,kBACnBC,aAAmB,kBACnBA,EAAQ,OAAS,OASbA,EAAQ,aAAa,OAAO,IAAMD,EAAQ,aAAa,OAAO,IAC9DA,EAAQ,MAAQC,EAAQ,aAAa,OAAO,GAAK,YAGhDD,aAAmB,qBACxBC,aAAmB,oBAAqB,CACxC,IAAMG,EAAWH,EAAQ,MACrBG,IAAaJ,EAAQ,QACrBA,EAAQ,MAAQI,GAEhBJ,EAAQ,YAAcA,EAAQ,WAAW,YAAcI,IACvDJ,EAAQ,WAAW,UAAYI,EAEvC,CACA,IAAMC,GAAiBJ,EAAQ,aAAarC,EAAS,eAAe,CAAC,GAAK,IAAI,MAAM,GAAG,EACvF,OAAW,CAAE,KAAAnB,EAAM,MAAAC,CAAM,IAAKuD,EAAQ,WAC9BD,EAAQ,aAAavD,CAAI,IAAMC,GAC/B,CAAC2D,EAAc,SAASC,EAAM7D,CAAI,CAAC,GAEnCuD,EAAQ,aAAavD,EAAMC,CAAK,EAGxC,IAAM6D,EAAWP,EAAQ,WACzB,QAASQ,EAAID,EAAS,OAAS,EAAGC,GAAK,EAAGA,IAAK,CAC3C,GAAM,CAAE,KAAA/D,CAAK,EAAI8D,EAASC,CAAC,EACvB,CAACP,EAAQ,aAAaxD,CAAI,GAC1B,CAAC4D,EAAc,SAASC,EAAM7D,CAAI,CAAC,GAEnCuD,EAAQ,gBAAgBvD,CAAI,CAEpC,CACJ,CACA,OAAI0D,IAAS,GAAmBA,IAAS,IACjCH,EAAQ,YAAcC,EAAQ,YAC9BD,EAAQ,UAAYC,EAAQ,WAG/BD,EAAQ,YAAYC,CAAO,GAC5B9B,GAAc6B,EAASC,CAAO,EAE3BD,CACX,CAKA,SAAS9B,GAAsBuC,EAAMtF,EAAU,CAC3C,QAAWuF,KAAOvF,EACd,GAAIoC,GAAiB,IAAImD,EAAI,EAAE,EAAG,CAC9B,IAAIzB,EAAUyB,EAEd,KAAOzB,GAAWA,IAAYwB,GAAM,CAChC,IAAIvB,EAAQ5B,EAAS,IAAI2B,CAAO,EAE3BC,IACDA,EAAQ,IAAI,IACZ5B,EAAS,IAAI2B,EAASC,CAAK,GAE/BA,EAAM,IAAIwB,EAAI,EAAE,EAChBzB,EAAUA,EAAQ,aACtB,CACJ,CAER,CCtdO,IAAM0B,GAAe,CACxB,KAAM,UACN,KAAMC,GACN,aAAeC,GAAQC,GAAwBF,GAAuB,CAAC,CAAE,QAASG,EAAM,KAAM,cAAeC,EAAmB,GAAGC,EAAgC,EAAI,IAAMJ,EAAI,WAAWK,GAAcH,CAAG,EAAG,CAC5M,UAAWI,GAAaH,CAAgB,CAC5C,CAAC,CAAC,CACN,ECgBAI,GAEAC,GAAKC,GAAMC,GAAKC,GAAOC,GAAQC,GAAeC,GAE9CC,GAAMC,GAAMC,GAAOC,GAAUC,GAAQC,GAAWC,GAAaC,GAAIC,GAAaC,GAAYC,GAAQC,GAAeC,GAAKC,GAAMC,GAASC,GAAOC,GAE5IC,GAAMC,GAAQC,EAAS,EACvBC,GAAM",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "DATASTAR_REQUEST", "DefaultSseRetryDurationMs", "DefaultPatchSignalsOnlyIfMissing", "ElementPatchModeOuter", "ElementPatchModeInner", "ElementPatchModeRemove", "ElementPatchModeReplace", "ElementPatchModePrepend", "ElementPatchModeAppend", "ElementPatchModeBefore", "ElementPatchModeAfter", "DefaultElementPatchMode", "EventTypePatchElements", "EventTypePatchSignals", "isHTMLOrSVG", "el", "isPojo", "obj", "isEmpty", "prop", "updateLeaves", "fn", "key", "val", "pathToObj", "paths", "result", "path", "value", "keys", "lastKey", "acc", "isBoolString", "str", "kebab", "camel", "x", "snake", "pascal", "jsStrToObject", "raw", "caseFns", "modifyCasing", "mods", "c", "fn", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "r", "snake", "q", "c", "initErr", "ctx", "reason", "metadata", "errCtx", "dserr", "runtimeErr", "DATASTAR_SIGNAL_PATCH_EVENT", "DATASTAR", "ReactiveFlags", "EffectFlags", "currentPatch", "queuedEffects", "batchDepth", "notifyIndex", "queuedEffectsLength", "activeSub", "startBatch", "endBatch", "flush", "dispatch", "signal", "initialValue", "signalOper", "computedSymbol", "computed", "getter", "c", "computedOper", "effect", "fn", "e", "link", "prev", "setCurrentSub", "effectOper", "peek", "run", "update", "updateComputed", "updateSignal", "sub", "prevSub", "startTracking", "oldValue", "endTracking", "s", "value", "notify", "flags", "subs", "checkDirty", "dep", "depFlags", "shallowPropagate", "newValue", "propagate", "currentValue", "subs_", "unlink", "prevDep", "nextDep", "recursedCheck", "isValidLink", "newLink", "sub_", "dep_", "prevDep_", "nextDep_", "nextSub_", "prevSub_", "toRemove", "next", "stack", "top", "subSubs", "depsTail_", "checkDepth", "dirty", "firstSub", "hasMultipleSubs", "nextSub", "subFlags", "checkLink", "depsTail", "getPath", "path", "result", "root", "split", "DELETE", "deep", "prefix", "isArr", "isPojo", "deepObj", "key", "keys", "_", "prop", "diff", "patch", "i", "detail", "pathToObj", "DATASTAR_SIGNAL_PATCH_EVENT", "mergePatch", "ifMissing", "mergeInner", "mergePaths", "paths", "options", "target", "targetParent", "filtered", "include", "exclude", "obj", "node", "toRegExp", "val", "actions", "plugins", "pluginRegexs", "removals", "mutationObserver", "alias", "setAlias", "aliasify", "name", "load", "pluginsToLoad", "plugin", "ctx", "initErr", "a", "b", "lenDiff", "applyEls", "els", "ignore", "el", "applyAttributePlugin", "cleanupEls", "cleanups", "cleanup", "apply", "observe", "attrKey", "rawKey", "camel", "rawModifiers", "hasKey", "hasValue", "runtimeErr", "generateReactiveExpression", "keyReq", "valReq", "rawMod", "label", "mod", "t", "mutations", "type", "attributeName", "addedNodes", "removedNodes", "isHTMLOrSVG", "expr", "attrPlugin", "statementRe", "statements", "lastIdx", "last", "signalName", "acc", "part", "varName", "escaped", "escapeRe", "DSP", "DSS", "counter", "match", "k", "nameGen", "snake", "actionsCalled", "actionsRe", "actionMatches", "actionNames", "actionFns", "actionPrefix", "DATASTAR", "actionName", "action", "args", "v", "error", "Peek", "peek", "fn", "SetAll", "filtered", "mergePatch", "peek", "value", "filter", "masked", "updateLeaves", "ToggleAll", "filtered", "mergePatch", "peek", "filter", "masked", "updateLeaves", "oldValue", "Attr", "el", "effect", "key", "rx", "syncAttr", "val", "kebab", "update", "observer", "obj", "attributeFilter", "cleanup", "dataURIRegex", "empty", "Bind", "el", "key", "mods", "value", "effect", "mergePaths", "runtimeErr", "getPath", "signalName", "modifyCasing", "get", "type", "set", "syncSignal", "files", "contents", "mimes", "names", "f", "resolve", "reader", "match", "typeMap", "option", "initialValue", "path", "inputs", "aliasify", "paths", "i", "input", "signalValue", "cleanup", "Class", "key", "el", "effect", "mods", "rx", "modifyCasing", "kebab", "callback", "observer", "classes", "k", "classNames", "cn", "name", "cleanup", "Computed", "key", "mods", "rx", "computed", "mergePaths", "modifyCasing", "Effect", "effect", "rx", "DATASTAR_FETCH_EVENT", "DATASTAR", "STARTED", "FINISHED", "ERROR", "RETRYING", "RETRIES_FAILED", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "Indicator", "el", "key", "mods", "mergePaths", "value", "signalName", "modifyCasing", "watcher", "event", "type", "elt", "STARTED", "FINISHED", "DATASTAR_FETCH_EVENT", "JsonSignals", "el", "effect", "value", "filtered", "mods", "spaces", "filters", "jsStrToObject", "callback", "observer", "cleanup", "tagToMs", "args", "arg", "tagHas", "tags", "tag", "defaultValue", "delay", "callback", "wait", "args", "debounce", "leading", "trailing", "timer", "throttle", "waiting", "modifyTiming", "mods", "delayArgs", "tagToMs", "debounceArgs", "tagHas", "throttleArgs", "supportsViewTransitions", "modifyViewTransition", "callback", "mods", "cb", "args", "On", "ctx", "el", "key", "mods", "rx", "startBatch", "endBatch", "target", "callback", "evt", "modifyTiming", "modifyViewTransition", "evtListOpts", "cb", "eventName", "kebab", "modifyCasing", "DATASTAR_FETCH_EVENT", "DATASTAR_SIGNAL_PATCH_EVENT", "once", "OnIntersect", "el", "mods", "rx", "startBatch", "endBatch", "callback", "modifyTiming", "modifyViewTransition", "options", "observer", "entries", "entry", "OnInterval", "mods", "rx", "startBatch", "endBatch", "callback", "modifyViewTransition", "duration", "durationArgs", "tagToMs", "tagHas", "intervalId", "OnLoad", "rx", "mods", "startBatch", "endBatch", "callback", "modifyViewTransition", "wait", "delayArgs", "tagToMs", "delay", "OnSignalPatch", "el", "key", "mods", "plugin", "rx", "filtered", "runtimeErr", "startBatch", "endBatch", "filtersRaw", "filters", "jsStrToObject", "callback", "modifyTiming", "evt", "watched", "isEmpty", "DATASTAR_SIGNAL_PATCH_EVENT", "Ref", "el", "key", "mods", "value", "mergePaths", "signalName", "modifyCasing", "NONE", "DISPLAY", "Show", "el", "effect", "rx", "update", "observer", "cleanup", "Signals", "key", "mods", "rx", "mergePatch", "mergePaths", "ifMissing", "modifyCasing", "patch", "Style", "key", "el", "effect", "rx", "style", "initialStyles", "kebab", "apply", "prop", "value", "initial", "update", "observer", "styles", "cleanup", "Text", "el", "effect", "rx", "update", "observer", "cleanup", "fetchAbortControllers", "createHttpMethod", "name", "method", "ctx", "url", "args", "el", "requestCancellation", "controller", "isDisabled", "fetcher", "dispatchFetch", "type", "argsRaw", "DATASTAR_FETCH_EVENT", "isWrongContent", "err", "evt", "filtered", "runtimeErr", "selector", "userHeaders", "contentType", "include", "exclude", "openWhenHidden", "retryInterval", "DefaultSseRetryDurationMs", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "abort", "action", "cleanupFn", "initialHeaders", "DATASTAR_REQUEST", "headers", "req", "response", "ERROR", "DATASTAR", "argsRawLines", "line", "i", "k", "v", "error", "RETRYING", "urlInstance", "queryParams", "res", "formEl", "formData", "submitter", "preventDefault", "multipart", "formParams", "key", "value", "boundary", "encoder", "total", "parts", "loaded", "write", "data", "progress", "field", "reader", "done", "chunk", "STARTED", "fetchEventSource", "FINISHED", "getBytes", "stream", "onChunk", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "valueOffset", "retry", "a", "b", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "inputFetch", "overrides", "rest", "resolve", "reject", "curRequestController", "onVisibilityChange", "create", "retryTimer", "dispose", "fetch", "onopen", "retries", "baseRetryInterval", "dispatchNonSSE", "dispatchType", "argNames", "n", "kebab", "o", "ct", "EventTypePatchElements", "EventTypePatchSignals", "script", "scriptAttributesHeader", "id", "interval", "RETRIES_FAILED", "innerErr", "DELETE", "createHttpMethod", "GET", "createHttpMethod", "PATCH", "createHttpMethod", "POST", "createHttpMethod", "PUT", "createHttpMethod", "PatchElements", "EventTypePatchElements", "ctx", "datastarSSEEventWatcher", "args", "supportsViewTransitions", "onPatchElements", "elements", "selector", "mode", "DefaultElementPatchMode", "initErr", "elementsWithSvgsRemoved", "hasHtml", "hasHead", "hasBody", "newDocument", "newContent", "ElementPatchModeOuter", "ElementPatchModeReplace", "child", "target", "applyToTargets", "targets", "scripts", "script", "execute", "elScripts", "old", "name", "value", "element", "capturedTargets", "cloned", "ElementPatchModeRemove", "ElementPatchModeInner", "morph", "ElementPatchModePrepend", "ElementPatchModeAppend", "ElementPatchModeBefore", "ElementPatchModeAfter", "oldIdTagNameMap", "ctxIdMap", "ctxPersistentIds", "duplicateIds", "ctxPantry", "oldElt", "ignore", "aliasify", "normalizedElt", "oldIdElements", "id", "tagName", "newIdElements", "populateIdMapWithTree", "morphChildren", "oldParent", "newParent", "insertionPoint", "endPoint", "newChild", "bestMatch", "findBestMatch", "cursor", "tempNode", "removeNode", "morphNode", "ncId", "movedChild", "current", "idSet", "moveBefore", "newEmptyChild", "newClonedChild", "node", "startPoint", "nextSibling", "siblingSoftMatchCount", "displaceMatchCount", "nodeMatchCount", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "oldNode", "newNode", "oldId", "type", "newValue", "preserveAttrs", "kebab", "oldAttrs", "i", "root", "elt", "PatchSignals", "EventTypePatchSignals", "ctx", "datastarSSEEventWatcher", "raw", "onlyIfMissingRaw", "DefaultPatchSignalsOnlyIfMissing", "jsStrToObject", "isBoolString", "load", "GET", "POST", "PUT", "PATCH", "DELETE", "PatchElements", "PatchSignals", "Attr", "Bind", "Class", "Computed", "Effect", "Indicator", "JsonSignals", "On", "OnIntersect", "OnInterval", "OnLoad", "OnSignalPatch", "Ref", "Show", "Signals", "Style", "Text", "Peek", "SetAll", "ToggleAll", "apply"]
}
