{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/utils/dom.ts", "../library/src/utils/paths.ts", "../library/src/utils/text.ts", "../library/src/engine/errors.ts", "../library/src/engine/types.ts", "../library/src/engine/engine.ts", "../library/src/bundles/datastar-core.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should elements be patched using the ViewTransition API?\nexport const DefaultElementsUseViewTransitions = false;\n\n// Should a given set of signals patch if they are missing?\nexport const DefaultPatchSignalsOnlyIfMissing = false;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a element is patched into the DOM.\n// Morphs the element into the existing element.\nexport const ElementPatchModeOuter = \"outer\"\n// Replaces the inner HTML of the existing element.\nexport const ElementPatchModeInner = \"inner\"\n// Removes the existing element.\nexport const ElementPatchModeRemove = \"remove\"\n// Replaces the existing element with the new element.\nexport const ElementPatchModeReplace = \"replace\"\n// Prepends the element inside to the existing element.\nexport const ElementPatchModePrepend = \"prepend\"\n// Appends the element inside the existing element.\nexport const ElementPatchModeAppend = \"append\"\n// Inserts the element before the existing element.\nexport const ElementPatchModeBefore = \"before\"\n// Inserts the element after the existing element.\nexport const ElementPatchModeAfter = \"after\"\n\n// Default value for ElementPatchMode\nexport const DefaultElementPatchMode = ElementPatchModeOuter;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\n// An event for patching HTML elements into the DOM.\nexport const EventTypePatchElements = \"datastar-patch-elements\"\n// An event for patching signals.\nexport const EventTypePatchSignals = \"datastar-patch-signals\"\n// #endregion\n\n// #endregion", "import type { HTMLOrSVG } from '../engine/types'\n\nexport function isHTMLOrSVG(el: Node): el is HTMLOrSVG {\n  return el instanceof HTMLElement || el instanceof SVGElement\n}\n", "import type { Paths } from '../engine/types'\n\nexport const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport function isEmpty(obj: Record<string, any>): boolean {\n  for (const prop in obj) {\n    if (Object.hasOwn(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function updateLeaves(\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val) || Array.isArray(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (paths: Paths): Record<string, any> => {\n  const result: Record<string, any> = {}\n  for (const [path, value] of paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), result)\n    obj[lastKey] = value\n  }\n  return result\n}\n", "import type { Modifiers } from '../engine/types'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase()\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport type { InitContext, RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(ctx: InitContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(ctx: RuntimeContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      // validSignals:\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { DATASTAR } from './consts'\nexport type PluginType = 'attribute' | 'watcher' | 'action'\nexport type Requirement = 'allowed' | 'must' | 'denied' | 'exclusive'\n\n// export type ReactiveNode = Signal | Computed | Effect\n// export type Subscriber = Computed | Effect\nexport type OnRemovalFn = () => void\n\nexport type DatastarPlugin = AttributePlugin | WatcherPlugin | ActionPlugin\n\nexport const DATASTAR_SIGNAL_PATCH_EVENT = `${DATASTAR}-signal-patch`\nexport type JSONPatch = Record<string, any> & { length?: never }\nexport type Paths = [string, any][]\n\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_PATCH_EVENT]: CustomEvent<JSONPatch>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accessible via a `data-${name}` attribute on an element\nexport type AttributePlugin = {\n  type: 'attribute'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  returnsValue?: boolean // If the expression returns a value\n  shouldEvaluate?: boolean // If the value should be evaluated\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the Datastar instance\nexport type WatcherPlugin = {\n  type: 'watcher'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport type ActionPlugin = {\n  type: 'action'\n  name: string // The name of the plugin\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type MergePatchArgs = {\n  ifMissing?: boolean\n}\n\nexport type InitContext = {\n  plugin: DatastarPlugin // The plugin instance\n  actions: Readonly<ActionPlugins> // All registered actions\n  root: Record<string, any> // global signals and computed signals\n  filtered: (opts?: SignalFilterOptions, obj?: JSONPatch) => Record<string, any>\n  signal<T>(initialValue?: T | undefined): Signal<T> // creates a signal\n  computed<T>(getter: (previousValue?: T) => T): Computed<T> // creates a computed signal\n  effect(fn: (...args: any[]) => void): OnRemovalFn // creates an effect\n  mergePatch: (patch: JSONPatch, args?: MergePatchArgs) => void\n  mergePaths: (paths: Paths, args?: MergePatchArgs) => void\n  peek: <T>(fn: () => T) => T // returns the current state of the signal without subscribing\n  getPath: <T = any>(path: string) => T | undefined // get a value from the root\n  startBatch: () => void // starts a signal batch\n  endBatch: () => void // ends a signal batch\n  initErr: (reason: string, metadata?: object) => Error\n}\n\nexport type HTMLOrSVG = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\nexport type ReactiveExpressionFn = <T>(...argsThenDeps: any[]) => T // a reactive expression\n\nexport type RuntimeContext = InitContext & {\n  el: HTMLOrSVG // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the modifiers and their tags\n  rx: ReactiveExpressionFn // function to generate a reactive expression\n  fnContent?: string // the content of the function\n  evt?: Event // the event that triggered the plugin\n  runtimeErr: (reason: string, metadata?: object) => Error\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n\nexport type EventCallbackHandler = (...args: any[]) => void\n\nexport type SignalFilter = RegExp\nexport type SignalFilterOptions = {\n  include?: RegExp | string\n  exclude?: RegExp | string\n}\n\nexport type Signal<T = any> = {\n  (): T\n  (value: T): boolean\n}\n\nexport type Computed<T = any> = () => T\n\nexport type Effect = () => void\n", "import { isHTMLOrSVG } from '../utils/dom'\nimport { isPojo, pathToObj } from '../utils/paths'\nimport { camel, snake } from '../utils/text'\nimport { DATASTAR, DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport type {\n  ActionPlugins,\n  AttributePlugin,\n  Computed,\n  DatastarPlugin,\n  Effect,\n  HTMLOrSVG,\n  InitContext,\n  JSONPatch,\n  MergePatchArgs,\n  OnRemovalFn,\n  Paths,\n  RuntimeContext,\n  RuntimeExpressionFunction,\n  Signal,\n  SignalFilterOptions,\n} from './types'\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from './types'\n\n/**\n * Custom signals implementation based on Alien Signals\n */\n\ninterface ReactiveNode {\n  deps_?: Link\n  depsTail_?: Link\n  subs_?: Link\n  subsTail_?: Link\n  flags_: ReactiveFlags\n}\n\ninterface Link {\n  dep_: ReactiveNode\n  sub_: ReactiveNode\n  prevSub_?: Link\n  nextSub_?: Link\n  prevDep_?: Link\n  nextDep_?: Link\n}\n\ninterface Stack<T> {\n  value_: T\n  prev_?: Stack<T>\n}\n\nenum ReactiveFlags {\n  None = 0,\n  Mutable = 1 << 0,\n  Watching = 1 << 1,\n  RecursedCheck = 1 << 2,\n  Recursed = 1 << 3,\n  Dirty = 1 << 4,\n  Pending = 1 << 5,\n}\n\nenum EffectFlags {\n  Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n  fn_(): void\n}\n\ninterface AlienComputed<T = any> extends ReactiveNode {\n  value_?: T\n  getter(previousValue?: T): T\n}\n\ninterface AlienSignal<T = any> extends ReactiveNode {\n  previousValue: T\n  value_: T\n}\n\nconst currentPatch: Paths = []\nconst queuedEffects: (AlienEffect | undefined)[] = []\nlet batchDepth = 0\nlet notifyIndex = 0\nlet queuedEffectsLength = 0\nlet activeSub: ReactiveNode | undefined\n\nconst startBatch = (): void => {\n  batchDepth++\n}\n\nconst endBatch = (): void => {\n  if (!--batchDepth) {\n    flush()\n    dispatch()\n  }\n}\n\nconst signal = <T>(initialValue?: T): Signal<T> => {\n  return signalOper.bind(0, {\n    previousValue: initialValue,\n    value_: initialValue,\n    flags_: 1 satisfies ReactiveFlags.Mutable,\n  }) as Signal<T>\n}\n\nconst computedSymbol = Symbol('computed')\nconst computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n  const c = computedOper.bind(0, {\n    flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n    getter,\n  }) as Computed<T>\n  // @ts-ignore\n  c[computedSymbol] = 1\n  return c\n}\n\nconst effect = (fn: () => void): Effect => {\n  const e: AlienEffect = {\n    fn_: fn,\n    flags_: 2 satisfies ReactiveFlags.Watching,\n  }\n  if (activeSub) {\n    link(e, activeSub)\n  }\n  const prev = setCurrentSub(e)\n  startBatch()\n  try {\n    e.fn_()\n  } finally {\n    endBatch()\n    setCurrentSub(prev)\n  }\n  return effectOper.bind(0, e)\n}\n\nconst peek = <T>(fn: () => T): T => {\n  const prev = setCurrentSub(undefined)\n  try {\n    return fn()\n  } finally {\n    setCurrentSub(prev)\n  }\n}\n\nconst flush = () => {\n  while (notifyIndex < queuedEffectsLength) {\n    const effect = queuedEffects[notifyIndex]!\n    queuedEffects[notifyIndex++] = undefined\n    run(effect, (effect.flags_ &= ~EffectFlags.Queued))\n  }\n  notifyIndex = 0\n  queuedEffectsLength = 0\n}\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n  if ('getter' in signal) {\n    return updateComputed(signal)\n  }\n  return updateSignal(signal, signal.value_)\n}\n\nconst setCurrentSub = (sub?: ReactiveNode): ReactiveNode | undefined => {\n  const prevSub = activeSub\n  activeSub = sub\n  return prevSub\n}\n\nconst updateComputed = (c: AlienComputed): boolean => {\n  const prevSub = setCurrentSub(c)\n  startTracking(c)\n  try {\n    const oldValue = c.value_\n    return oldValue !== (c.value_ = c.getter(oldValue))\n  } finally {\n    setCurrentSub(prevSub)\n    endTracking(c)\n  }\n}\n\nconst updateSignal = (s: AlienSignal, value: any): boolean => {\n  s.flags_ = 1 satisfies ReactiveFlags.Mutable\n  return s.previousValue !== (s.previousValue = value)\n}\n\nconst notify = (e: AlienEffect): void => {\n  const flags = e.flags_\n  if (!(flags & EffectFlags.Queued)) {\n    e.flags_ = flags | EffectFlags.Queued\n    const subs = e.subs_\n    if (subs) {\n      notify(subs.sub_ as AlienEffect)\n    } else {\n      queuedEffects[queuedEffectsLength++] = e\n    }\n  }\n}\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(e.deps_!, e))\n  ) {\n    const prev = setCurrentSub(e)\n    startTracking(e)\n    startBatch()\n    try {\n      e.fn_()\n    } finally {\n      endBatch()\n      setCurrentSub(prev)\n      endTracking(e)\n    }\n    return\n  }\n  if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  let link = e.deps_\n  while (link) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n    if (depFlags & EffectFlags.Queued) {\n      run(dep as AlienEffect, (dep.flags_ = depFlags & ~EffectFlags.Queued))\n    }\n    link = link.nextDep_\n  }\n}\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n  const flags = c.flags_\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(c.deps_!, c))\n  ) {\n    if (updateComputed(c)) {\n      const subs = c.subs_\n      if (subs) {\n        shallowPropagate(subs)\n      }\n    }\n  } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  if (activeSub) {\n    link(c, activeSub)\n  }\n  return c.value_!\n}\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | boolean => {\n  if (value.length) {\n    const newValue = value[0]\n    if (s.value_ !== (s.value_ = newValue)) {\n      s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n      const subs = s.subs_\n      if (subs) {\n        propagate(subs)\n        if (!batchDepth) {\n          flush()\n        }\n      }\n      return true\n    }\n    return false\n  }\n  const currentValue = s.value_\n  if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n    if (updateSignal(s, currentValue)) {\n      const subs_ = s.subs_\n      if (subs_) {\n        shallowPropagate(subs_)\n      }\n    }\n  }\n  if (activeSub) {\n    link(s, activeSub)\n  }\n  return currentValue\n}\n\nconst effectOper = (e: AlienEffect): void => {\n  let dep = e.deps_\n  while (dep) {\n    dep = unlink(dep, e)\n  }\n  const sub = e.subs_\n  if (sub) {\n    unlink(sub)\n  }\n  e.flags_ = 0 satisfies ReactiveFlags.None\n}\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n  const prevDep = sub.depsTail_\n  if (prevDep && prevDep.dep_ === dep) {\n    return\n  }\n  let nextDep: Link | undefined\n  const recursedCheck = sub.flags_ & (4 satisfies ReactiveFlags.RecursedCheck)\n  if (recursedCheck) {\n    nextDep = prevDep ? prevDep.nextDep_ : sub.deps_\n    if (nextDep && nextDep.dep_ === dep) {\n      sub.depsTail_ = nextDep\n      return\n    }\n  }\n  const prevSub = dep.subsTail_\n  if (\n    prevSub &&\n    prevSub.sub_ === sub &&\n    (!recursedCheck || isValidLink(prevSub, sub))\n  ) {\n    return\n  }\n  const newLink =\n    (sub.depsTail_ =\n    dep.subsTail_ =\n      {\n        dep_: dep,\n        sub_: sub,\n        prevDep_: prevDep,\n        nextDep_: nextDep,\n        prevSub_: prevSub,\n      })\n  if (nextDep) {\n    nextDep.prevDep_ = newLink\n  }\n  if (prevDep) {\n    prevDep.nextDep_ = newLink\n  } else {\n    sub.deps_ = newLink\n  }\n  if (prevSub) {\n    prevSub.nextSub_ = newLink\n  } else {\n    dep.subs_ = newLink\n  }\n}\n\nconst unlink = (link: Link, sub_ = link.sub_): Link | undefined => {\n  const dep_ = link.dep_\n  const prevDep_ = link.prevDep_\n  const nextDep_ = link.nextDep_\n  const nextSub_ = link.nextSub_\n  const prevSub_ = link.prevSub_\n  if (nextDep_) {\n    nextDep_.prevDep_ = prevDep_\n  } else {\n    sub_.depsTail_ = prevDep_\n  }\n  if (prevDep_) {\n    prevDep_.nextDep_ = nextDep_\n  } else {\n    sub_.deps_ = nextDep_\n  }\n  if (nextSub_) {\n    nextSub_.prevSub_ = prevSub_\n  } else {\n    dep_.subsTail_ = prevSub_\n  }\n  if (prevSub_) {\n    prevSub_.nextSub_ = nextSub_\n  } else if (!(dep_.subs_ = nextSub_)) {\n    if ('getter' in dep_) {\n      let toRemove = dep_.deps_\n      if (toRemove) {\n        dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n        do {\n          toRemove = unlink(toRemove, dep_)\n        } while (toRemove)\n      }\n    } else if (!('previousValue' in dep_)) {\n      effectOper(dep_ as AlienEffect)\n    }\n  }\n  return nextDep_\n}\n\nconst propagate = (link: Link): void => {\n  let next = link.nextSub_\n  let stack: Stack<Link | undefined> | undefined\n\n  top: while (true) {\n    const sub = link.sub_\n\n    let flags = sub.flags_\n\n    if (flags & (3 as ReactiveFlags.Mutable | ReactiveFlags.Watching)) {\n      if (\n        !(\n          flags &\n          (60 as\n            | ReactiveFlags.RecursedCheck\n            | ReactiveFlags.Recursed\n            | ReactiveFlags.Dirty\n            | ReactiveFlags.Pending)\n        )\n      ) {\n        sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed))\n      ) {\n        flags = 0 satisfies ReactiveFlags.None\n      } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n        sub.flags_ =\n          (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n          (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)) &&\n        isValidLink(link, sub)\n      ) {\n        sub.flags_ =\n          flags | (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending)\n        flags &= 1 satisfies ReactiveFlags.Mutable\n      } else {\n        flags = 0 satisfies ReactiveFlags.None\n      }\n\n      if (flags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n\n      if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n        const subSubs = sub.subs_\n        if (subSubs) {\n          link = subSubs\n          if (subSubs.nextSub_) {\n            stack = { value_: next, prev_: stack }\n            next = link.nextSub_\n          }\n          continue\n        }\n      }\n    }\n\n    if ((link = next!)) {\n      next = link.nextSub_\n      continue\n    }\n\n    while (stack) {\n      link = stack.value_!\n      stack = stack.prev_\n      if (link) {\n        next = link.nextSub_\n        continue top\n      }\n    }\n\n    break\n  }\n}\n\nconst startTracking = (sub: ReactiveNode): void => {\n  sub.depsTail_ = undefined\n  sub.flags_ =\n    (sub.flags_ &\n      ~(56 as\n        | ReactiveFlags.Recursed\n        | ReactiveFlags.Dirty\n        | ReactiveFlags.Pending)) |\n    (4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst endTracking = (sub: ReactiveNode): void => {\n  const depsTail_ = sub.depsTail_\n  let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_\n  while (toRemove) {\n    toRemove = unlink(toRemove, sub)\n  }\n  sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n  let stack: Stack<Link> | undefined\n  let checkDepth = 0\n\n  top: while (true) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n\n    let dirty = false\n\n    if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n      dirty = true\n    } else if (\n      (depFlags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n      (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n    ) {\n      if (update(dep as AlienSignal | AlienComputed)) {\n        const subs = dep.subs_!\n        if (subs.nextSub_) {\n          shallowPropagate(subs)\n        }\n        dirty = true\n      }\n    } else if (\n      (depFlags & (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n      (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n    ) {\n      if (link.nextSub_ || link.prevSub_) {\n        stack = { value_: link, prev_: stack }\n      }\n      link = dep.deps_!\n      sub = dep\n      ++checkDepth\n      continue\n    }\n\n    if (!dirty && link.nextDep_) {\n      link = link.nextDep_\n      continue\n    }\n\n    while (checkDepth) {\n      --checkDepth\n      const firstSub = sub.subs_!\n      const hasMultipleSubs = firstSub.nextSub_\n      if (hasMultipleSubs) {\n        link = stack!.value_\n        stack = stack!.prev_\n      } else {\n        link = firstSub\n      }\n      if (dirty) {\n        if (update(sub as AlienSignal | AlienComputed)) {\n          if (hasMultipleSubs) {\n            shallowPropagate(firstSub)\n          }\n          sub = link.sub_\n          continue\n        }\n      } else {\n        sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending)\n      }\n      sub = link.sub_\n      if (link.nextDep_) {\n        link = link.nextDep_\n        continue top\n      }\n      dirty = false\n    }\n\n    return dirty\n  }\n}\n\nconst shallowPropagate = (link: Link): void => {\n  do {\n    const sub = link.sub_\n    const nextSub = link.nextSub_\n    const subFlags = sub.flags_\n    if (\n      (subFlags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n      (32 satisfies ReactiveFlags.Pending)\n    ) {\n      sub.flags_ = subFlags | (16 satisfies ReactiveFlags.Dirty)\n      if (subFlags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n    }\n    link = nextSub!\n  } while (link)\n}\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n  const depsTail = sub.depsTail_\n  if (depsTail) {\n    let link = sub.deps_!\n    do {\n      if (link === checkLink) {\n        return true\n      }\n      if (link === depsTail) {\n        break\n      }\n      link = link.nextDep_!\n    } while (link)\n  }\n  return false\n}\n\nconst getPath = <T = any>(path: string): T | undefined => {\n  let result = root\n  const split = path.split('.')\n  for (const path of split) {\n    if (result == null || !Object.hasOwn(result, path)) {\n      return\n    }\n    result = result[path]\n  }\n  return result as T\n}\n\nexport const DELETE = Symbol('delete')\nconst deep = (value: any, prefix = ''): any => {\n  const isArr = Array.isArray(value)\n  if (isArr || isPojo(value)) {\n    const deepObj = (isArr ? [] : {}) as Record<string, Signal>\n    for (const key in value) {\n      deepObj[key] = signal(\n        deep((value as Record<string, Signal>)[key], `${prefix + key}.`),\n      )\n    }\n    const keys = signal(0)\n    return new Proxy(deepObj, {\n      get(_, prop: string) {\n        if (!(prop === 'toJSON' && !Object.hasOwn(deepObj, prop))) {\n          if (isArr && prop in Array.prototype) {\n            keys()\n            return deepObj[prop]\n          } else {\n            if (typeof prop === 'symbol') {\n              return deepObj[prop]\n            }\n            if (!Object.hasOwn(deepObj, prop) || deepObj[prop]() == null) {\n              deepObj[prop] = signal('')\n              dispatch(prefix + prop, '')\n              keys(keys() + 1)\n            }\n            return deepObj[prop]()\n          }\n        }\n      },\n      set(_, prop: string, newValue) {\n        const path = prefix + prop\n        if (newValue === DELETE) {\n          if (Object.hasOwn(deepObj, prop)) {\n            delete deepObj[prop]\n            dispatch(path, DELETE)\n            keys(keys() + 1)\n          }\n        } else {\n          if (isArr && prop === 'length') {\n            const diff = (deepObj[prop] as unknown as number) - newValue\n            deepObj[prop] = newValue\n            if (diff > 0) {\n              const patch: Record<string, any> = {}\n              for (let i = newValue; i < deepObj[prop]; i++) {\n                patch[i] = null\n              }\n              dispatch(prefix.slice(0, -1), patch)\n              keys(keys() + 1)\n            }\n          } else {\n            if (Object.hasOwn(deepObj, prop)) {\n              if (newValue == null) {\n                if (deepObj[prop](null)) {\n                  dispatch(path, null)\n                }\n              } else {\n                if (Object.hasOwn(newValue, computedSymbol)) {\n                  deepObj[prop] = newValue\n                  dispatch(path, '')\n                } else {\n                  if (deepObj[prop](deep(newValue, `${path}.`))) {\n                    dispatch(path, newValue)\n                  }\n                }\n              }\n            } else {\n              if (newValue != null) {\n                if (Object.hasOwn(newValue, computedSymbol)) {\n                  deepObj[prop] = newValue\n                  dispatch(path, '')\n                } else {\n                  deepObj[prop] = signal(deep(newValue, `${path}.`))\n                  dispatch(path, newValue)\n                }\n                keys(keys() + 1)\n              }\n            }\n          }\n        }\n\n        return true\n      },\n      deleteProperty(_, prop: string) {\n        if (Object.hasOwn(deepObj, prop)) {\n          if (deepObj[prop](null)) {\n            dispatch(prefix + prop, null)\n          }\n        }\n\n        return true\n      },\n      ownKeys() {\n        keys()\n        return Reflect.ownKeys(deepObj)\n      },\n      has(_, prop) {\n        keys()\n        return prop in deepObj\n      },\n    })\n  }\n  return value\n}\n\nconst dispatch = (path?: string, value?: any) => {\n  if (path !== undefined && value !== undefined) {\n    currentPatch.push([path, value])\n  }\n  if (!batchDepth && currentPatch.length) {\n    const detail = pathToObj(currentPatch)\n    currentPatch.length = 0\n    document.dispatchEvent(\n      new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n        detail,\n      }),\n    )\n  }\n}\n\nconst mergePatch = (\n  patch: JSONPatch,\n  { ifMissing }: MergePatchArgs = {},\n): void => {\n  startBatch()\n  for (const key in patch) {\n    if (patch[key] == null) {\n      if (!ifMissing) {\n        delete root[key]\n      }\n    } else {\n      mergeInner(patch[key], key, root, '', ifMissing)\n    }\n  }\n  endBatch()\n}\n\nconst mergePaths = (paths: Paths, options: MergePatchArgs = {}): void =>\n  mergePatch(pathToObj(paths), options)\n\nconst mergeInner = (\n  patch: any,\n  target: string,\n  targetParent: Record<string, any>,\n  prefix: string,\n  ifMissing: boolean | undefined,\n): void => {\n  if (isPojo(patch)) {\n    if (\n      !(\n        Object.hasOwn(targetParent, target) &&\n        (isPojo(targetParent[target]) || Array.isArray(targetParent[target]))\n      )\n    ) {\n      targetParent[target] = {}\n    }\n\n    for (const key in patch) {\n      if (patch[key] == null) {\n        if (!ifMissing) {\n          delete targetParent[target][key]\n        }\n      } else {\n        mergeInner(\n          patch[key],\n          key,\n          targetParent[target],\n          `${prefix + target}.`,\n          ifMissing,\n        )\n      }\n    }\n  } else if (!(ifMissing && Object.hasOwn(targetParent, target))) {\n    targetParent[target] = patch\n  }\n}\n\nfunction filtered(\n  { include = /.*/, exclude = /(?!)/ }: SignalFilterOptions = {},\n  obj: JSONPatch = root,\n): Record<string, any> {\n  // We need to find all valid signal paths in the object\n  const paths: Paths = []\n  const stack: [any, string][] = [[obj, '']]\n\n  while (stack.length) {\n    const [node, prefix] = stack.pop()!\n\n    for (const key in node) {\n      const path = prefix + key\n      if (isPojo(node[key])) {\n        stack.push([node[key], `${path}.`])\n      } else if (\n        toRegExp(include).test(path) &&\n        !toRegExp(exclude).test(path)\n      ) {\n        paths.push([path, getPath(path)])\n      }\n    }\n  }\n\n  return pathToObj(paths)\n}\n\nfunction toRegExp(val: string | RegExp): RegExp {\n  if (typeof val === 'string') {\n    return RegExp(val.replace(/^\\/|\\/$/g, ''))\n  }\n\n  return val\n}\n\nconst root: Record<string, any> = deep({})\n\n/**\n * Turn data-* attributes into reactive expressions\n * This is the core of the Datastar\n */\n\nconst actions: ActionPlugins = {}\nconst plugins: AttributePlugin[] = []\nlet pluginRegexs: RegExp[] = []\n\n// Map of cleanup functions by element, keyed by a dataset key-value hash\nconst removals = new Map<HTMLOrSVG, Map<string, OnRemovalFn>>()\n\nlet mutationObserver: MutationObserver | null = null\n\nlet alias = ''\nexport function setAlias(value: string) {\n  alias = value\n}\nexport function aliasify(name: string) {\n  return alias ? `data-${alias}-${name}` : `data-${name}`\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n  for (const plugin of pluginsToLoad) {\n    const ctx: InitContext = {\n      plugin,\n      actions,\n      root,\n      filtered,\n      signal,\n      computed,\n      effect,\n      mergePatch,\n      mergePaths,\n      peek,\n      getPath,\n      startBatch,\n      endBatch,\n      initErr: 0 as any,\n    }\n    ctx.initErr = initErr.bind(0, ctx)\n\n    if (plugin.type === 'action') {\n      actions[plugin.name] = plugin\n    } else if (plugin.type === 'attribute') {\n      plugins.push(plugin)\n      plugin.onGlobalInit?.(ctx)\n    } else if (plugin.type === 'watcher') {\n      plugin.onGlobalInit?.(ctx)\n    } else {\n      throw ctx.initErr('InvalidPluginType')\n    }\n  }\n\n  // Sort attribute plugins by descending length then alphabetically\n  plugins.sort((a, b) => {\n    const lenDiff = b.name.length - a.name.length\n    if (lenDiff !== 0) return lenDiff\n    return a.name.localeCompare(b.name)\n  })\n\n  pluginRegexs = plugins.map((plugin) => RegExp(`^${plugin.name}([A-Z]|_|$)`))\n}\n\nfunction applyEls(els: Iterable<HTMLOrSVG>): void {\n  const ignore = `[${aliasify('ignore')}]`\n  for (const el of els) {\n    if (!el.closest(ignore)) {\n      for (const key in el.dataset) {\n        applyAttributePlugin(el, key, el.dataset[key]!)\n      }\n    }\n  }\n}\n\nfunction cleanupEls(els: Iterable<HTMLOrSVG>): void {\n  for (const el of els) {\n    const cleanups = removals.get(el)\n    // If removals has el, delete it and run all cleanup functions\n    if (removals.delete(el)) {\n      for (const cleanup of cleanups!.values()) {\n        cleanup()\n      }\n      cleanups!.clear()\n    }\n  }\n}\n\n// Apply all plugins to the entire DOM or a provided element\nexport function apply(root: HTMLOrSVG = document.body) {\n  // Delay applying plugins to give custom plugins a chance to load\n  queueMicrotask(() => {\n    applyEls([root])\n    applyEls(root.querySelectorAll<HTMLOrSVG>('*'))\n\n    // Monitor the entire document body or a provided element for changes\n    // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n    if (!mutationObserver) {\n      mutationObserver = new MutationObserver(observe)\n      mutationObserver.observe(root, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n      })\n    }\n  })\n}\n\nfunction applyAttributePlugin(\n  el: HTMLOrSVG,\n  attrKey: string,\n  value: string,\n): void {\n  if (attrKey.startsWith(alias)) {\n    const rawKey = camel(alias ? attrKey.slice(alias.length) : attrKey)\n    const plugin = plugins.find((_, i) => pluginRegexs[i].test(rawKey))\n    if (plugin) {\n      // Extract the key and modifiers\n      let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/__+/)\n\n      const hasKey = !!key\n      if (hasKey) {\n        key = camel(key)\n      }\n      const hasValue = !!value\n\n      // Create the runtime context\n      const ctx: RuntimeContext = {\n        plugin,\n        actions,\n        root,\n        filtered,\n        signal,\n        computed,\n        effect,\n        mergePatch,\n        mergePaths,\n        peek,\n        getPath,\n        startBatch,\n        endBatch,\n        initErr: 0 as any,\n        el,\n        rawKey,\n        key,\n        value,\n        mods: new Map(),\n        runtimeErr: 0 as any,\n        rx: 0 as any,\n      }\n      ctx.initErr = initErr.bind(0, ctx)\n      ctx.runtimeErr = runtimeErr.bind(0, ctx)\n      if (\n        plugin.shouldEvaluate === undefined ||\n        plugin.shouldEvaluate === true\n      ) {\n        ctx.rx = generateReactiveExpression(ctx)\n      }\n\n      // Check the requirements\n      const keyReq = plugin.keyReq || 'allowed'\n      if (hasKey) {\n        if (keyReq === 'denied') {\n          throw ctx.runtimeErr(`${plugin.name}KeyNotAllowed`)\n        }\n      } else if (keyReq === 'must') {\n        throw ctx.runtimeErr(`${plugin.name}KeyRequired`)\n      }\n\n      const valReq = plugin.valReq || 'allowed'\n      if (hasValue) {\n        if (valReq === 'denied') {\n          throw ctx.runtimeErr(`${plugin.name}ValueNotAllowed`)\n        }\n      } else if (valReq === 'must') {\n        throw ctx.runtimeErr(`${plugin.name}ValueRequired`)\n      }\n\n      // Check for exclusive requirements\n      if (keyReq === 'exclusive' || valReq === 'exclusive') {\n        if (hasKey && hasValue) {\n          throw ctx.runtimeErr(`${plugin.name}KeyAndValueProvided`)\n        }\n        if (!hasKey && !hasValue) {\n          throw ctx.runtimeErr(`${plugin.name}KeyOrValueRequired`)\n        }\n      }\n\n      for (const rawMod of rawModifiers) {\n        const [label, ...mod] = rawMod.split('.')\n        ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n      }\n\n      const cleanup = plugin.onLoad(ctx)\n      if (cleanup) {\n        let cleanups = removals.get(el)\n        if (cleanups) {\n          cleanups.get(rawKey)?.()\n        } else {\n          cleanups = new Map()\n          removals.set(el, cleanups)\n        }\n        cleanups.set(rawKey, cleanup)\n      }\n    }\n  }\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe(mutations: MutationRecord[]) {\n  const ignore = `[${aliasify('ignore')}]`\n\n  for (const {\n    target,\n    type,\n    attributeName,\n    addedNodes,\n    removedNodes,\n  } of mutations) {\n    if (type === 'childList') {\n      for (const node of removedNodes) {\n        if (isHTMLOrSVG(node)) {\n          cleanupEls([node])\n          cleanupEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n\n      for (const node of addedNodes) {\n        if (isHTMLOrSVG(node)) {\n          applyEls([node])\n          applyEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n    } else if (type === 'attributes') {\n      // If el has a parent with data-ignore, skip it\n      if (isHTMLOrSVG(target) && !target.closest(ignore)) {\n        const key = camel(attributeName!.slice(5))\n        const value = target.getAttribute(attributeName!)\n        if (value === null) {\n          const cleanups = removals.get(target)\n          if (cleanups) {\n            cleanups.get(key)?.()\n            cleanups.delete(key)\n          }\n        } else {\n          applyAttributePlugin(target, key, value)\n        }\n      }\n    }\n  }\n}\n\nfunction generateReactiveExpression(\n  ctx: RuntimeContext,\n): RuntimeExpressionFunction {\n  let expr = ''\n\n  const attrPlugin = (ctx.plugin as AttributePlugin) || undefined\n\n  // plugin is guaranteed to be an attribute plugin\n  if (attrPlugin?.returnsValue) {\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n    //\n    // The iife support is (intentionally) limited. It only supports\n    // function and arrow syntax with no arguments, and no nested IIFEs.\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm\n    const statements = ctx.value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      expr = statements.join(';\\n')\n    }\n  } else {\n    expr = ctx.value.trim()\n  }\n\n  // Replace signal references with bracket notation\n  // Examples:\n  //   $count          \u2192 $['count']\n  //   $count--        \u2192 $['count']--\n  //   $count++        \u2192 $['count']++\n  //   $count += 5     \u2192 $['count'] += 5\n  //   $foo = 5        \u2192 $['foo'] = 5\n  //   $foo.bar        \u2192 $['foo']['bar']\n  //   $foo-bar        \u2192 $['foo-bar']\n  //   $foo.bar-baz    \u2192 $['foo']['bar-baz']\n  //   $foo-$bar       \u2192 $['foo']-$['bar']\n  //   $arr[$index]    \u2192 $['arr'][$['index']]\n  //   $['foo']        \u2192 $['foo']\n  //   $foo[obj.bar]   \u2192 $['foo'][obj.bar]\n  //   $foo['bar.baz'] \u2192 $['foo']['bar.baz']\n  //   $1              \u2192 $['1']\n  //   $123            \u2192 $['123']\n  //   $foo.0.name     \u2192 $['foo']['0']['name']\n  //   $foo.0.1.2.bar.0 \u2192 $['foo']['0']['1']['2']['bar']['0']\n\n  // Transform all signal patterns\n  expr = expr\n    // $['x'] \u2192 $x (normalize existing bracket notation)\n    .replace(/\\$\\['([a-zA-Z_$\\d][\\w$]*)'\\]/g, '$$$1')\n    // $x \u2192 $['x'] (including dots and hyphens)\n    .replace(/\\$([a-zA-Z_\\d]\\w*(?:[.-]\\w+)*)/g, (_, signalName) => {\n      const parts = signalName.split('.')\n      return parts.reduce(\n        (acc: string, part: string) => `${acc}['${part}']`,\n        '$',\n      )\n    })\n    // $ inside brackets: [$x] \u2192 [$['x']]\n    .replace(\n      /\\[(\\$[a-zA-Z_\\d]\\w*)\\]/g,\n      (_, varName) => `[$['${varName.slice(1)}']]`,\n    )\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  let counter = 0\n  for (const match of expr.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = `dsEscaped${counter++}`\n    escaped.set(v, k)\n    expr = expr.replace(DSP + k + DSS, v)\n  }\n\n  const nameGen = (prefix: string, name: string) => {\n    return `${prefix}${snake(name).replaceAll(/\\./g, '_')}`\n  }\n\n  // Replace any action calls\n  const actionsCalled = new Set<string>()\n  const actionsRe = RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm')\n  const actionMatches = [...expr.matchAll(actionsRe)]\n  const actionNames = new Set<string>()\n  const actionFns = new Set<(...args: any[]) => any>()\n  if (actionMatches.length) {\n    const actionPrefix = `${DATASTAR}Act_`\n    for (const match of actionMatches) {\n      const actionName = match[1]\n      const action = actions[actionName]\n      if (!action) {\n        continue\n      }\n      actionsCalled.add(actionName)\n\n      const name = nameGen(actionPrefix, actionName)\n\n      // Add ctx to action calls\n      expr = expr.replace(`@${actionName}(`, `${name}(`)\n      actionNames.add(name)\n      actionFns.add((...args: any[]) => action.fn(ctx, ...args))\n    }\n  }\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    expr = expr.replace(k, v)\n  }\n\n  ctx.fnContent = expr\n\n  try {\n    const fn = Function(\n      'el',\n      '$',\n      ...(attrPlugin?.argNames || []),\n      ...actionNames,\n      expr,\n    )\n    return (...args: any[]) => {\n      try {\n        return fn(ctx.el, root, ...args, ...actionFns)\n      } catch (e: any) {\n        throw ctx.runtimeErr('ExecuteExpression', {\n          error: e.message,\n        })\n      }\n    }\n  } catch (error: any) {\n    throw ctx.runtimeErr('GenerateExpression', {\n      error: error.message,\n    })\n  }\n}\n", "import { apply, load, setAlias } from '../engine'\n\napply()\n\nexport { apply, load, setAlias }\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "isHTMLOrSVG", "el", "isPojo", "obj", "pathToObj", "paths", "result", "path", "value", "keys", "lastKey", "obj", "acc", "key", "kebab", "str", "camel", "x", "snake", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "r", "snake", "q", "c", "initErr", "ctx", "reason", "metadata", "errCtx", "dserr", "runtimeErr", "DATASTAR_SIGNAL_PATCH_EVENT", "DATASTAR", "currentPatch", "queuedEffects", "batchDepth", "notifyIndex", "queuedEffectsLength", "activeSub", "startBatch", "endBatch", "flush", "dispatch", "signal", "initialValue", "signalOper", "value_", "flags_", "computedSymbol", "computed", "getter", "c", "computedOper", "effect", "fn", "e", "fn_", "link", "prev", "setCurrentSub", "effectOper", "peek", "run", "update", "updateComputed", "updateSignal", "sub", "prevSub", "startTracking", "oldValue", "endTracking", "s", "value", "notify", "flags", "subs", "subs_", "sub_", "checkDirty", "deps_", "dep", "dep_", "depFlags", "nextDep_", "shallowPropagate", "newValue", "propagate", "currentValue", "unlink", "prevDep", "depsTail_", "nextDep", "recursedCheck", "subsTail_", "isValidLink", "newLink", "prevDep_", "prevSub_", "nextSub_", "toRemove", "next", "stack", "top", "subSubs", "prev_", "checkDepth", "dirty", "firstSub", "hasMultipleSubs", "nextSub", "subFlags", "checkLink", "depsTail", "getPath", "path", "result", "root", "split", "DELETE", "deep", "prefix", "isArr", "isPojo", "deepObj", "key", "keys", "_", "prop", "diff", "patch", "i", "detail", "pathToObj", "DATASTAR_SIGNAL_PATCH_EVENT", "mergePatch", "ifMissing", "mergeInner", "mergePaths", "paths", "options", "target", "targetParent", "filtered", "include", "exclude", "obj", "node", "toRegExp", "val", "actions", "plugins", "pluginRegexs", "removals", "mutationObserver", "alias", "setAlias", "aliasify", "name", "load", "pluginsToLoad", "plugin", "ctx", "initErr", "a", "b", "lenDiff", "applyEls", "els", "ignore", "el", "applyAttributePlugin", "cleanupEls", "cleanups", "cleanup", "apply", "observe", "attrKey", "rawKey", "camel", "rawModifiers", "hasKey", "hasValue", "runtimeErr", "generateReactiveExpression", "keyReq", "valReq", "rawMod", "label", "mod", "t", "mutations", "type", "attributeName", "addedNodes", "removedNodes", "isHTMLOrSVG", "expr", "attrPlugin", "statementRe", "statements", "lastIdx", "last", "signalName", "acc", "part", "varName", "escaped", "escapeRe", "DSP", "DSS", "counter", "match", "k", "v", "nameGen", "snake", "actionsCalled", "actionsRe", "actionMatches", "actionNames", "actionFns", "actionPrefix", "DATASTAR", "actionName", "action", "args", "error", "apply"]
}
