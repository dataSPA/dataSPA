{
  "version": 3,
  "sources": ["../library/dist/engine/consts.js", "../library/dist/utils/dom.js", "../library/dist/utils/paths.js", "../library/dist/utils/text.js", "../library/dist/engine/errors.js", "../library/dist/engine/types.js", "../library/dist/engine/engine.js", "../library/dist/bundles/datastar-core.js"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source;\nexport const DSP = lol.slice(0, 5);\nexport const DSS = lol.slice(4);\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n// #region Defaults\n// #region Default durations\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n// #endregion\n// #region Default strings\n// #endregion\n// #region Default booleans\n// Should elements be patched using the ViewTransition API?\nexport const DefaultElementsUseViewTransitions = false;\n// Should a given set of signals patch if they are missing?\nexport const DefaultPatchSignalsOnlyIfMissing = false;\n// #endregion\n// #region Enums\n// The mode in which a element is patched into the DOM.\n// Morphs the element into the existing element.\nexport const ElementPatchModeOuter = \"outer\";\n// Replaces the inner HTML of the existing element.\nexport const ElementPatchModeInner = \"inner\";\n// Removes the existing element.\nexport const ElementPatchModeRemove = \"remove\";\n// Replaces the existing element with the new element.\nexport const ElementPatchModeReplace = \"replace\";\n// Prepends the element inside to the existing element.\nexport const ElementPatchModePrepend = \"prepend\";\n// Appends the element inside the existing element.\nexport const ElementPatchModeAppend = \"append\";\n// Inserts the element before the existing element.\nexport const ElementPatchModeBefore = \"before\";\n// Inserts the element after the existing element.\nexport const ElementPatchModeAfter = \"after\";\n// Default value for ElementPatchMode\nexport const DefaultElementPatchMode = ElementPatchModeOuter;\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\n// An event for patching HTML elements into the DOM.\nexport const EventTypePatchElements = \"datastar-patch-elements\";\n// An event for patching signals.\nexport const EventTypePatchSignals = \"datastar-patch-signals\";\n// #endregion\n// #endregion\n", "export function isHTMLOrSVG(el) {\n    return el instanceof HTMLElement || el instanceof SVGElement;\n}\n", "export const isPojo = (obj) => obj !== null &&\n    typeof obj === 'object' &&\n    (Object.getPrototypeOf(obj) === Object.prototype ||\n        Object.getPrototypeOf(obj) === null);\nexport function isEmpty(obj) {\n    for (const prop in obj) {\n        if (Object.hasOwn(obj, prop)) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function updateLeaves(obj, fn) {\n    for (const key in obj) {\n        const val = obj[key];\n        if (isPojo(val) || Array.isArray(val)) {\n            updateLeaves(val, fn);\n        }\n        else {\n            obj[key] = fn(val);\n        }\n    }\n}\nexport const pathToObj = (paths) => {\n    const result = {};\n    for (const [path, value] of paths) {\n        const keys = path.split('.');\n        const lastKey = keys.pop();\n        const obj = keys.reduce((acc, key) => (acc[key] ??= {}), result);\n        obj[lastKey] = value;\n    }\n    return result;\n};\n", "export const isBoolString = (str) => str.trim() === 'true';\nexport const kebab = (str) => str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase();\nexport const camel = (str) => kebab(str).replace(/-./g, (x) => x[1].toUpperCase());\nexport const snake = (str) => kebab(str).replace(/-/g, '_');\nexport const pascal = (str) => camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase());\nexport const jsStrToObject = (raw) => {\n    try {\n        return JSON.parse(raw);\n    }\n    catch {\n        // If JSON parsing fails, try to evaluate as a JavaScript object\n        // This is less safe and should be used with caution\n        return Function(`return (${raw})`)();\n    }\n};\nconst caseFns = { kebab, snake, pascal };\nexport function modifyCasing(str, mods) {\n    for (const c of mods.get('case') || []) {\n        const fn = caseFns[c];\n        if (fn)\n            str = fn(str);\n    }\n    return str;\n}\n", "import { snake } from '../utils/text';\nimport { DATASTAR } from './consts';\nconst url = 'https://data-star.dev/errors';\nfunction dserr(type, reason, metadata = {}) {\n    const e = new Error();\n    e.name = `${DATASTAR} ${type} error`;\n    const r = snake(reason);\n    const q = new URLSearchParams({\n        metadata: JSON.stringify(metadata),\n    }).toString();\n    const c = JSON.stringify(metadata, null, 2);\n    e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`;\n    return e;\n}\nexport function internalErr(from, reason, args = {}) {\n    return dserr('internal', reason, Object.assign({ from }, args));\n}\nexport function initErr(ctx, reason, metadata = {}) {\n    const errCtx = {\n        plugin: {\n            name: ctx.plugin.name,\n            type: ctx.plugin.type,\n        },\n    };\n    return dserr('init', reason, Object.assign(errCtx, metadata));\n}\nexport function runtimeErr(ctx, reason, metadata = {}) {\n    const errCtx = {\n        plugin: {\n            name: ctx.plugin.name,\n            type: ctx.plugin.type,\n        },\n        element: {\n            id: ctx.el.id,\n            tag: ctx.el.tagName,\n        },\n        expression: {\n            rawKey: ctx.rawKey,\n            key: ctx.key,\n            value: ctx.value,\n            // validSignals:\n            fnContent: ctx.fnContent,\n        },\n    };\n    return dserr('runtime', reason, Object.assign(errCtx, metadata));\n}\n", "import { DATASTAR } from './consts';\nexport const DATASTAR_SIGNAL_PATCH_EVENT = `${DATASTAR}-signal-patch`;\n", "import { isHTMLOrSVG } from '../utils/dom';\nimport { isPojo, pathToObj } from '../utils/paths';\nimport { camel, snake } from '../utils/text';\nimport { DATASTAR, DSP, DSS } from './consts';\nimport { initErr, runtimeErr } from './errors';\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from './types';\nvar ReactiveFlags;\n(function (ReactiveFlags) {\n    ReactiveFlags[ReactiveFlags[\"None\"] = 0] = \"None\";\n    ReactiveFlags[ReactiveFlags[\"Mutable\"] = 1] = \"Mutable\";\n    ReactiveFlags[ReactiveFlags[\"Watching\"] = 2] = \"Watching\";\n    ReactiveFlags[ReactiveFlags[\"RecursedCheck\"] = 4] = \"RecursedCheck\";\n    ReactiveFlags[ReactiveFlags[\"Recursed\"] = 8] = \"Recursed\";\n    ReactiveFlags[ReactiveFlags[\"Dirty\"] = 16] = \"Dirty\";\n    ReactiveFlags[ReactiveFlags[\"Pending\"] = 32] = \"Pending\";\n})(ReactiveFlags || (ReactiveFlags = {}));\nvar EffectFlags;\n(function (EffectFlags) {\n    EffectFlags[EffectFlags[\"Queued\"] = 64] = \"Queued\";\n})(EffectFlags || (EffectFlags = {}));\nconst currentPatch = [];\nconst queuedEffects = [];\nlet batchDepth = 0;\nlet notifyIndex = 0;\nlet queuedEffectsLength = 0;\nlet activeSub;\nconst startBatch = () => {\n    batchDepth++;\n};\nconst endBatch = () => {\n    if (!--batchDepth) {\n        flush();\n        dispatch();\n    }\n};\nconst signal = (initialValue) => {\n    return signalOper.bind(0, {\n        previousValue: initialValue,\n        value_: initialValue,\n        flags_: 1,\n    });\n};\nconst computedSymbol = Symbol('computed');\nconst computed = (getter) => {\n    const c = computedOper.bind(0, {\n        flags_: 17,\n        getter,\n    });\n    // @ts-ignore\n    c[computedSymbol] = 1;\n    return c;\n};\nconst effect = (fn) => {\n    const e = {\n        fn_: fn,\n        flags_: 2,\n    };\n    if (activeSub) {\n        link(e, activeSub);\n    }\n    const prev = setCurrentSub(e);\n    startBatch();\n    try {\n        e.fn_();\n    }\n    finally {\n        endBatch();\n        setCurrentSub(prev);\n    }\n    return effectOper.bind(0, e);\n};\nconst peek = (fn) => {\n    const prev = setCurrentSub(undefined);\n    try {\n        return fn();\n    }\n    finally {\n        setCurrentSub(prev);\n    }\n};\nconst flush = () => {\n    while (notifyIndex < queuedEffectsLength) {\n        const effect = queuedEffects[notifyIndex];\n        queuedEffects[notifyIndex++] = undefined;\n        run(effect, (effect.flags_ &= ~EffectFlags.Queued));\n    }\n    notifyIndex = 0;\n    queuedEffectsLength = 0;\n};\nconst update = (signal) => {\n    if ('getter' in signal) {\n        return updateComputed(signal);\n    }\n    return updateSignal(signal, signal.value_);\n};\nconst setCurrentSub = (sub) => {\n    const prevSub = activeSub;\n    activeSub = sub;\n    return prevSub;\n};\nconst updateComputed = (c) => {\n    const prevSub = setCurrentSub(c);\n    startTracking(c);\n    try {\n        const oldValue = c.value_;\n        return oldValue !== (c.value_ = c.getter(oldValue));\n    }\n    finally {\n        setCurrentSub(prevSub);\n        endTracking(c);\n    }\n};\nconst updateSignal = (s, value) => {\n    s.flags_ = 1;\n    return s.previousValue !== (s.previousValue = value);\n};\nconst notify = (e) => {\n    const flags = e.flags_;\n    if (!(flags & EffectFlags.Queued)) {\n        e.flags_ = flags | EffectFlags.Queued;\n        const subs = e.subs_;\n        if (subs) {\n            notify(subs.sub_);\n        }\n        else {\n            queuedEffects[queuedEffectsLength++] = e;\n        }\n    }\n};\nconst run = (e, flags) => {\n    if (flags & 16 ||\n        (flags & 32 && checkDirty(e.deps_, e))) {\n        const prev = setCurrentSub(e);\n        startTracking(e);\n        startBatch();\n        try {\n            e.fn_();\n        }\n        finally {\n            endBatch();\n            setCurrentSub(prev);\n            endTracking(e);\n        }\n        return;\n    }\n    if (flags & 32) {\n        e.flags_ = flags & ~32;\n    }\n    let link = e.deps_;\n    while (link) {\n        const dep = link.dep_;\n        const depFlags = dep.flags_;\n        if (depFlags & EffectFlags.Queued) {\n            run(dep, (dep.flags_ = depFlags & ~EffectFlags.Queued));\n        }\n        link = link.nextDep_;\n    }\n};\nconst computedOper = (c) => {\n    const flags = c.flags_;\n    if (flags & 16 ||\n        (flags & 32 && checkDirty(c.deps_, c))) {\n        if (updateComputed(c)) {\n            const subs = c.subs_;\n            if (subs) {\n                shallowPropagate(subs);\n            }\n        }\n    }\n    else if (flags & 32) {\n        c.flags_ = flags & ~32;\n    }\n    if (activeSub) {\n        link(c, activeSub);\n    }\n    return c.value_;\n};\nconst signalOper = (s, ...value) => {\n    if (value.length) {\n        const newValue = value[0];\n        if (s.value_ !== (s.value_ = newValue)) {\n            s.flags_ = 17;\n            const subs = s.subs_;\n            if (subs) {\n                propagate(subs);\n                if (!batchDepth) {\n                    flush();\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    const currentValue = s.value_;\n    if (s.flags_ & 16) {\n        if (updateSignal(s, currentValue)) {\n            const subs_ = s.subs_;\n            if (subs_) {\n                shallowPropagate(subs_);\n            }\n        }\n    }\n    if (activeSub) {\n        link(s, activeSub);\n    }\n    return currentValue;\n};\nconst effectOper = (e) => {\n    let dep = e.deps_;\n    while (dep) {\n        dep = unlink(dep, e);\n    }\n    const sub = e.subs_;\n    if (sub) {\n        unlink(sub);\n    }\n    e.flags_ = 0;\n};\nconst link = (dep, sub) => {\n    const prevDep = sub.depsTail_;\n    if (prevDep && prevDep.dep_ === dep) {\n        return;\n    }\n    let nextDep;\n    const recursedCheck = sub.flags_ & 4;\n    if (recursedCheck) {\n        nextDep = prevDep ? prevDep.nextDep_ : sub.deps_;\n        if (nextDep && nextDep.dep_ === dep) {\n            sub.depsTail_ = nextDep;\n            return;\n        }\n    }\n    const prevSub = dep.subsTail_;\n    if (prevSub &&\n        prevSub.sub_ === sub &&\n        (!recursedCheck || isValidLink(prevSub, sub))) {\n        return;\n    }\n    const newLink = (sub.depsTail_ =\n        dep.subsTail_ =\n            {\n                dep_: dep,\n                sub_: sub,\n                prevDep_: prevDep,\n                nextDep_: nextDep,\n                prevSub_: prevSub,\n            });\n    if (nextDep) {\n        nextDep.prevDep_ = newLink;\n    }\n    if (prevDep) {\n        prevDep.nextDep_ = newLink;\n    }\n    else {\n        sub.deps_ = newLink;\n    }\n    if (prevSub) {\n        prevSub.nextSub_ = newLink;\n    }\n    else {\n        dep.subs_ = newLink;\n    }\n};\nconst unlink = (link, sub_ = link.sub_) => {\n    const dep_ = link.dep_;\n    const prevDep_ = link.prevDep_;\n    const nextDep_ = link.nextDep_;\n    const nextSub_ = link.nextSub_;\n    const prevSub_ = link.prevSub_;\n    if (nextDep_) {\n        nextDep_.prevDep_ = prevDep_;\n    }\n    else {\n        sub_.depsTail_ = prevDep_;\n    }\n    if (prevDep_) {\n        prevDep_.nextDep_ = nextDep_;\n    }\n    else {\n        sub_.deps_ = nextDep_;\n    }\n    if (nextSub_) {\n        nextSub_.prevSub_ = prevSub_;\n    }\n    else {\n        dep_.subsTail_ = prevSub_;\n    }\n    if (prevSub_) {\n        prevSub_.nextSub_ = nextSub_;\n    }\n    else if (!(dep_.subs_ = nextSub_)) {\n        if ('getter' in dep_) {\n            let toRemove = dep_.deps_;\n            if (toRemove) {\n                dep_.flags_ = 17;\n                do {\n                    toRemove = unlink(toRemove, dep_);\n                } while (toRemove);\n            }\n        }\n        else if (!('previousValue' in dep_)) {\n            effectOper(dep_);\n        }\n    }\n    return nextDep_;\n};\nconst propagate = (link) => {\n    let next = link.nextSub_;\n    let stack;\n    top: while (true) {\n        const sub = link.sub_;\n        let flags = sub.flags_;\n        if (flags & 3) {\n            if (!(flags &\n                60)) {\n                sub.flags_ = flags | 32;\n            }\n            else if (!(flags & 12)) {\n                flags = 0;\n            }\n            else if (!(flags & 4)) {\n                sub.flags_ =\n                    (flags & ~8) |\n                        32;\n            }\n            else if (!(flags & 48) &&\n                isValidLink(link, sub)) {\n                sub.flags_ =\n                    flags | 40;\n                flags &= 1;\n            }\n            else {\n                flags = 0;\n            }\n            if (flags & 2) {\n                notify(sub);\n            }\n            if (flags & 1) {\n                const subSubs = sub.subs_;\n                if (subSubs) {\n                    link = subSubs;\n                    if (subSubs.nextSub_) {\n                        stack = { value_: next, prev_: stack };\n                        next = link.nextSub_;\n                    }\n                    continue;\n                }\n            }\n        }\n        if ((link = next)) {\n            next = link.nextSub_;\n            continue;\n        }\n        while (stack) {\n            link = stack.value_;\n            stack = stack.prev_;\n            if (link) {\n                next = link.nextSub_;\n                continue top;\n            }\n        }\n        break;\n    }\n};\nconst startTracking = (sub) => {\n    sub.depsTail_ = undefined;\n    sub.flags_ =\n        (sub.flags_ &\n            ~56) |\n            4;\n};\nconst endTracking = (sub) => {\n    const depsTail_ = sub.depsTail_;\n    let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_;\n    while (toRemove) {\n        toRemove = unlink(toRemove, sub);\n    }\n    sub.flags_ &= ~4;\n};\nconst checkDirty = (link, sub) => {\n    let stack;\n    let checkDepth = 0;\n    top: while (true) {\n        const dep = link.dep_;\n        const depFlags = dep.flags_;\n        let dirty = false;\n        if (sub.flags_ & 16) {\n            dirty = true;\n        }\n        else if ((depFlags & 17) ===\n            17) {\n            if (update(dep)) {\n                const subs = dep.subs_;\n                if (subs.nextSub_) {\n                    shallowPropagate(subs);\n                }\n                dirty = true;\n            }\n        }\n        else if ((depFlags & 33) ===\n            33) {\n            if (link.nextSub_ || link.prevSub_) {\n                stack = { value_: link, prev_: stack };\n            }\n            link = dep.deps_;\n            sub = dep;\n            ++checkDepth;\n            continue;\n        }\n        if (!dirty && link.nextDep_) {\n            link = link.nextDep_;\n            continue;\n        }\n        while (checkDepth) {\n            --checkDepth;\n            const firstSub = sub.subs_;\n            const hasMultipleSubs = firstSub.nextSub_;\n            if (hasMultipleSubs) {\n                link = stack.value_;\n                stack = stack.prev_;\n            }\n            else {\n                link = firstSub;\n            }\n            if (dirty) {\n                if (update(sub)) {\n                    if (hasMultipleSubs) {\n                        shallowPropagate(firstSub);\n                    }\n                    sub = link.sub_;\n                    continue;\n                }\n            }\n            else {\n                sub.flags_ &= ~32;\n            }\n            sub = link.sub_;\n            if (link.nextDep_) {\n                link = link.nextDep_;\n                continue top;\n            }\n            dirty = false;\n        }\n        return dirty;\n    }\n};\nconst shallowPropagate = (link) => {\n    do {\n        const sub = link.sub_;\n        const nextSub = link.nextSub_;\n        const subFlags = sub.flags_;\n        if ((subFlags & 48) ===\n            32) {\n            sub.flags_ = subFlags | 16;\n            if (subFlags & 2) {\n                notify(sub);\n            }\n        }\n        link = nextSub;\n    } while (link);\n};\nconst isValidLink = (checkLink, sub) => {\n    const depsTail = sub.depsTail_;\n    if (depsTail) {\n        let link = sub.deps_;\n        do {\n            if (link === checkLink) {\n                return true;\n            }\n            if (link === depsTail) {\n                break;\n            }\n            link = link.nextDep_;\n        } while (link);\n    }\n    return false;\n};\nconst getPath = (path) => {\n    let result = root;\n    const split = path.split('.');\n    for (const path of split) {\n        if (result == null || !Object.hasOwn(result, path)) {\n            return;\n        }\n        result = result[path];\n    }\n    return result;\n};\nexport const DELETE = Symbol('delete');\nconst deep = (value, prefix = '') => {\n    const isArr = Array.isArray(value);\n    if (isArr || isPojo(value)) {\n        const deepObj = (isArr ? [] : {});\n        for (const key in value) {\n            deepObj[key] = signal(deep(value[key], `${prefix + key}.`));\n        }\n        const keys = signal(0);\n        return new Proxy(deepObj, {\n            get(_, prop) {\n                if (!(prop === 'toJSON' && !Object.hasOwn(deepObj, prop))) {\n                    if (isArr && prop in Array.prototype) {\n                        keys();\n                        return deepObj[prop];\n                    }\n                    else {\n                        if (typeof prop === 'symbol') {\n                            return deepObj[prop];\n                        }\n                        if (!Object.hasOwn(deepObj, prop) || deepObj[prop]() == null) {\n                            deepObj[prop] = signal('');\n                            dispatch(prefix + prop, '');\n                            keys(keys() + 1);\n                        }\n                        return deepObj[prop]();\n                    }\n                }\n            },\n            set(_, prop, newValue) {\n                const path = prefix + prop;\n                if (newValue === DELETE) {\n                    if (Object.hasOwn(deepObj, prop)) {\n                        delete deepObj[prop];\n                        dispatch(path, DELETE);\n                        keys(keys() + 1);\n                    }\n                }\n                else {\n                    if (isArr && prop === 'length') {\n                        const diff = deepObj[prop] - newValue;\n                        deepObj[prop] = newValue;\n                        if (diff > 0) {\n                            const patch = {};\n                            for (let i = newValue; i < deepObj[prop]; i++) {\n                                patch[i] = null;\n                            }\n                            dispatch(prefix.slice(0, -1), patch);\n                            keys(keys() + 1);\n                        }\n                    }\n                    else {\n                        if (Object.hasOwn(deepObj, prop)) {\n                            if (newValue == null) {\n                                if (deepObj[prop](null)) {\n                                    dispatch(path, null);\n                                }\n                            }\n                            else {\n                                if (Object.hasOwn(newValue, computedSymbol)) {\n                                    deepObj[prop] = newValue;\n                                    dispatch(path, '');\n                                }\n                                else {\n                                    if (deepObj[prop](deep(newValue, `${path}.`))) {\n                                        dispatch(path, newValue);\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            if (newValue != null) {\n                                if (Object.hasOwn(newValue, computedSymbol)) {\n                                    deepObj[prop] = newValue;\n                                    dispatch(path, '');\n                                }\n                                else {\n                                    deepObj[prop] = signal(deep(newValue, `${path}.`));\n                                    dispatch(path, newValue);\n                                }\n                                keys(keys() + 1);\n                            }\n                        }\n                    }\n                }\n                return true;\n            },\n            deleteProperty(_, prop) {\n                if (Object.hasOwn(deepObj, prop)) {\n                    if (deepObj[prop](null)) {\n                        dispatch(prefix + prop, null);\n                    }\n                }\n                return true;\n            },\n            ownKeys() {\n                keys();\n                return Reflect.ownKeys(deepObj);\n            },\n            has(_, prop) {\n                keys();\n                return prop in deepObj;\n            },\n        });\n    }\n    return value;\n};\nconst dispatch = (path, value) => {\n    if (path !== undefined && value !== undefined) {\n        currentPatch.push([path, value]);\n    }\n    if (!batchDepth && currentPatch.length) {\n        const detail = pathToObj(currentPatch);\n        currentPatch.length = 0;\n        document.dispatchEvent(new CustomEvent(DATASTAR_SIGNAL_PATCH_EVENT, {\n            detail,\n        }));\n    }\n};\nconst mergePatch = (patch, { ifMissing } = {}) => {\n    startBatch();\n    for (const key in patch) {\n        if (patch[key] == null) {\n            if (!ifMissing) {\n                delete root[key];\n            }\n        }\n        else {\n            mergeInner(patch[key], key, root, '', ifMissing);\n        }\n    }\n    endBatch();\n};\nconst mergePaths = (paths, options = {}) => mergePatch(pathToObj(paths), options);\nconst mergeInner = (patch, target, targetParent, prefix, ifMissing) => {\n    if (isPojo(patch)) {\n        if (!(Object.hasOwn(targetParent, target) &&\n            (isPojo(targetParent[target]) || Array.isArray(targetParent[target])))) {\n            targetParent[target] = {};\n        }\n        for (const key in patch) {\n            if (patch[key] == null) {\n                if (!ifMissing) {\n                    delete targetParent[target][key];\n                }\n            }\n            else {\n                mergeInner(patch[key], key, targetParent[target], `${prefix + target}.`, ifMissing);\n            }\n        }\n    }\n    else if (!(ifMissing && Object.hasOwn(targetParent, target))) {\n        targetParent[target] = patch;\n    }\n};\nfunction filtered({ include = /.*/, exclude = /(?!)/ } = {}, obj = root) {\n    // We need to find all valid signal paths in the object\n    const paths = [];\n    const stack = [[obj, '']];\n    while (stack.length) {\n        const [node, prefix] = stack.pop();\n        for (const key in node) {\n            const path = prefix + key;\n            if (isPojo(node[key])) {\n                stack.push([node[key], `${path}.`]);\n            }\n            else if (toRegExp(include).test(path) &&\n                !toRegExp(exclude).test(path)) {\n                paths.push([path, getPath(path)]);\n            }\n        }\n    }\n    return pathToObj(paths);\n}\nfunction toRegExp(val) {\n    if (typeof val === 'string') {\n        return RegExp(val.replace(/^\\/|\\/$/g, ''));\n    }\n    return val;\n}\nconst root = deep({});\n/**\n * Turn data-* attributes into reactive expressions\n * This is the core of the Datastar\n */\nconst actions = {};\nconst plugins = [];\nlet pluginRegexs = [];\n// Map of cleanup functions by element, keyed by a dataset key-value hash\nconst removals = new Map();\nlet mutationObserver = null;\nlet alias = '';\nexport function setAlias(value) {\n    alias = value;\n}\nexport function aliasify(name) {\n    return alias ? `data-${alias}-${name}` : `data-${name}`;\n}\nexport function load(...pluginsToLoad) {\n    for (const plugin of pluginsToLoad) {\n        const ctx = {\n            plugin,\n            actions,\n            root,\n            filtered,\n            signal,\n            computed,\n            effect,\n            mergePatch,\n            mergePaths,\n            peek,\n            getPath,\n            startBatch,\n            endBatch,\n            initErr: 0,\n        };\n        ctx.initErr = initErr.bind(0, ctx);\n        if (plugin.type === 'action') {\n            actions[plugin.name] = plugin;\n        }\n        else if (plugin.type === 'attribute') {\n            plugins.push(plugin);\n            plugin.onGlobalInit?.(ctx);\n        }\n        else if (plugin.type === 'watcher') {\n            plugin.onGlobalInit?.(ctx);\n        }\n        else {\n            throw ctx.initErr('InvalidPluginType');\n        }\n    }\n    // Sort attribute plugins by descending length then alphabetically\n    plugins.sort((a, b) => {\n        const lenDiff = b.name.length - a.name.length;\n        if (lenDiff !== 0)\n            return lenDiff;\n        return a.name.localeCompare(b.name);\n    });\n    pluginRegexs = plugins.map((plugin) => RegExp(`^${plugin.name}([A-Z]|_|$)`));\n}\nfunction applyEls(els) {\n    const ignore = `[${aliasify('ignore')}]`;\n    for (const el of els) {\n        if (!el.closest(ignore)) {\n            for (const key in el.dataset) {\n                applyAttributePlugin(el, key, el.dataset[key]);\n            }\n        }\n    }\n}\nfunction cleanupEls(els) {\n    for (const el of els) {\n        const cleanups = removals.get(el);\n        // If removals has el, delete it and run all cleanup functions\n        if (removals.delete(el)) {\n            for (const cleanup of cleanups.values()) {\n                cleanup();\n            }\n            cleanups.clear();\n        }\n    }\n}\n// Apply all plugins to the entire DOM or a provided element\nexport function apply(root = document.body) {\n    // Delay applying plugins to give custom plugins a chance to load\n    queueMicrotask(() => {\n        applyEls([root]);\n        applyEls(root.querySelectorAll('*'));\n        // Monitor the entire document body or a provided element for changes\n        // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n        if (!mutationObserver) {\n            mutationObserver = new MutationObserver(observe);\n            mutationObserver.observe(root, {\n                subtree: true,\n                childList: true,\n                attributes: true,\n            });\n        }\n    });\n}\nfunction applyAttributePlugin(el, attrKey, value) {\n    if (attrKey.startsWith(alias)) {\n        const rawKey = camel(alias ? attrKey.slice(alias.length) : attrKey);\n        const plugin = plugins.find((_, i) => pluginRegexs[i].test(rawKey));\n        if (plugin) {\n            // Extract the key and modifiers\n            let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/__+/);\n            const hasKey = !!key;\n            if (hasKey) {\n                key = camel(key);\n            }\n            const hasValue = !!value;\n            // Create the runtime context\n            const ctx = {\n                plugin,\n                actions,\n                root,\n                filtered,\n                signal,\n                computed,\n                effect,\n                mergePatch,\n                mergePaths,\n                peek,\n                getPath,\n                startBatch,\n                endBatch,\n                initErr: 0,\n                el,\n                rawKey,\n                key,\n                value,\n                mods: new Map(),\n                runtimeErr: 0,\n                rx: 0,\n            };\n            ctx.initErr = initErr.bind(0, ctx);\n            ctx.runtimeErr = runtimeErr.bind(0, ctx);\n            if (plugin.shouldEvaluate === undefined ||\n                plugin.shouldEvaluate === true) {\n                ctx.rx = generateReactiveExpression(ctx);\n            }\n            // Check the requirements\n            const keyReq = plugin.keyReq || 'allowed';\n            if (hasKey) {\n                if (keyReq === 'denied') {\n                    throw ctx.runtimeErr(`${plugin.name}KeyNotAllowed`);\n                }\n            }\n            else if (keyReq === 'must') {\n                throw ctx.runtimeErr(`${plugin.name}KeyRequired`);\n            }\n            const valReq = plugin.valReq || 'allowed';\n            if (hasValue) {\n                if (valReq === 'denied') {\n                    throw ctx.runtimeErr(`${plugin.name}ValueNotAllowed`);\n                }\n            }\n            else if (valReq === 'must') {\n                throw ctx.runtimeErr(`${plugin.name}ValueRequired`);\n            }\n            // Check for exclusive requirements\n            if (keyReq === 'exclusive' || valReq === 'exclusive') {\n                if (hasKey && hasValue) {\n                    throw ctx.runtimeErr(`${plugin.name}KeyAndValueProvided`);\n                }\n                if (!hasKey && !hasValue) {\n                    throw ctx.runtimeErr(`${plugin.name}KeyOrValueRequired`);\n                }\n            }\n            for (const rawMod of rawModifiers) {\n                const [label, ...mod] = rawMod.split('.');\n                ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())));\n            }\n            const cleanup = plugin.onLoad(ctx);\n            if (cleanup) {\n                let cleanups = removals.get(el);\n                if (cleanups) {\n                    cleanups.get(rawKey)?.();\n                }\n                else {\n                    cleanups = new Map();\n                    removals.set(el, cleanups);\n                }\n                cleanups.set(rawKey, cleanup);\n            }\n        }\n    }\n}\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe(mutations) {\n    const ignore = `[${aliasify('ignore')}]`;\n    for (const { target, type, attributeName, addedNodes, removedNodes, } of mutations) {\n        if (type === 'childList') {\n            for (const node of removedNodes) {\n                if (isHTMLOrSVG(node)) {\n                    cleanupEls([node]);\n                    cleanupEls(node.querySelectorAll('*'));\n                }\n            }\n            for (const node of addedNodes) {\n                if (isHTMLOrSVG(node)) {\n                    applyEls([node]);\n                    applyEls(node.querySelectorAll('*'));\n                }\n            }\n        }\n        else if (type === 'attributes') {\n            // If el has a parent with data-ignore, skip it\n            if (isHTMLOrSVG(target) && !target.closest(ignore)) {\n                const key = camel(attributeName.slice(5));\n                const value = target.getAttribute(attributeName);\n                if (value === null) {\n                    const cleanups = removals.get(target);\n                    if (cleanups) {\n                        cleanups.get(key)?.();\n                        cleanups.delete(key);\n                    }\n                }\n                else {\n                    applyAttributePlugin(target, key, value);\n                }\n            }\n        }\n    }\n}\nfunction generateReactiveExpression(ctx) {\n    let expr = '';\n    const attrPlugin = ctx.plugin || undefined;\n    // plugin is guaranteed to be an attribute plugin\n    if (attrPlugin?.returnsValue) {\n        // This regex allows Datastar expressions to support nested\n        // regex and strings that contain ; without breaking.\n        //\n        // Each of these regex defines a block type we want to match\n        // (importantly we ignore the content within these blocks):\n        //\n        // regex            \\/(\\\\\\/|[^\\/])*\\/\n        // double quotes      \"(\\\\\"|[^\\\"])*\"\n        // single quotes      '(\\\\'|[^'])*'\n        // ticks              `(\\\\`|[^`])*`\n        // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n        //\n        // The iife support is (intentionally) limited. It only supports\n        // function and arrow syntax with no arguments, and no nested IIFEs.\n        //\n        // We also want to match the non delimiter part of statements\n        // note we only support ; statement delimiters:\n        //\n        // [^;]\n        //\n        const statementRe = /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm;\n        const statements = ctx.value.trim().match(statementRe);\n        if (statements) {\n            const lastIdx = statements.length - 1;\n            const last = statements[lastIdx].trim();\n            if (!last.startsWith('return')) {\n                statements[lastIdx] = `return (${last});`;\n            }\n            expr = statements.join(';\\n');\n        }\n    }\n    else {\n        expr = ctx.value.trim();\n    }\n    // Replace signal references with bracket notation\n    // Examples:\n    //   $count          \u2192 $['count']\n    //   $count--        \u2192 $['count']--\n    //   $count++        \u2192 $['count']++\n    //   $count += 5     \u2192 $['count'] += 5\n    //   $foo = 5        \u2192 $['foo'] = 5\n    //   $foo.bar        \u2192 $['foo']['bar']\n    //   $foo-bar        \u2192 $['foo-bar']\n    //   $foo.bar-baz    \u2192 $['foo']['bar-baz']\n    //   $foo-$bar       \u2192 $['foo']-$['bar']\n    //   $arr[$index]    \u2192 $['arr'][$['index']]\n    //   $['foo']        \u2192 $['foo']\n    //   $foo[obj.bar]   \u2192 $['foo'][obj.bar]\n    //   $foo['bar.baz'] \u2192 $['foo']['bar.baz']\n    //   $1              \u2192 $['1']\n    //   $123            \u2192 $['123']\n    //   $foo.0.name     \u2192 $['foo']['0']['name']\n    //   $foo.0.1.2.bar.0 \u2192 $['foo']['0']['1']['2']['bar']['0']\n    // Transform all signal patterns\n    expr = expr\n        // $['x'] \u2192 $x (normalize existing bracket notation)\n        .replace(/\\$\\['([a-zA-Z_$\\d][\\w$]*)'\\]/g, '$$$1')\n        // $x \u2192 $['x'] (including dots and hyphens)\n        .replace(/\\$([a-zA-Z_\\d]\\w*(?:[.-]\\w+)*)/g, (_, signalName) => {\n        const parts = signalName.split('.');\n        return parts.reduce((acc, part) => `${acc}['${part}']`, '$');\n    })\n        // $ inside brackets: [$x] \u2192 [$['x']]\n        .replace(/\\[(\\$[a-zA-Z_\\d]\\w*)\\]/g, (_, varName) => `[$['${varName.slice(1)}']]`);\n    // Ignore any escaped values\n    const escaped = new Map();\n    const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm');\n    let counter = 0;\n    for (const match of expr.matchAll(escapeRe)) {\n        const k = match[1];\n        const v = `dsEscaped${counter++}`;\n        escaped.set(v, k);\n        expr = expr.replace(DSP + k + DSS, v);\n    }\n    const nameGen = (prefix, name) => {\n        return `${prefix}${snake(name).replaceAll(/\\./g, '_')}`;\n    };\n    // Replace any action calls\n    const actionsCalled = new Set();\n    const actionsRe = RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm');\n    const actionMatches = [...expr.matchAll(actionsRe)];\n    const actionNames = new Set();\n    const actionFns = new Set();\n    if (actionMatches.length) {\n        const actionPrefix = `${DATASTAR}Act_`;\n        for (const match of actionMatches) {\n            const actionName = match[1];\n            const action = actions[actionName];\n            if (!action) {\n                continue;\n            }\n            actionsCalled.add(actionName);\n            const name = nameGen(actionPrefix, actionName);\n            // Add ctx to action calls\n            expr = expr.replace(`@${actionName}(`, `${name}(`);\n            actionNames.add(name);\n            actionFns.add((...args) => action.fn(ctx, ...args));\n        }\n    }\n    // Replace any escaped values\n    for (const [k, v] of escaped) {\n        expr = expr.replace(k, v);\n    }\n    ctx.fnContent = expr;\n    try {\n        const fn = Function('el', '$', ...(attrPlugin?.argNames || []), ...actionNames, expr);\n        return (...args) => {\n            try {\n                return fn(ctx.el, root, ...args, ...actionFns);\n            }\n            catch (e) {\n                throw ctx.runtimeErr('ExecuteExpression', {\n                    error: e.message,\n                });\n            }\n        };\n    }\n    catch (error) {\n        throw ctx.runtimeErr('GenerateExpression', {\n            error: error.message,\n        });\n    }\n}\n", "import { apply, load, setAlias } from '../engine';\napply();\nexport { apply, load, setAlias };\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "isHTMLOrSVG", "el", "isPojo", "obj", "pathToObj", "paths", "result", "path", "value", "keys", "lastKey", "obj", "acc", "key", "kebab", "str", "camel", "x", "snake", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "r", "snake", "q", "c", "initErr", "ctx", "reason", "metadata", "errCtx", "dserr", "runtimeErr", "DATASTAR_SIGNAL_PATCH_EVENT", "DATASTAR", "ReactiveFlags", "EffectFlags", "currentPatch", "queuedEffects", "batchDepth", "notifyIndex", "queuedEffectsLength", "activeSub", "startBatch", "endBatch", "flush", "dispatch", "signal", "initialValue", "signalOper", "computedSymbol", "computed", "getter", "c", "computedOper", "effect", "fn", "e", "link", "prev", "setCurrentSub", "effectOper", "peek", "run", "update", "updateComputed", "updateSignal", "sub", "prevSub", "startTracking", "oldValue", "endTracking", "s", "value", "notify", "flags", "subs", "checkDirty", "dep", "depFlags", "shallowPropagate", "newValue", "propagate", "currentValue", "subs_", "unlink", "prevDep", "nextDep", "recursedCheck", "isValidLink", "newLink", "sub_", "dep_", "prevDep_", "nextDep_", "nextSub_", "prevSub_", "toRemove", "next", "stack", "top", "subSubs", "depsTail_", "checkDepth", "dirty", "firstSub", "hasMultipleSubs", "nextSub", "subFlags", "checkLink", "depsTail", "getPath", "path", "result", "root", "split", "DELETE", "deep", "prefix", "isArr", "isPojo", "deepObj", "key", "keys", "_", "prop", "diff", "patch", "i", "detail", "pathToObj", "DATASTAR_SIGNAL_PATCH_EVENT", "mergePatch", "ifMissing", "mergeInner", "mergePaths", "paths", "options", "target", "targetParent", "filtered", "include", "exclude", "obj", "node", "toRegExp", "val", "actions", "plugins", "pluginRegexs", "removals", "mutationObserver", "alias", "setAlias", "aliasify", "name", "load", "pluginsToLoad", "plugin", "ctx", "initErr", "a", "b", "lenDiff", "applyEls", "els", "ignore", "el", "applyAttributePlugin", "cleanupEls", "cleanups", "cleanup", "apply", "observe", "attrKey", "rawKey", "camel", "rawModifiers", "hasKey", "hasValue", "runtimeErr", "generateReactiveExpression", "keyReq", "valReq", "rawMod", "label", "mod", "t", "mutations", "type", "attributeName", "addedNodes", "removedNodes", "isHTMLOrSVG", "expr", "attrPlugin", "statementRe", "statements", "lastIdx", "last", "signalName", "acc", "part", "varName", "escaped", "escapeRe", "DSP", "DSS", "counter", "match", "k", "v", "nameGen", "snake", "actionsCalled", "actionsRe", "actionMatches", "actionNames", "actionFns", "actionPrefix", "DATASTAR", "actionName", "action", "args", "error", "apply"]
}
